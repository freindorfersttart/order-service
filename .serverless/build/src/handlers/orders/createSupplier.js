"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@prisma/client/runtime/binary.js
var require_binary = __commonJS({
  "node_modules/@prisma/client/runtime/binary.js"(exports2, module2) {
    "use strict";
    var mb = Object.create;
    var co = Object.defineProperty;
    var yb = Object.getOwnPropertyDescriptor;
    var wb = Object.getOwnPropertyNames;
    var Db = Object.getPrototypeOf;
    var Rb = Object.prototype.hasOwnProperty;
    var $h = (t, e) => () => (t && (e = t(t = 0)), e);
    var C = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
    var Jn = (t, e) => {
      for (var r in e) co(t, r, { get: e[r], enumerable: true });
    };
    var zh = (t, e, r, n) => {
      if (e && typeof e == "object" || typeof e == "function") for (let A of wb(e)) !Rb.call(t, A) && A !== r && co(t, A, { get: () => e[A], enumerable: !(n = yb(e, A)) || n.enumerable });
      return t;
    };
    var G = (t, e, r) => (r = t != null ? mb(Db(t)) : {}, zh(e || !t || !t.__esModule ? co(r, "default", { value: t, enumerable: true }) : r, t));
    var Sb = (t) => zh(co({}, "__esModule", { value: true }), t);
    var Df = C((i9, wf) => {
      "use strict";
      wf.exports = yf;
      yf.sync = dN;
      var Bf = require("node:fs");
      function EN(t, e) {
        var r = e.pathExt !== void 0 ? e.pathExt : process.env.PATHEXT;
        if (!r || (r = r.split(";"), r.indexOf("") !== -1)) return true;
        for (var n = 0; n < r.length; n++) {
          var A = r[n].toLowerCase();
          if (A && t.substr(-A.length).toLowerCase() === A) return true;
        }
        return false;
      }
      function mf(t, e, r) {
        return !t.isSymbolicLink() && !t.isFile() ? false : EN(e, r);
      }
      function yf(t, e, r) {
        Bf.stat(t, function(n, A) {
          r(n, n ? false : mf(A, t, e));
        });
      }
      function dN(t, e) {
        return mf(Bf.statSync(t), t, e);
      }
    });
    var Ff = C((s9, Nf) => {
      "use strict";
      Nf.exports = Sf;
      Sf.sync = hN;
      var Rf = require("node:fs");
      function Sf(t, e, r) {
        Rf.stat(t, function(n, A) {
          r(n, n ? false : bf(A, e));
        });
      }
      function hN(t, e) {
        return bf(Rf.statSync(t), e);
      }
      function bf(t, e) {
        return t.isFile() && fN(t, e);
      }
      function fN(t, e) {
        var r = t.mode, n = t.uid, A = t.gid, i = e.uid !== void 0 ? e.uid : process.getuid && process.getuid(), s = e.gid !== void 0 ? e.gid : process.getgid && process.getgid(), o = parseInt("100", 8), a = parseInt("010", 8), c = parseInt("001", 8), l = o | a, u = r & c || r & a && A === s || r & o && n === i || r & l && i === 0;
        return u;
      }
    });
    var xf = C((a9, Tf) => {
      "use strict";
      var o9 = require("node:fs"), Bo;
      process.platform === "win32" || global.TESTING_WINDOWS ? Bo = Df() : Bo = Ff();
      Tf.exports = Jl;
      Jl.sync = QN;
      function Jl(t, e, r) {
        if (typeof e == "function" && (r = e, e = {}), !r) {
          if (typeof Promise != "function") throw new TypeError("callback not provided");
          return new Promise(function(n, A) {
            Jl(t, e || {}, function(i, s) {
              i ? A(i) : n(s);
            });
          });
        }
        Bo(t, e || {}, function(n, A) {
          n && (n.code === "EACCES" || e && e.ignoreErrors) && (n = null, A = false), r(n, A);
        });
      }
      function QN(t, e) {
        try {
          return Bo.sync(t, e || {});
        } catch (r) {
          if (e && e.ignoreErrors || r.code === "EACCES") return false;
          throw r;
        }
      }
    });
    var Yf = C((c9, Pf) => {
      "use strict";
      var _n = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", Uf = require("node:path"), CN = _n ? ";" : ":", kf = xf(), Mf = (t) => Object.assign(new Error(`not found: ${t}`), { code: "ENOENT" }), Lf = (t, e) => {
        let r = e.colon || CN, n = t.match(/\//) || _n && t.match(/\\/) ? [""] : [..._n ? [process.cwd()] : [], ...(e.path || process.env.PATH || "").split(r)], A = _n ? e.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", i = _n ? A.split(r) : [""];
        return _n && t.indexOf(".") !== -1 && i[0] !== "" && i.unshift(""), { pathEnv: n, pathExt: i, pathExtExe: A };
      }, vf = (t, e, r) => {
        typeof e == "function" && (r = e, e = {}), e || (e = {});
        let { pathEnv: n, pathExt: A, pathExtExe: i } = Lf(t, e), s = [], o = (c) => new Promise((l, u) => {
          if (c === n.length) return e.all && s.length ? l(s) : u(Mf(t));
          let g = n[c], E = /^".*"$/.test(g) ? g.slice(1, -1) : g, h = Uf.join(E, t), f = !E && /^\.[\\\/]/.test(t) ? t.slice(0, 2) + h : h;
          l(a(f, c, 0));
        }), a = (c, l, u) => new Promise((g, E) => {
          if (u === A.length) return g(o(l + 1));
          let h = A[u];
          kf(c + h, { pathExt: i }, (f, p) => {
            if (!f && p) if (e.all) s.push(c + h);
            else return g(c + h);
            return g(a(c, l, u + 1));
          });
        });
        return r ? o(0).then((c) => r(null, c), r) : o(0);
      }, IN = (t, e) => {
        e = e || {};
        let { pathEnv: r, pathExt: n, pathExtExe: A } = Lf(t, e), i = [];
        for (let s = 0; s < r.length; s++) {
          let o = r[s], a = /^".*"$/.test(o) ? o.slice(1, -1) : o, c = Uf.join(a, t), l = !a && /^\.[\\\/]/.test(t) ? t.slice(0, 2) + c : c;
          for (let u = 0; u < n.length; u++) {
            let g = l + n[u];
            try {
              if (kf.sync(g, { pathExt: A })) if (e.all) i.push(g);
              else return g;
            } catch {
            }
          }
        }
        if (e.all && i.length) return i;
        if (e.nothrow) return null;
        throw Mf(t);
      };
      Pf.exports = vf;
      vf.sync = IN;
    });
    var _l = C((l9, Wl) => {
      "use strict";
      var Gf = (t = {}) => {
        let e = t.env || process.env;
        return (t.platform || process.platform) !== "win32" ? "PATH" : Object.keys(e).reverse().find((n) => n.toUpperCase() === "PATH") || "Path";
      };
      Wl.exports = Gf;
      Wl.exports.default = Gf;
    });
    var qf = C((u9, Hf) => {
      "use strict";
      var Of = require("node:path"), pN = Yf(), BN = _l();
      function Vf(t, e) {
        let r = t.options.env || process.env, n = process.cwd(), A = t.options.cwd != null, i = A && process.chdir !== void 0 && !process.chdir.disabled;
        if (i) try {
          process.chdir(t.options.cwd);
        } catch {
        }
        let s;
        try {
          s = pN.sync(t.command, { path: r[BN({ env: r })], pathExt: e ? Of.delimiter : void 0 });
        } catch {
        } finally {
          i && process.chdir(n);
        }
        return s && (s = Of.resolve(A ? t.options.cwd : "", s)), s;
      }
      function mN(t) {
        return Vf(t) || Vf(t, true);
      }
      Hf.exports = mN;
    });
    var Jf = C((g9, Zl) => {
      "use strict";
      var jl = /([()\][%!^"`<>&|;, *?])/g;
      function yN(t) {
        return t = t.replace(jl, "^$1"), t;
      }
      function wN(t, e) {
        return t = `${t}`, t = t.replace(/(\\*)"/g, '$1$1\\"'), t = t.replace(/(\\*)$/, "$1$1"), t = `"${t}"`, t = t.replace(jl, "^$1"), e && (t = t.replace(jl, "^$1")), t;
      }
      Zl.exports.command = yN;
      Zl.exports.argument = wN;
    });
    var _f = C((E9, Wf) => {
      "use strict";
      Wf.exports = /^#!(.*)/;
    });
    var Zf = C((d9, jf) => {
      "use strict";
      var DN = _f();
      jf.exports = (t = "") => {
        let e = t.match(DN);
        if (!e) return null;
        let [r, n] = e[0].replace(/#! ?/, "").split(" "), A = r.split("/").pop();
        return A === "env" ? n : n ? `${A} ${n}` : A;
      };
    });
    var Kf = C((h9, Xf) => {
      "use strict";
      var Xl = require("node:fs"), RN = Zf();
      function SN(t) {
        let r = Buffer.alloc(150), n;
        try {
          n = Xl.openSync(t, "r"), Xl.readSync(n, r, 0, 150, 0), Xl.closeSync(n);
        } catch {
        }
        return RN(r.toString());
      }
      Xf.exports = SN;
    });
    var tQ = C((f9, eQ) => {
      "use strict";
      var bN = require("node:path"), $f = qf(), zf = Jf(), NN = Kf(), FN = process.platform === "win32", TN = /\.(?:com|exe)$/i, xN = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
      function UN(t) {
        t.file = $f(t);
        let e = t.file && NN(t.file);
        return e ? (t.args.unshift(t.file), t.command = e, $f(t)) : t.file;
      }
      function kN(t) {
        if (!FN) return t;
        let e = UN(t), r = !TN.test(e);
        if (t.options.forceShell || r) {
          let n = xN.test(e);
          t.command = bN.normalize(t.command), t.command = zf.command(t.command), t.args = t.args.map((i) => zf.argument(i, n));
          let A = [t.command].concat(t.args).join(" ");
          t.args = ["/d", "/s", "/c", `"${A}"`], t.command = process.env.comspec || "cmd.exe", t.options.windowsVerbatimArguments = true;
        }
        return t;
      }
      function MN(t, e, r) {
        e && !Array.isArray(e) && (r = e, e = null), e = e ? e.slice(0) : [], r = Object.assign({}, r);
        let n = { command: t, args: e, options: r, file: void 0, original: { command: t, args: e } };
        return r.shell ? n : kN(n);
      }
      eQ.exports = MN;
    });
    var AQ = C((Q9, nQ) => {
      "use strict";
      var Kl = process.platform === "win32";
      function $l(t, e) {
        return Object.assign(new Error(`${e} ${t.command} ENOENT`), { code: "ENOENT", errno: "ENOENT", syscall: `${e} ${t.command}`, path: t.command, spawnargs: t.args });
      }
      function LN(t, e) {
        if (!Kl) return;
        let r = t.emit;
        t.emit = function(n, A) {
          if (n === "exit") {
            let i = rQ(A, e, "spawn");
            if (i) return r.call(t, "error", i);
          }
          return r.apply(t, arguments);
        };
      }
      function rQ(t, e) {
        return Kl && t === 1 && !e.file ? $l(e.original, "spawn") : null;
      }
      function vN(t, e) {
        return Kl && t === 1 && !e.file ? $l(e.original, "spawnSync") : null;
      }
      nQ.exports = { hookChildProcess: LN, verifyENOENT: rQ, verifyENOENTSync: vN, notFoundError: $l };
    });
    var oQ = C((C9, jn) => {
      "use strict";
      var iQ = require("node:child_process"), zl = tQ(), eu = AQ();
      function sQ(t, e, r) {
        let n = zl(t, e, r), A = iQ.spawn(n.command, n.args, n.options);
        return eu.hookChildProcess(A, n), A;
      }
      function PN(t, e, r) {
        let n = zl(t, e, r), A = iQ.spawnSync(n.command, n.args, n.options);
        return A.error = A.error || eu.verifyENOENTSync(A.status, n), A;
      }
      jn.exports = sQ;
      jn.exports.spawn = sQ;
      jn.exports.sync = PN;
      jn.exports._parse = zl;
      jn.exports._enoent = eu;
    });
    var cQ = C((I9, aQ) => {
      "use strict";
      aQ.exports = (t) => {
        let e = typeof t == "string" ? `
` : 10, r = typeof t == "string" ? "\r" : 13;
        return t[t.length - 1] === e && (t = t.slice(0, t.length - 1)), t[t.length - 1] === r && (t = t.slice(0, t.length - 1)), t;
      };
    });
    var gQ = C((p9, pi) => {
      "use strict";
      var Ii = require("node:path"), lQ = _l(), uQ = (t) => {
        t = { cwd: process.cwd(), path: process.env[lQ()], execPath: process.execPath, ...t };
        let e, r = Ii.resolve(t.cwd), n = [];
        for (; e !== r; ) n.push(Ii.join(r, "node_modules/.bin")), e = r, r = Ii.resolve(r, "..");
        let A = Ii.resolve(t.cwd, t.execPath, "..");
        return n.push(A), n.concat(t.path).join(Ii.delimiter);
      };
      pi.exports = uQ;
      pi.exports.default = uQ;
      pi.exports.env = (t) => {
        t = { env: process.env, ...t };
        let e = { ...t.env }, r = lQ({ env: e });
        return t.path = e[r], e[r] = pi.exports(t), e;
      };
    });
    var dQ = C((B9, tu) => {
      "use strict";
      var EQ = (t, e) => {
        for (let r of Reflect.ownKeys(e)) Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(e, r));
        return t;
      };
      tu.exports = EQ;
      tu.exports.default = EQ;
    });
    var fQ = C((m9, yo) => {
      "use strict";
      var YN = dQ(), mo = /* @__PURE__ */ new WeakMap(), hQ = (t, e = {}) => {
        if (typeof t != "function") throw new TypeError("Expected a function");
        let r, n = 0, A = t.displayName || t.name || "<anonymous>", i = function(...s) {
          if (mo.set(i, ++n), n === 1) r = t.apply(this, s), t = null;
          else if (e.throw === true) throw new Error(`Function \`${A}\` can only be called once`);
          return r;
        };
        return YN(i, t), mo.set(i, n), i;
      };
      yo.exports = hQ;
      yo.exports.default = hQ;
      yo.exports.callCount = (t) => {
        if (!mo.has(t)) throw new Error(`The given function \`${t.name}\` is not wrapped by the \`onetime\` package`);
        return mo.get(t);
      };
    });
    var QQ = C((wo) => {
      "use strict";
      Object.defineProperty(wo, "__esModule", { value: true });
      wo.SIGNALS = void 0;
      var GN = [{ name: "SIGHUP", number: 1, action: "terminate", description: "Terminal closed", standard: "posix" }, { name: "SIGINT", number: 2, action: "terminate", description: "User interruption with CTRL-C", standard: "ansi" }, { name: "SIGQUIT", number: 3, action: "core", description: "User interruption with CTRL-\\", standard: "posix" }, { name: "SIGILL", number: 4, action: "core", description: "Invalid machine instruction", standard: "ansi" }, { name: "SIGTRAP", number: 5, action: "core", description: "Debugger breakpoint", standard: "posix" }, { name: "SIGABRT", number: 6, action: "core", description: "Aborted", standard: "ansi" }, { name: "SIGIOT", number: 6, action: "core", description: "Aborted", standard: "bsd" }, { name: "SIGBUS", number: 7, action: "core", description: "Bus error due to misaligned, non-existing address or paging error", standard: "bsd" }, { name: "SIGEMT", number: 7, action: "terminate", description: "Command should be emulated but is not implemented", standard: "other" }, { name: "SIGFPE", number: 8, action: "core", description: "Floating point arithmetic error", standard: "ansi" }, { name: "SIGKILL", number: 9, action: "terminate", description: "Forced termination", standard: "posix", forced: true }, { name: "SIGUSR1", number: 10, action: "terminate", description: "Application-specific signal", standard: "posix" }, { name: "SIGSEGV", number: 11, action: "core", description: "Segmentation fault", standard: "ansi" }, { name: "SIGUSR2", number: 12, action: "terminate", description: "Application-specific signal", standard: "posix" }, { name: "SIGPIPE", number: 13, action: "terminate", description: "Broken pipe or socket", standard: "posix" }, { name: "SIGALRM", number: 14, action: "terminate", description: "Timeout or timer", standard: "posix" }, { name: "SIGTERM", number: 15, action: "terminate", description: "Termination", standard: "ansi" }, { name: "SIGSTKFLT", number: 16, action: "terminate", description: "Stack is empty or overflowed", standard: "other" }, { name: "SIGCHLD", number: 17, action: "ignore", description: "Child process terminated, paused or unpaused", standard: "posix" }, { name: "SIGCLD", number: 17, action: "ignore", description: "Child process terminated, paused or unpaused", standard: "other" }, { name: "SIGCONT", number: 18, action: "unpause", description: "Unpaused", standard: "posix", forced: true }, { name: "SIGSTOP", number: 19, action: "pause", description: "Paused", standard: "posix", forced: true }, { name: "SIGTSTP", number: 20, action: "pause", description: 'Paused using CTRL-Z or "suspend"', standard: "posix" }, { name: "SIGTTIN", number: 21, action: "pause", description: "Background process cannot read terminal input", standard: "posix" }, { name: "SIGBREAK", number: 21, action: "terminate", description: "User interruption with CTRL-BREAK", standard: "other" }, { name: "SIGTTOU", number: 22, action: "pause", description: "Background process cannot write to terminal output", standard: "posix" }, { name: "SIGURG", number: 23, action: "ignore", description: "Socket received out-of-band data", standard: "bsd" }, { name: "SIGXCPU", number: 24, action: "core", description: "Process timed out", standard: "bsd" }, { name: "SIGXFSZ", number: 25, action: "core", description: "File too big", standard: "bsd" }, { name: "SIGVTALRM", number: 26, action: "terminate", description: "Timeout or timer", standard: "bsd" }, { name: "SIGPROF", number: 27, action: "terminate", description: "Timeout or timer", standard: "bsd" }, { name: "SIGWINCH", number: 28, action: "ignore", description: "Terminal window size changed", standard: "bsd" }, { name: "SIGIO", number: 29, action: "terminate", description: "I/O is available", standard: "other" }, { name: "SIGPOLL", number: 29, action: "terminate", description: "Watched event", standard: "other" }, { name: "SIGINFO", number: 29, action: "ignore", description: "Request for process information", standard: "other" }, { name: "SIGPWR", number: 30, action: "terminate", description: "Device running out of power", standard: "systemv" }, { name: "SIGSYS", number: 31, action: "core", description: "Invalid system call", standard: "other" }, { name: "SIGUNUSED", number: 31, action: "terminate", description: "Invalid system call", standard: "other" }];
      wo.SIGNALS = GN;
    });
    var ru = C((Zn) => {
      "use strict";
      Object.defineProperty(Zn, "__esModule", { value: true });
      Zn.SIGRTMAX = Zn.getRealtimeSignals = void 0;
      var ON = function() {
        let t = IQ - CQ + 1;
        return Array.from({ length: t }, VN);
      };
      Zn.getRealtimeSignals = ON;
      var VN = function(t, e) {
        return { name: `SIGRT${e + 1}`, number: CQ + e, action: "terminate", description: "Application-specific signal (realtime)", standard: "posix" };
      }, CQ = 34, IQ = 64;
      Zn.SIGRTMAX = IQ;
    });
    var pQ = C((Do) => {
      "use strict";
      Object.defineProperty(Do, "__esModule", { value: true });
      Do.getSignals = void 0;
      var HN = require("node:os"), qN = QQ(), JN = ru(), WN = function() {
        let t = (0, JN.getRealtimeSignals)();
        return [...qN.SIGNALS, ...t].map(_N);
      };
      Do.getSignals = WN;
      var _N = function({ name: t, number: e, description: r, action: n, forced: A = false, standard: i }) {
        let { signals: { [t]: s } } = HN.constants, o = s !== void 0;
        return { name: t, number: o ? s : e, description: r, supported: o, action: n, forced: A, standard: i };
      };
    });
    var mQ = C((Xn) => {
      "use strict";
      Object.defineProperty(Xn, "__esModule", { value: true });
      Xn.signalsByNumber = Xn.signalsByName = void 0;
      var jN = require("node:os"), BQ = pQ(), ZN = ru(), XN = function() {
        return (0, BQ.getSignals)().reduce(KN, {});
      }, KN = function(t, { name: e, number: r, description: n, supported: A, action: i, forced: s, standard: o }) {
        return { ...t, [e]: { name: e, number: r, description: n, supported: A, action: i, forced: s, standard: o } };
      }, $N = XN();
      Xn.signalsByName = $N;
      var zN = function() {
        let t = (0, BQ.getSignals)(), e = ZN.SIGRTMAX + 1, r = Array.from({ length: e }, (n, A) => eF(A, t));
        return Object.assign({}, ...r);
      }, eF = function(t, e) {
        let r = tF(t, e);
        if (r === void 0) return {};
        let { name: n, description: A, supported: i, action: s, forced: o, standard: a } = r;
        return { [t]: { name: n, number: t, description: A, supported: i, action: s, forced: o, standard: a } };
      }, tF = function(t, e) {
        let r = e.find(({ name: n }) => jN.constants.signals[n] === t);
        return r !== void 0 ? r : e.find((n) => n.number === t);
      }, rF = zN();
      Xn.signalsByNumber = rF;
    });
    var wQ = C((S9, yQ) => {
      "use strict";
      var { signalsByName: nF } = mQ(), AF = ({ timedOut: t, timeout: e, errorCode: r, signal: n, signalDescription: A, exitCode: i, isCanceled: s }) => t ? `timed out after ${e} milliseconds` : s ? "was canceled" : r !== void 0 ? `failed with ${r}` : n !== void 0 ? `was killed with ${n} (${A})` : i !== void 0 ? `failed with exit code ${i}` : "failed", iF = ({ stdout: t, stderr: e, all: r, error: n, signal: A, exitCode: i, command: s, escapedCommand: o, timedOut: a, isCanceled: c, killed: l, parsed: { options: { timeout: u } } }) => {
        i = i === null ? void 0 : i, A = A === null ? void 0 : A;
        let g = A === void 0 ? void 0 : nF[A].description, E = n && n.code, f = `Command ${AF({ timedOut: a, timeout: u, errorCode: E, signal: A, signalDescription: g, exitCode: i, isCanceled: c })}: ${s}`, p = Object.prototype.toString.call(n) === "[object Error]", Q = p ? `${f}
${n.message}` : f, I = [Q, e, t].filter(Boolean).join(`
`);
        return p ? (n.originalMessage = n.message, n.message = I) : n = new Error(I), n.shortMessage = Q, n.command = s, n.escapedCommand = o, n.exitCode = i, n.signal = A, n.signalDescription = g, n.stdout = t, n.stderr = e, r !== void 0 && (n.all = r), "bufferedData" in n && delete n.bufferedData, n.failed = true, n.timedOut = !!a, n.isCanceled = c, n.killed = l && !a, n;
      };
      yQ.exports = iF;
    });
    var RQ = C((b9, nu) => {
      "use strict";
      var Ro = ["stdin", "stdout", "stderr"], sF = (t) => Ro.some((e) => t[e] !== void 0), DQ = (t) => {
        if (!t) return;
        let { stdio: e } = t;
        if (e === void 0) return Ro.map((n) => t[n]);
        if (sF(t)) throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${Ro.map((n) => `\`${n}\``).join(", ")}`);
        if (typeof e == "string") return e;
        if (!Array.isArray(e)) throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof e}\``);
        let r = Math.max(e.length, Ro.length);
        return Array.from({ length: r }, (n, A) => e[A]);
      };
      nu.exports = DQ;
      nu.exports.node = (t) => {
        let e = DQ(t);
        return e === "ipc" ? "ipc" : e === void 0 || typeof e == "string" ? [e, e, e, "ipc"] : e.includes("ipc") ? e : [...e, "ipc"];
      };
    });
    var SQ = C((N9, So) => {
      "use strict";
      So.exports = ["SIGABRT", "SIGALRM", "SIGHUP", "SIGINT", "SIGTERM"];
      process.platform !== "win32" && So.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
      process.platform === "linux" && So.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    });
    var xQ = C((F9, zn) => {
      "use strict";
      var ue = global.process, on = function(t) {
        return t && typeof t == "object" && typeof t.removeListener == "function" && typeof t.emit == "function" && typeof t.reallyExit == "function" && typeof t.listeners == "function" && typeof t.kill == "function" && typeof t.pid == "number" && typeof t.on == "function";
      };
      on(ue) ? (bQ = require("node:assert"), Kn = SQ(), NQ = /^win/i.test(ue.platform), Bi = require("node:events"), typeof Bi != "function" && (Bi = Bi.EventEmitter), ue.__signal_exit_emitter__ ? we = ue.__signal_exit_emitter__ : (we = ue.__signal_exit_emitter__ = new Bi(), we.count = 0, we.emitted = {}), we.infinite || (we.setMaxListeners(1 / 0), we.infinite = true), zn.exports = function(t, e) {
        if (!on(global.process)) return function() {
        };
        bQ.equal(typeof t, "function", "a callback must be provided for exit handler"), $n === false && Au();
        var r = "exit";
        e && e.alwaysLast && (r = "afterexit");
        var n = function() {
          we.removeListener(r, t), we.listeners("exit").length === 0 && we.listeners("afterexit").length === 0 && bo();
        };
        return we.on(r, t), n;
      }, bo = function() {
        !$n || !on(global.process) || ($n = false, Kn.forEach(function(e) {
          try {
            ue.removeListener(e, No[e]);
          } catch {
          }
        }), ue.emit = Fo, ue.reallyExit = iu, we.count -= 1);
      }, zn.exports.unload = bo, an = function(e, r, n) {
        we.emitted[e] || (we.emitted[e] = true, we.emit(e, r, n));
      }, No = {}, Kn.forEach(function(t) {
        No[t] = function() {
          if (on(global.process)) {
            var r = ue.listeners(t);
            r.length === we.count && (bo(), an("exit", null, t), an("afterexit", null, t), NQ && t === "SIGHUP" && (t = "SIGINT"), ue.kill(ue.pid, t));
          }
        };
      }), zn.exports.signals = function() {
        return Kn;
      }, $n = false, Au = function() {
        $n || !on(global.process) || ($n = true, we.count += 1, Kn = Kn.filter(function(e) {
          try {
            return ue.on(e, No[e]), true;
          } catch {
            return false;
          }
        }), ue.emit = TQ, ue.reallyExit = FQ);
      }, zn.exports.load = Au, iu = ue.reallyExit, FQ = function(e) {
        on(global.process) && (ue.exitCode = e || 0, an("exit", ue.exitCode, null), an("afterexit", ue.exitCode, null), iu.call(ue, ue.exitCode));
      }, Fo = ue.emit, TQ = function(e, r) {
        if (e === "exit" && on(global.process)) {
          r !== void 0 && (ue.exitCode = r);
          var n = Fo.apply(this, arguments);
          return an("exit", ue.exitCode, null), an("afterexit", ue.exitCode, null), n;
        } else return Fo.apply(this, arguments);
      }) : zn.exports = function() {
        return function() {
        };
      };
      var bQ, Kn, NQ, Bi, we, bo, an, No, $n, Au, iu, FQ, Fo, TQ;
    });
    var kQ = C((T9, UQ) => {
      "use strict";
      var oF = require("node:os"), aF = xQ(), cF = 1e3 * 5, lF = (t, e = "SIGTERM", r = {}) => {
        let n = t(e);
        return uF(t, e, r, n), n;
      }, uF = (t, e, r, n) => {
        if (!gF(e, r, n)) return;
        let A = dF(r), i = setTimeout(() => {
          t("SIGKILL");
        }, A);
        i.unref && i.unref();
      }, gF = (t, { forceKillAfterTimeout: e }, r) => EF(t) && e !== false && r, EF = (t) => t === oF.constants.signals.SIGTERM || typeof t == "string" && t.toUpperCase() === "SIGTERM", dF = ({ forceKillAfterTimeout: t = true }) => {
        if (t === true) return cF;
        if (!Number.isFinite(t) || t < 0) throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${t}\` (${typeof t})`);
        return t;
      }, hF = (t, e) => {
        t.kill() && (e.isCanceled = true);
      }, fF = (t, e, r) => {
        t.kill(e), r(Object.assign(new Error("Timed out"), { timedOut: true, signal: e }));
      }, QF = (t, { timeout: e, killSignal: r = "SIGTERM" }, n) => {
        if (e === 0 || e === void 0) return n;
        let A, i = new Promise((o, a) => {
          A = setTimeout(() => {
            fF(t, r, a);
          }, e);
        }), s = n.finally(() => {
          clearTimeout(A);
        });
        return Promise.race([i, s]);
      }, CF = ({ timeout: t }) => {
        if (t !== void 0 && (!Number.isFinite(t) || t < 0)) throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${t}\` (${typeof t})`);
      }, IF = async (t, { cleanup: e, detached: r }, n) => {
        if (!e || r) return n;
        let A = aF(() => {
          t.kill();
        });
        return n.finally(() => {
          A();
        });
      };
      UQ.exports = { spawnedKill: lF, spawnedCancel: hF, setupTimeout: QF, validateTimeout: CF, setExitHandler: IF };
    });
    var LQ = C((x9, MQ) => {
      "use strict";
      var Ut = (t) => t !== null && typeof t == "object" && typeof t.pipe == "function";
      Ut.writable = (t) => Ut(t) && t.writable !== false && typeof t._write == "function" && typeof t._writableState == "object";
      Ut.readable = (t) => Ut(t) && t.readable !== false && typeof t._read == "function" && typeof t._readableState == "object";
      Ut.duplex = (t) => Ut.writable(t) && Ut.readable(t);
      Ut.transform = (t) => Ut.duplex(t) && typeof t._transform == "function";
      MQ.exports = Ut;
    });
    var PQ = C((U9, vQ) => {
      "use strict";
      var { PassThrough: pF } = require("node:stream");
      vQ.exports = (t) => {
        t = { ...t };
        let { array: e } = t, { encoding: r } = t, n = r === "buffer", A = false;
        e ? A = !(r || n) : r = r || "utf8", n && (r = null);
        let i = new pF({ objectMode: A });
        r && i.setEncoding(r);
        let s = 0, o = [];
        return i.on("data", (a) => {
          o.push(a), A ? s = o.length : s += a.length;
        }), i.getBufferedValue = () => e ? o : n ? Buffer.concat(o, s) : o.join(""), i.getBufferedLength = () => s, i;
      };
    });
    var ou = C((k9, mi) => {
      "use strict";
      var { constants: BF } = require("node:buffer"), mF = require("node:stream"), { promisify: yF } = require("node:util"), wF = PQ(), DF = yF(mF.pipeline), To = class extends Error {
        constructor() {
          super("maxBuffer exceeded"), this.name = "MaxBufferError";
        }
      };
      async function su(t, e) {
        if (!t) throw new Error("Expected a stream");
        e = { maxBuffer: 1 / 0, ...e };
        let { maxBuffer: r } = e, n = wF(e);
        return await new Promise((A, i) => {
          let s = (o) => {
            o && n.getBufferedLength() <= BF.MAX_LENGTH && (o.bufferedData = n.getBufferedValue()), i(o);
          };
          (async () => {
            try {
              await DF(t, n), A();
            } catch (o) {
              s(o);
            }
          })(), n.on("data", () => {
            n.getBufferedLength() > r && s(new To());
          });
        }), n.getBufferedValue();
      }
      mi.exports = su;
      mi.exports.buffer = (t, e) => su(t, { ...e, encoding: "buffer" });
      mi.exports.array = (t, e) => su(t, { ...e, array: true });
      mi.exports.MaxBufferError = To;
    });
    var GQ = C((M9, YQ) => {
      "use strict";
      var { PassThrough: RF } = require("node:stream");
      YQ.exports = function() {
        var t = [], e = new RF({ objectMode: true });
        return e.setMaxListeners(0), e.add = r, e.isEmpty = n, e.on("unpipe", A), Array.prototype.slice.call(arguments).forEach(r), e;
        function r(i) {
          return Array.isArray(i) ? (i.forEach(r), this) : (t.push(i), i.once("end", A.bind(null, i)), i.once("error", e.emit.bind(e, "error")), i.pipe(e, { end: false }), this);
        }
        function n() {
          return t.length == 0;
        }
        function A(i) {
          t = t.filter(function(s) {
            return s !== i;
          }), !t.length && e.readable && e.end();
        }
      };
    });
    var qQ = C((L9, HQ) => {
      "use strict";
      var VQ = LQ(), OQ = ou(), SF = GQ(), bF = (t, e) => {
        e === void 0 || t.stdin === void 0 || (VQ(e) ? e.pipe(t.stdin) : t.stdin.end(e));
      }, NF = (t, { all: e }) => {
        if (!e || !t.stdout && !t.stderr) return;
        let r = SF();
        return t.stdout && r.add(t.stdout), t.stderr && r.add(t.stderr), r;
      }, au = async (t, e) => {
        if (t) {
          t.destroy();
          try {
            return await e;
          } catch (r) {
            return r.bufferedData;
          }
        }
      }, cu = (t, { encoding: e, buffer: r, maxBuffer: n }) => {
        if (!(!t || !r)) return e ? OQ(t, { encoding: e, maxBuffer: n }) : OQ.buffer(t, { maxBuffer: n });
      }, FF = async ({ stdout: t, stderr: e, all: r }, { encoding: n, buffer: A, maxBuffer: i }, s) => {
        let o = cu(t, { encoding: n, buffer: A, maxBuffer: i }), a = cu(e, { encoding: n, buffer: A, maxBuffer: i }), c = cu(r, { encoding: n, buffer: A, maxBuffer: i * 2 });
        try {
          return await Promise.all([s, o, a, c]);
        } catch (l) {
          return Promise.all([{ error: l, signal: l.signal, timedOut: l.timedOut }, au(t, o), au(e, a), au(r, c)]);
        }
      }, TF = ({ input: t }) => {
        if (VQ(t)) throw new TypeError("The `input` option cannot be a stream in sync mode");
      };
      HQ.exports = { handleInput: bF, makeAllStream: NF, getSpawnedResult: FF, validateInputSync: TF };
    });
    var WQ = C((v9, JQ) => {
      "use strict";
      var xF = (async () => {
      })().constructor.prototype, UF = ["then", "catch", "finally"].map((t) => [t, Reflect.getOwnPropertyDescriptor(xF, t)]), kF = (t, e) => {
        for (let [r, n] of UF) {
          let A = typeof e == "function" ? (...i) => Reflect.apply(n.value, e(), i) : n.value.bind(e);
          Reflect.defineProperty(t, r, { ...n, value: A });
        }
        return t;
      }, MF = (t) => new Promise((e, r) => {
        t.on("exit", (n, A) => {
          e({ exitCode: n, signal: A });
        }), t.on("error", (n) => {
          r(n);
        }), t.stdin && t.stdin.on("error", (n) => {
          r(n);
        });
      });
      JQ.exports = { mergePromise: kF, getSpawnedPromise: MF };
    });
    var ZQ = C((P9, jQ) => {
      "use strict";
      var _Q = (t, e = []) => Array.isArray(e) ? [t, ...e] : [t], LF = /^[\w.-]+$/, vF = /"/g, PF = (t) => typeof t != "string" || LF.test(t) ? t : `"${t.replace(vF, '\\"')}"`, YF = (t, e) => _Q(t, e).join(" "), GF = (t, e) => _Q(t, e).map((r) => PF(r)).join(" "), OF = / +/g, VF = (t) => {
        let e = [];
        for (let r of t.trim().split(OF)) {
          let n = e[e.length - 1];
          n && n.endsWith("\\") ? e[e.length - 1] = `${n.slice(0, -1)} ${r}` : e.push(r);
        }
        return e;
      };
      jQ.exports = { joinCommand: YF, getEscapedCommand: GF, parseCommand: VF };
    });
    var rC = C((Y9, eA) => {
      "use strict";
      var HF = require("node:path"), lu = require("node:child_process"), qF = oQ(), JF = cQ(), WF = gQ(), _F = fQ(), xo = wQ(), KQ = RQ(), { spawnedKill: jF, spawnedCancel: ZF, setupTimeout: XF, validateTimeout: KF, setExitHandler: $F } = kQ(), { handleInput: zF, getSpawnedResult: eT, makeAllStream: tT, validateInputSync: rT } = qQ(), { mergePromise: XQ, getSpawnedPromise: nT } = WQ(), { joinCommand: $Q, parseCommand: zQ, getEscapedCommand: eC } = ZQ(), AT = 1e3 * 1e3 * 100, iT = ({ env: t, extendEnv: e, preferLocal: r, localDir: n, execPath: A }) => {
        let i = e ? { ...process.env, ...t } : t;
        return r ? WF.env({ env: i, cwd: n, execPath: A }) : i;
      }, tC = (t, e, r = {}) => {
        let n = qF._parse(t, e, r);
        return t = n.command, e = n.args, r = n.options, r = { maxBuffer: AT, buffer: true, stripFinalNewline: true, extendEnv: true, preferLocal: false, localDir: r.cwd || process.cwd(), execPath: process.execPath, encoding: "utf8", reject: true, cleanup: true, all: false, windowsHide: true, ...r }, r.env = iT(r), r.stdio = KQ(r), process.platform === "win32" && HF.basename(t, ".exe") === "cmd" && e.unshift("/q"), { file: t, args: e, options: r, parsed: n };
      }, yi = (t, e, r) => typeof e != "string" && !Buffer.isBuffer(e) ? r === void 0 ? void 0 : "" : t.stripFinalNewline ? JF(e) : e, Uo = (t, e, r) => {
        let n = tC(t, e, r), A = $Q(t, e), i = eC(t, e);
        KF(n.options);
        let s;
        try {
          s = lu.spawn(n.file, n.args, n.options);
        } catch (E) {
          let h = new lu.ChildProcess(), f = Promise.reject(xo({ error: E, stdout: "", stderr: "", all: "", command: A, escapedCommand: i, parsed: n, timedOut: false, isCanceled: false, killed: false }));
          return XQ(h, f);
        }
        let o = nT(s), a = XF(s, n.options, o), c = $F(s, n.options, a), l = { isCanceled: false };
        s.kill = jF.bind(null, s.kill.bind(s)), s.cancel = ZF.bind(null, s, l);
        let g = _F(async () => {
          let [{ error: E, exitCode: h, signal: f, timedOut: p }, Q, I, B] = await eT(s, n.options, c), w = yi(n.options, Q), D = yi(n.options, I), v = yi(n.options, B);
          if (E || h !== 0 || f !== null) {
            let K = xo({ error: E, exitCode: h, signal: f, stdout: w, stderr: D, all: v, command: A, escapedCommand: i, parsed: n, timedOut: p, isCanceled: l.isCanceled, killed: s.killed });
            if (!n.options.reject) return K;
            throw K;
          }
          return { command: A, escapedCommand: i, exitCode: 0, stdout: w, stderr: D, all: v, failed: false, timedOut: false, isCanceled: false, killed: false };
        });
        return zF(s, n.options.input), s.all = tT(s, n.options), XQ(s, g);
      };
      eA.exports = Uo;
      eA.exports.sync = (t, e, r) => {
        let n = tC(t, e, r), A = $Q(t, e), i = eC(t, e);
        rT(n.options);
        let s;
        try {
          s = lu.spawnSync(n.file, n.args, n.options);
        } catch (c) {
          throw xo({ error: c, stdout: "", stderr: "", all: "", command: A, escapedCommand: i, parsed: n, timedOut: false, isCanceled: false, killed: false });
        }
        let o = yi(n.options, s.stdout, s.error), a = yi(n.options, s.stderr, s.error);
        if (s.error || s.status !== 0 || s.signal !== null) {
          let c = xo({ stdout: o, stderr: a, error: s.error, signal: s.signal, exitCode: s.status, command: A, escapedCommand: i, parsed: n, timedOut: s.error && s.error.code === "ETIMEDOUT", isCanceled: false, killed: s.signal !== null });
          if (!n.options.reject) return c;
          throw c;
        }
        return { command: A, escapedCommand: i, exitCode: 0, stdout: o, stderr: a, failed: false, timedOut: false, isCanceled: false, killed: false };
      };
      eA.exports.command = (t, e) => {
        let [r, ...n] = zQ(t);
        return Uo(r, n, e);
      };
      eA.exports.commandSync = (t, e) => {
        let [r, ...n] = zQ(t);
        return Uo.sync(r, n, e);
      };
      eA.exports.node = (t, e, r = {}) => {
        e && !Array.isArray(e) && typeof e == "object" && (r = e, e = []);
        let n = KQ.node(r), A = process.execArgv.filter((o) => !o.startsWith("--inspect")), { nodePath: i = process.execPath, nodeOptions: s = A } = r;
        return Uo(i, [...s, t, ...Array.isArray(e) ? e : []], { ...r, stdin: void 0, stdout: void 0, stderr: void 0, stdio: n, shell: false });
      };
    });
    var nC = C((W9, sT) => {
      sT.exports = { name: "@prisma/internals", version: "6.14.0", description: "This package is intended for Prisma's internal use", main: "dist/index.js", types: "dist/index.d.ts", repository: { type: "git", url: "https://github.com/prisma/prisma.git", directory: "packages/internals" }, homepage: "https://www.prisma.io", author: "Tim Suchanek <suchanek@prisma.io>", bugs: "https://github.com/prisma/prisma/issues", license: "Apache-2.0", scripts: { dev: "DEV=true tsx helpers/build.ts", build: "tsx helpers/build.ts", test: "dotenv -e ../../.db.env -- jest --silent", prepublishOnly: "pnpm run build" }, files: ["README.md", "dist", "!**/libquery_engine*", "!dist/get-generators/engines/*", "scripts"], devDependencies: { "@babel/helper-validator-identifier": "7.25.9", "@opentelemetry/api": "1.9.0", "@swc/core": "1.11.5", "@swc/jest": "0.2.37", "@types/babel__helper-validator-identifier": "7.15.2", "@types/jest": "29.5.14", "@types/node": "18.19.76", "@types/resolve": "1.20.6", archiver: "6.0.2", "checkpoint-client": "1.1.33", "cli-truncate": "4.0.0", dotenv: "16.5.0", empathic: "2.0.0", esbuild: "0.25.5", "escape-string-regexp": "5.0.0", execa: "5.1.1", "fast-glob": "3.3.3", "find-up": "7.0.0", "fp-ts": "2.16.9", "fs-extra": "11.3.0", "fs-jetpack": "5.1.0", "global-dirs": "4.0.0", globby: "11.1.0", "identifier-regex": "1.0.0", "indent-string": "4.0.0", "is-windows": "1.0.2", "is-wsl": "3.1.0", jest: "29.7.0", "jest-junit": "16.0.0", kleur: "4.1.5", "mock-stdin": "1.0.0", "new-github-issue-url": "0.2.1", "node-fetch": "3.3.2", "npm-packlist": "5.1.3", open: "7.4.2", "p-map": "4.0.0", resolve: "1.22.10", "string-width": "7.2.0", "strip-ansi": "6.0.1", "strip-indent": "4.0.0", "temp-dir": "2.0.0", tempy: "1.0.1", "terminal-link": "4.0.0", tmp: "0.2.3", "ts-node": "10.9.2", "ts-pattern": "5.6.2", "ts-toolbelt": "9.6.0", typescript: "5.4.5", yarn: "1.22.22" }, dependencies: { "@prisma/config": "workspace:*", "@prisma/debug": "workspace:*", "@prisma/dmmf": "workspace:*", "@prisma/driver-adapter-utils": "workspace:*", "@prisma/engines": "workspace:*", "@prisma/fetch-engine": "workspace:*", "@prisma/generator": "workspace:*", "@prisma/generator-helper": "workspace:*", "@prisma/get-platform": "workspace:*", "@prisma/prisma-schema-wasm": "6.14.0-25.717184b7b35ea05dfa71a3236b7af656013e1e49", "@prisma/schema-engine-wasm": "6.14.0-25.717184b7b35ea05dfa71a3236b7af656013e1e49", "@prisma/schema-files-loader": "workspace:*", arg: "5.0.2", prompts: "2.4.2" }, peerDependencies: { typescript: ">=5.1.0" }, peerDependenciesMeta: { typescript: { optional: true } }, sideEffects: false };
    });
    var Eu = C((Z9, AC) => {
      "use strict";
      var lT = require("node:fs"), uT = require("node:os"), gu = /* @__PURE__ */ Symbol.for("__RESOLVED_TEMP_DIRECTORY__");
      global[gu] || Object.defineProperty(global, gu, { value: lT.realpathSync(uT.tmpdir()) });
      AC.exports = global[gu];
    });
    var sC = C((X9, iC) => {
      "use strict";
      function lt(t, e) {
        typeof e == "boolean" && (e = { forever: e }), this._originalTimeouts = JSON.parse(JSON.stringify(t)), this._timeouts = t, this._options = e || {}, this._maxRetryTime = e && e.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._timer = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0));
      }
      iC.exports = lt;
      lt.prototype.reset = function() {
        this._attempts = 1, this._timeouts = this._originalTimeouts.slice(0);
      };
      lt.prototype.stop = function() {
        this._timeout && clearTimeout(this._timeout), this._timer && clearTimeout(this._timer), this._timeouts = [], this._cachedTimeouts = null;
      };
      lt.prototype.retry = function(t) {
        if (this._timeout && clearTimeout(this._timeout), !t) return false;
        var e = (/* @__PURE__ */ new Date()).getTime();
        if (t && e - this._operationStart >= this._maxRetryTime) return this._errors.push(t), this._errors.unshift(new Error("RetryOperation timeout occurred")), false;
        this._errors.push(t);
        var r = this._timeouts.shift();
        if (r === void 0) if (this._cachedTimeouts) this._errors.splice(0, this._errors.length - 1), r = this._cachedTimeouts.slice(-1);
        else return false;
        var n = this;
        return this._timer = setTimeout(function() {
          n._attempts++, n._operationTimeoutCb && (n._timeout = setTimeout(function() {
            n._operationTimeoutCb(n._attempts);
          }, n._operationTimeout), n._options.unref && n._timeout.unref()), n._fn(n._attempts);
        }, r), this._options.unref && this._timer.unref(), true;
      };
      lt.prototype.attempt = function(t, e) {
        this._fn = t, e && (e.timeout && (this._operationTimeout = e.timeout), e.cb && (this._operationTimeoutCb = e.cb));
        var r = this;
        this._operationTimeoutCb && (this._timeout = setTimeout(function() {
          r._operationTimeoutCb();
        }, r._operationTimeout)), this._operationStart = (/* @__PURE__ */ new Date()).getTime(), this._fn(this._attempts);
      };
      lt.prototype.try = function(t) {
        console.log("Using RetryOperation.try() is deprecated"), this.attempt(t);
      };
      lt.prototype.start = function(t) {
        console.log("Using RetryOperation.start() is deprecated"), this.attempt(t);
      };
      lt.prototype.start = lt.prototype.try;
      lt.prototype.errors = function() {
        return this._errors;
      };
      lt.prototype.attempts = function() {
        return this._attempts;
      };
      lt.prototype.mainError = function() {
        if (this._errors.length === 0) return null;
        for (var t = {}, e = null, r = 0, n = 0; n < this._errors.length; n++) {
          var A = this._errors[n], i = A.message, s = (t[i] || 0) + 1;
          t[i] = s, s >= r && (e = A, r = s);
        }
        return e;
      };
    });
    var oC = C((cn) => {
      "use strict";
      var gT = sC();
      cn.operation = function(t) {
        var e = cn.timeouts(t);
        return new gT(e, { forever: t && (t.forever || t.retries === 1 / 0), unref: t && t.unref, maxRetryTime: t && t.maxRetryTime });
      };
      cn.timeouts = function(t) {
        if (t instanceof Array) return [].concat(t);
        var e = { retries: 10, factor: 2, minTimeout: 1 * 1e3, maxTimeout: 1 / 0, randomize: false };
        for (var r in t) e[r] = t[r];
        if (e.minTimeout > e.maxTimeout) throw new Error("minTimeout is greater than maxTimeout");
        for (var n = [], A = 0; A < e.retries; A++) n.push(this.createTimeout(A, e));
        return t && t.forever && !n.length && n.push(this.createTimeout(A, e)), n.sort(function(i, s) {
          return i - s;
        }), n;
      };
      cn.createTimeout = function(t, e) {
        var r = e.randomize ? Math.random() + 1 : 1, n = Math.round(r * Math.max(e.minTimeout, 1) * Math.pow(e.factor, t));
        return n = Math.min(n, e.maxTimeout), n;
      };
      cn.wrap = function(t, e, r) {
        if (e instanceof Array && (r = e, e = null), !r) {
          r = [];
          for (var n in t) typeof t[n] == "function" && r.push(n);
        }
        for (var A = 0; A < r.length; A++) {
          var i = r[A], s = t[i];
          t[i] = function(a) {
            var c = cn.operation(e), l = Array.prototype.slice.call(arguments, 1), u = l.pop();
            l.push(function(g) {
              c.retry(g) || (g && (arguments[0] = c.mainError()), u.apply(this, arguments));
            }), c.attempt(function() {
              a.apply(t, l);
            });
          }.bind(t, s), t[i].options = e;
        }
      };
    });
    var cC = C(($9, aC) => {
      "use strict";
      aC.exports = oC();
    });
    var uC = C((z9, Mo) => {
      "use strict";
      var ET = cC(), dT = ["Failed to fetch", "NetworkError when attempting to fetch resource.", "The Internet connection appears to be offline.", "Network request failed"], ko = class extends Error {
        constructor(e) {
          super(), e instanceof Error ? (this.originalError = e, { message: e } = e) : (this.originalError = new Error(e), this.originalError.stack = this.stack), this.name = "AbortError", this.message = e;
        }
      }, hT = (t, e, r) => {
        let n = r.retries - (e - 1);
        return t.attemptNumber = e, t.retriesLeft = n, t;
      }, fT = (t) => dT.includes(t), lC = (t, e) => new Promise((r, n) => {
        e = { onFailedAttempt: () => {
        }, retries: 10, ...e };
        let A = ET.operation(e);
        A.attempt(async (i) => {
          try {
            r(await t(i));
          } catch (s) {
            if (!(s instanceof Error)) {
              n(new TypeError(`Non-error was thrown: "${s}". You should only throw errors.`));
              return;
            }
            if (s instanceof ko) A.stop(), n(s.originalError);
            else if (s instanceof TypeError && !fT(s.message)) A.stop(), n(s);
            else {
              hT(s, i, e);
              try {
                await e.onFailedAttempt(s);
              } catch (o) {
                n(o);
                return;
              }
              A.retry(s) || n(A.mainError());
            }
          }
        });
      });
      Mo.exports = lC;
      Mo.exports.default = lC;
      Mo.exports.AbortError = ko;
    });
    var du = C((Aj, QT) => {
      QT.exports = { name: "@prisma/engines-version", version: "6.14.0-25.717184b7b35ea05dfa71a3236b7af656013e1e49", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "717184b7b35ea05dfa71a3236b7af656013e1e49" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.19.76", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
    });
    var vo = C((Lo) => {
      "use strict";
      Object.defineProperty(Lo, "__esModule", { value: true });
      Lo.enginesVersion = void 0;
      Lo.enginesVersion = du().prisma.enginesVersion;
    });
    var hC = C((dj, dC) => {
      "use strict";
      dC.exports = (t) => {
        let e = t.match(/^[ \t]*(?=\S)/gm);
        return e ? e.reduce((r, n) => Math.min(r, n.length), 1 / 0) : 0;
      };
    });
    var Iu = C((Qj, CC) => {
      "use strict";
      CC.exports = (t, e = 1, r) => {
        if (r = { indent: " ", includeEmptyLines: false, ...r }, typeof t != "string") throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof t}\``);
        if (typeof e != "number") throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof e}\``);
        if (typeof r.indent != "string") throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);
        if (e === 0) return t;
        let n = r.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
        return t.replace(n, r.indent.repeat(e));
      };
    });
    var mC = C((pj, BC) => {
      "use strict";
      BC.exports = ({ onlyFirst: t = false } = {}) => {
        let e = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
        return new RegExp(e, t ? void 0 : "g");
      };
    });
    var yu = C((Bj, yC) => {
      "use strict";
      var ST = mC();
      yC.exports = (t) => typeof t == "string" ? t.replace(ST(), "") : t;
    });
    var DC = C((Dj, FT) => {
      FT.exports = { name: "dotenv", version: "16.5.0", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { types: "./lib/main.d.ts", require: "./lib/main.js", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", pretest: "npm run lint && npm run dts-check", test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000", "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, homepage: "https://github.com/motdotla/dotenv#readme", funding: "https://dotenvx.com", keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^18.11.3", decache: "^4.6.2", sinon: "^14.0.1", standard: "^17.0.0", "standard-version": "^9.5.0", tap: "^19.2.0", typescript: "^4.8.4" }, engines: { node: ">=12" }, browser: { fs: false } };
    });
    var FC = C((Rj, ir) => {
      "use strict";
      var Du = require("node:fs"), Ru = require("node:path"), TT = require("node:os"), xT = require("node:crypto"), UT = DC(), SC = UT.version, kT = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
      function MT(t) {
        let e = {}, r = t.toString();
        r = r.replace(/\r\n?/mg, `
`);
        let n;
        for (; (n = kT.exec(r)) != null; ) {
          let A = n[1], i = n[2] || "";
          i = i.trim();
          let s = i[0];
          i = i.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s === '"' && (i = i.replace(/\\n/g, `
`), i = i.replace(/\\r/g, "\r")), e[A] = i;
        }
        return e;
      }
      function LT(t) {
        let e = NC(t), r = pe.configDotenv({ path: e });
        if (!r.parsed) {
          let s = new Error(`MISSING_DATA: Cannot parse ${e} for an unknown reason`);
          throw s.code = "MISSING_DATA", s;
        }
        let n = bC(t).split(","), A = n.length, i;
        for (let s = 0; s < A; s++) try {
          let o = n[s].trim(), a = PT(r, o);
          i = pe.decrypt(a.ciphertext, a.key);
          break;
        } catch (o) {
          if (s + 1 >= A) throw o;
        }
        return pe.parse(i);
      }
      function vT(t) {
        console.log(`[dotenv@${SC}][WARN] ${t}`);
      }
      function bi(t) {
        console.log(`[dotenv@${SC}][DEBUG] ${t}`);
      }
      function bC(t) {
        return t && t.DOTENV_KEY && t.DOTENV_KEY.length > 0 ? t.DOTENV_KEY : process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0 ? process.env.DOTENV_KEY : "";
      }
      function PT(t, e) {
        let r;
        try {
          r = new URL(e);
        } catch (o) {
          if (o.code === "ERR_INVALID_URL") {
            let a = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
            throw a.code = "INVALID_DOTENV_KEY", a;
          }
          throw o;
        }
        let n = r.password;
        if (!n) {
          let o = new Error("INVALID_DOTENV_KEY: Missing key part");
          throw o.code = "INVALID_DOTENV_KEY", o;
        }
        let A = r.searchParams.get("environment");
        if (!A) {
          let o = new Error("INVALID_DOTENV_KEY: Missing environment part");
          throw o.code = "INVALID_DOTENV_KEY", o;
        }
        let i = `DOTENV_VAULT_${A.toUpperCase()}`, s = t.parsed[i];
        if (!s) {
          let o = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${i} in your .env.vault file.`);
          throw o.code = "NOT_FOUND_DOTENV_ENVIRONMENT", o;
        }
        return { ciphertext: s, key: n };
      }
      function NC(t) {
        let e = null;
        if (t && t.path && t.path.length > 0) if (Array.isArray(t.path)) for (let r of t.path) Du.existsSync(r) && (e = r.endsWith(".vault") ? r : `${r}.vault`);
        else e = t.path.endsWith(".vault") ? t.path : `${t.path}.vault`;
        else e = Ru.resolve(process.cwd(), ".env.vault");
        return Du.existsSync(e) ? e : null;
      }
      function RC(t) {
        return t[0] === "~" ? Ru.join(TT.homedir(), t.slice(1)) : t;
      }
      function YT(t) {
        !!(t && t.debug) && bi("Loading env from encrypted .env.vault");
        let r = pe._parseVault(t), n = process.env;
        return t && t.processEnv != null && (n = t.processEnv), pe.populate(n, r, t), { parsed: r };
      }
      function GT(t) {
        let e = Ru.resolve(process.cwd(), ".env"), r = "utf8", n = !!(t && t.debug);
        t && t.encoding ? r = t.encoding : n && bi("No encoding is specified. UTF-8 is used by default");
        let A = [e];
        if (t && t.path) if (!Array.isArray(t.path)) A = [RC(t.path)];
        else {
          A = [];
          for (let a of t.path) A.push(RC(a));
        }
        let i, s = {};
        for (let a of A) try {
          let c = pe.parse(Du.readFileSync(a, { encoding: r }));
          pe.populate(s, c, t);
        } catch (c) {
          n && bi(`Failed to load ${a} ${c.message}`), i = c;
        }
        let o = process.env;
        return t && t.processEnv != null && (o = t.processEnv), pe.populate(o, s, t), i ? { parsed: s, error: i } : { parsed: s };
      }
      function OT(t) {
        if (bC(t).length === 0) return pe.configDotenv(t);
        let e = NC(t);
        return e ? pe._configVault(t) : (vT(`You set DOTENV_KEY but you are missing a .env.vault file at ${e}. Did you forget to build it?`), pe.configDotenv(t));
      }
      function VT(t, e) {
        let r = Buffer.from(e.slice(-64), "hex"), n = Buffer.from(t, "base64"), A = n.subarray(0, 12), i = n.subarray(-16);
        n = n.subarray(12, -16);
        try {
          let s = xT.createDecipheriv("aes-256-gcm", r, A);
          return s.setAuthTag(i), `${s.update(n)}${s.final()}`;
        } catch (s) {
          let o = s instanceof RangeError, a = s.message === "Invalid key length", c = s.message === "Unsupported state or unable to authenticate data";
          if (o || a) {
            let l = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
            throw l.code = "INVALID_DOTENV_KEY", l;
          } else if (c) {
            let l = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
            throw l.code = "DECRYPTION_FAILED", l;
          } else throw s;
        }
      }
      function HT(t, e, r = {}) {
        let n = !!(r && r.debug), A = !!(r && r.override);
        if (typeof e != "object") {
          let i = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
          throw i.code = "OBJECT_REQUIRED", i;
        }
        for (let i of Object.keys(e)) Object.prototype.hasOwnProperty.call(t, i) ? (A === true && (t[i] = e[i]), n && bi(A === true ? `"${i}" is already defined and WAS overwritten` : `"${i}" is already defined and was NOT overwritten`)) : t[i] = e[i];
      }
      var pe = { configDotenv: GT, _configVault: YT, _parseVault: LT, config: OT, decrypt: VT, parse: MT, populate: HT };
      ir.exports.configDotenv = pe.configDotenv;
      ir.exports._configVault = pe._configVault;
      ir.exports._parseVault = pe._parseVault;
      ir.exports.config = pe.config;
      ir.exports.decrypt = pe.decrypt;
      ir.exports.parse = pe.parse;
      ir.exports.populate = pe.populate;
      ir.exports = pe;
    });
    var kC = C((xj, Vo) => {
      "use strict";
      Vo.exports = (t = {}) => {
        let e;
        if (t.repoUrl) e = t.repoUrl;
        else if (t.user && t.repo) e = `https://github.com/${t.user}/${t.repo}`;
        else throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
        let r = new URL(`${e}/issues/new`), n = ["body", "title", "labels", "template", "milestone", "assignee", "projects"];
        for (let A of n) {
          let i = t[A];
          if (i !== void 0) {
            if (A === "labels" || A === "projects") {
              if (!Array.isArray(i)) throw new TypeError(`The \`${A}\` option should be an array`);
              i = i.join(",");
            }
            r.searchParams.set(A, i);
          }
        }
        return r.toString();
      };
      Vo.exports.default = Vo.exports;
    });
    var vu = C((i3, nI) => {
      "use strict";
      nI.exports = /* @__PURE__ */ (function() {
        function t(e, r, n, A, i) {
          return e < r || n < r ? e > n ? n + 1 : e + 1 : A === i ? r : r + 1;
        }
        return function(e, r) {
          if (e === r) return 0;
          if (e.length > r.length) {
            var n = e;
            e = r, r = n;
          }
          for (var A = e.length, i = r.length; A > 0 && e.charCodeAt(A - 1) === r.charCodeAt(i - 1); ) A--, i--;
          for (var s = 0; s < A && e.charCodeAt(s) === r.charCodeAt(s); ) s++;
          if (A -= s, i -= s, A === 0 || i < 3) return i;
          var o = 0, a, c, l, u, g, E, h, f, p, Q, I, B, w = [];
          for (a = 0; a < A; a++) w.push(a + 1), w.push(e.charCodeAt(s + a));
          for (var D = w.length - 1; o < i - 3; ) for (p = r.charCodeAt(s + (c = o)), Q = r.charCodeAt(s + (l = o + 1)), I = r.charCodeAt(s + (u = o + 2)), B = r.charCodeAt(s + (g = o + 3)), E = o += 4, a = 0; a < D; a += 2) h = w[a], f = w[a + 1], c = t(h, c, l, p, f), l = t(c, l, u, Q, f), u = t(l, u, g, I, f), E = t(u, g, E, B, f), w[a] = E, g = u, u = l, l = c, c = h;
          for (; o < i; ) for (p = r.charCodeAt(s + (c = o)), E = ++o, a = 0; a < D; a += 2) h = w[a], w[a] = E = t(h, c, E, p, w[a + 1]), c = h;
          return E;
        };
      })();
    });
    var aI = $h(() => {
      "use strict";
    });
    var cI = $h(() => {
      "use strict";
    });
    var ne = C((mK, vp) => {
      "use strict";
      vp.exports = { kClose: /* @__PURE__ */ Symbol("close"), kDestroy: /* @__PURE__ */ Symbol("destroy"), kDispatch: /* @__PURE__ */ Symbol("dispatch"), kUrl: /* @__PURE__ */ Symbol("url"), kWriting: /* @__PURE__ */ Symbol("writing"), kResuming: /* @__PURE__ */ Symbol("resuming"), kQueue: /* @__PURE__ */ Symbol("queue"), kConnect: /* @__PURE__ */ Symbol("connect"), kConnecting: /* @__PURE__ */ Symbol("connecting"), kKeepAliveDefaultTimeout: /* @__PURE__ */ Symbol("default keep alive timeout"), kKeepAliveMaxTimeout: /* @__PURE__ */ Symbol("max keep alive timeout"), kKeepAliveTimeoutThreshold: /* @__PURE__ */ Symbol("keep alive timeout threshold"), kKeepAliveTimeoutValue: /* @__PURE__ */ Symbol("keep alive timeout"), kKeepAlive: /* @__PURE__ */ Symbol("keep alive"), kHeadersTimeout: /* @__PURE__ */ Symbol("headers timeout"), kBodyTimeout: /* @__PURE__ */ Symbol("body timeout"), kServerName: /* @__PURE__ */ Symbol("server name"), kLocalAddress: /* @__PURE__ */ Symbol("local address"), kHost: /* @__PURE__ */ Symbol("host"), kNoRef: /* @__PURE__ */ Symbol("no ref"), kBodyUsed: /* @__PURE__ */ Symbol("used"), kBody: /* @__PURE__ */ Symbol("abstracted request body"), kRunning: /* @__PURE__ */ Symbol("running"), kBlocking: /* @__PURE__ */ Symbol("blocking"), kPending: /* @__PURE__ */ Symbol("pending"), kSize: /* @__PURE__ */ Symbol("size"), kBusy: /* @__PURE__ */ Symbol("busy"), kQueued: /* @__PURE__ */ Symbol("queued"), kFree: /* @__PURE__ */ Symbol("free"), kConnected: /* @__PURE__ */ Symbol("connected"), kClosed: /* @__PURE__ */ Symbol("closed"), kNeedDrain: /* @__PURE__ */ Symbol("need drain"), kReset: /* @__PURE__ */ Symbol("reset"), kDestroyed: /* @__PURE__ */ Symbol.for("nodejs.stream.destroyed"), kResume: /* @__PURE__ */ Symbol("resume"), kOnError: /* @__PURE__ */ Symbol("on error"), kMaxHeadersSize: /* @__PURE__ */ Symbol("max headers size"), kRunningIdx: /* @__PURE__ */ Symbol("running index"), kPendingIdx: /* @__PURE__ */ Symbol("pending index"), kError: /* @__PURE__ */ Symbol("error"), kClients: /* @__PURE__ */ Symbol("clients"), kClient: /* @__PURE__ */ Symbol("client"), kParser: /* @__PURE__ */ Symbol("parser"), kOnDestroyed: /* @__PURE__ */ Symbol("destroy callbacks"), kPipelining: /* @__PURE__ */ Symbol("pipelining"), kSocket: /* @__PURE__ */ Symbol("socket"), kHostHeader: /* @__PURE__ */ Symbol("host header"), kConnector: /* @__PURE__ */ Symbol("connector"), kStrictContentLength: /* @__PURE__ */ Symbol("strict content length"), kMaxRedirections: /* @__PURE__ */ Symbol("maxRedirections"), kMaxRequests: /* @__PURE__ */ Symbol("maxRequestsPerClient"), kProxy: /* @__PURE__ */ Symbol("proxy agent options"), kCounter: /* @__PURE__ */ Symbol("socket request counter"), kMaxResponseSize: /* @__PURE__ */ Symbol("max response size"), kHTTP2Session: /* @__PURE__ */ Symbol("http2Session"), kHTTP2SessionState: /* @__PURE__ */ Symbol("http2Session state"), kRetryHandlerDefaultRetry: /* @__PURE__ */ Symbol("retry agent default retry"), kConstruct: /* @__PURE__ */ Symbol("constructable"), kListeners: /* @__PURE__ */ Symbol("listeners"), kHTTPContext: /* @__PURE__ */ Symbol("http context"), kMaxConcurrentStreams: /* @__PURE__ */ Symbol("max concurrent streams"), kNoProxyAgent: /* @__PURE__ */ Symbol("no proxy agent"), kHttpProxyAgent: /* @__PURE__ */ Symbol("http proxy agent"), kHttpsProxyAgent: /* @__PURE__ */ Symbol("https proxy agent") };
    });
    var H = C((yK, Pp) => {
      "use strict";
      var Ee = class extends Error {
        constructor(e, r) {
          super(e, r), this.name = "UndiciError", this.code = "UND_ERR";
        }
      }, ig = class extends Ee {
        constructor(e) {
          super(e), this.name = "ConnectTimeoutError", this.message = e || "Connect Timeout Error", this.code = "UND_ERR_CONNECT_TIMEOUT";
        }
      }, sg = class extends Ee {
        constructor(e) {
          super(e), this.name = "HeadersTimeoutError", this.message = e || "Headers Timeout Error", this.code = "UND_ERR_HEADERS_TIMEOUT";
        }
      }, og = class extends Ee {
        constructor(e) {
          super(e), this.name = "HeadersOverflowError", this.message = e || "Headers Overflow Error", this.code = "UND_ERR_HEADERS_OVERFLOW";
        }
      }, ag = class extends Ee {
        constructor(e) {
          super(e), this.name = "BodyTimeoutError", this.message = e || "Body Timeout Error", this.code = "UND_ERR_BODY_TIMEOUT";
        }
      }, cg = class extends Ee {
        constructor(e, r, n, A) {
          super(e), this.name = "ResponseStatusCodeError", this.message = e || "Response Status Code Error", this.code = "UND_ERR_RESPONSE_STATUS_CODE", this.body = A, this.status = r, this.statusCode = r, this.headers = n;
        }
      }, lg = class extends Ee {
        constructor(e) {
          super(e), this.name = "InvalidArgumentError", this.message = e || "Invalid Argument Error", this.code = "UND_ERR_INVALID_ARG";
        }
      }, ug = class extends Ee {
        constructor(e) {
          super(e), this.name = "InvalidReturnValueError", this.message = e || "Invalid Return Value Error", this.code = "UND_ERR_INVALID_RETURN_VALUE";
        }
      }, Sa = class extends Ee {
        constructor(e) {
          super(e), this.name = "AbortError", this.message = e || "The operation was aborted";
        }
      }, gg = class extends Sa {
        constructor(e) {
          super(e), this.name = "AbortError", this.message = e || "Request aborted", this.code = "UND_ERR_ABORTED";
        }
      }, Eg = class extends Ee {
        constructor(e) {
          super(e), this.name = "InformationalError", this.message = e || "Request information", this.code = "UND_ERR_INFO";
        }
      }, dg = class extends Ee {
        constructor(e) {
          super(e), this.name = "RequestContentLengthMismatchError", this.message = e || "Request body length does not match content-length header", this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
        }
      }, hg = class extends Ee {
        constructor(e) {
          super(e), this.name = "ResponseContentLengthMismatchError", this.message = e || "Response body length does not match content-length header", this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
        }
      }, fg = class extends Ee {
        constructor(e) {
          super(e), this.name = "ClientDestroyedError", this.message = e || "The client is destroyed", this.code = "UND_ERR_DESTROYED";
        }
      }, Qg = class extends Ee {
        constructor(e) {
          super(e), this.name = "ClientClosedError", this.message = e || "The client is closed", this.code = "UND_ERR_CLOSED";
        }
      }, Cg = class extends Ee {
        constructor(e, r) {
          super(e), this.name = "SocketError", this.message = e || "Socket error", this.code = "UND_ERR_SOCKET", this.socket = r;
        }
      }, Ig = class extends Ee {
        constructor(e) {
          super(e), this.name = "NotSupportedError", this.message = e || "Not supported error", this.code = "UND_ERR_NOT_SUPPORTED";
        }
      }, pg = class extends Ee {
        constructor(e) {
          super(e), this.name = "MissingUpstreamError", this.message = e || "No upstream has been added to the BalancedPool", this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
        }
      }, Bg = class extends Error {
        constructor(e, r, n) {
          super(e), this.name = "HTTPParserError", this.code = r ? `HPE_${r}` : void 0, this.data = n ? n.toString() : void 0;
        }
      }, mg = class extends Ee {
        constructor(e) {
          super(e), this.name = "ResponseExceededMaxSizeError", this.message = e || "Response content exceeded max size", this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
        }
      }, yg = class extends Ee {
        constructor(e, r, { headers: n, data: A }) {
          super(e), this.name = "RequestRetryError", this.message = e || "Request retry error", this.code = "UND_ERR_REQ_RETRY", this.statusCode = r, this.data = A, this.headers = n;
        }
      }, wg = class extends Ee {
        constructor(e, r, { headers: n, body: A }) {
          super(e), this.name = "ResponseError", this.message = e || "Response error", this.code = "UND_ERR_RESPONSE", this.statusCode = r, this.body = A, this.headers = n;
        }
      }, Dg = class extends Ee {
        constructor(e, r, n = {}) {
          super(r, { cause: e, ...n }), this.name = "SecureProxyConnectionError", this.message = r || "Secure Proxy Connection failed", this.code = "UND_ERR_PRX_TLS", this.cause = e;
        }
      };
      Pp.exports = { AbortError: Sa, HTTPParserError: Bg, UndiciError: Ee, HeadersTimeoutError: sg, HeadersOverflowError: og, BodyTimeoutError: ag, RequestContentLengthMismatchError: dg, ConnectTimeoutError: ig, ResponseStatusCodeError: cg, InvalidArgumentError: lg, InvalidReturnValueError: ug, RequestAbortedError: gg, ClientDestroyedError: fg, ClientClosedError: Qg, InformationalError: Eg, SocketError: Cg, NotSupportedError: Ig, ResponseContentLengthMismatchError: hg, BalancedPoolMissingUpstreamError: pg, ResponseExceededMaxSizeError: mg, RequestRetryError: yg, ResponseError: wg, SecureProxyConnectionError: Dg };
    });
    var Na = C((wK, Gp) => {
      "use strict";
      var Rg = ["Accept", "Accept-Encoding", "Accept-Language", "Accept-Ranges", "Access-Control-Allow-Credentials", "Access-Control-Allow-Headers", "Access-Control-Allow-Methods", "Access-Control-Allow-Origin", "Access-Control-Expose-Headers", "Access-Control-Max-Age", "Access-Control-Request-Headers", "Access-Control-Request-Method", "Age", "Allow", "Alt-Svc", "Alt-Used", "Authorization", "Cache-Control", "Clear-Site-Data", "Connection", "Content-Disposition", "Content-Encoding", "Content-Language", "Content-Length", "Content-Location", "Content-Range", "Content-Security-Policy", "Content-Security-Policy-Report-Only", "Content-Type", "Cookie", "Cross-Origin-Embedder-Policy", "Cross-Origin-Opener-Policy", "Cross-Origin-Resource-Policy", "Date", "Device-Memory", "Downlink", "ECT", "ETag", "Expect", "Expect-CT", "Expires", "Forwarded", "From", "Host", "If-Match", "If-Modified-Since", "If-None-Match", "If-Range", "If-Unmodified-Since", "Keep-Alive", "Last-Modified", "Link", "Location", "Max-Forwards", "Origin", "Permissions-Policy", "Pragma", "Proxy-Authenticate", "Proxy-Authorization", "RTT", "Range", "Referer", "Referrer-Policy", "Refresh", "Retry-After", "Sec-WebSocket-Accept", "Sec-WebSocket-Extensions", "Sec-WebSocket-Key", "Sec-WebSocket-Protocol", "Sec-WebSocket-Version", "Server", "Server-Timing", "Service-Worker-Allowed", "Service-Worker-Navigation-Preload", "Set-Cookie", "SourceMap", "Strict-Transport-Security", "Supports-Loading-Mode", "TE", "Timing-Allow-Origin", "Trailer", "Transfer-Encoding", "Upgrade", "Upgrade-Insecure-Requests", "User-Agent", "Vary", "Via", "WWW-Authenticate", "X-Content-Type-Options", "X-DNS-Prefetch-Control", "X-Frame-Options", "X-Permitted-Cross-Domain-Policies", "X-Powered-By", "X-Requested-With", "X-XSS-Protection"], ba = {};
      Object.setPrototypeOf(ba, null);
      var Yp = {};
      Object.setPrototypeOf(Yp, null);
      function Hk(t) {
        let e = Yp[t];
        return e === void 0 && (e = Buffer.from(t)), e;
      }
      for (let t = 0; t < Rg.length; ++t) {
        let e = Rg[t], r = e.toLowerCase();
        ba[e] = ba[r] = r;
      }
      Gp.exports = { wellknownHeaderNames: Rg, headerNameLowerCasedRecord: ba, getHeaderNameAsBuffer: Hk };
    });
    var qp = C((DK, Hp) => {
      "use strict";
      var { wellknownHeaderNames: Op, headerNameLowerCasedRecord: qk } = Na(), Sg = class t {
        value = null;
        left = null;
        middle = null;
        right = null;
        code;
        constructor(e, r, n) {
          if (n === void 0 || n >= e.length) throw new TypeError("Unreachable");
          if ((this.code = e.charCodeAt(n)) > 127) throw new TypeError("key must be ascii string");
          e.length !== ++n ? this.middle = new t(e, r, n) : this.value = r;
        }
        add(e, r) {
          let n = e.length;
          if (n === 0) throw new TypeError("Unreachable");
          let A = 0, i = this;
          for (; ; ) {
            let s = e.charCodeAt(A);
            if (s > 127) throw new TypeError("key must be ascii string");
            if (i.code === s) if (n === ++A) {
              i.value = r;
              break;
            } else if (i.middle !== null) i = i.middle;
            else {
              i.middle = new t(e, r, A);
              break;
            }
            else if (i.code < s) if (i.left !== null) i = i.left;
            else {
              i.left = new t(e, r, A);
              break;
            }
            else if (i.right !== null) i = i.right;
            else {
              i.right = new t(e, r, A);
              break;
            }
          }
        }
        search(e) {
          let r = e.length, n = 0, A = this;
          for (; A !== null && n < r; ) {
            let i = e[n];
            for (i <= 90 && i >= 65 && (i |= 32); A !== null; ) {
              if (i === A.code) {
                if (r === ++n) return A;
                A = A.middle;
                break;
              }
              A = A.code < i ? A.left : A.right;
            }
          }
          return null;
        }
      }, Fa = class {
        node = null;
        insert(e, r) {
          this.node === null ? this.node = new Sg(e, r, 0) : this.node.add(e, r);
        }
        lookup(e) {
          return this.node?.search(e)?.value ?? null;
        }
      }, Vp = new Fa();
      for (let t = 0; t < Op.length; ++t) {
        let e = qk[Op[t]];
        Vp.insert(e, e);
      }
      Hp.exports = { TernarySearchTree: Fa, tree: Vp };
    });
    var Y = C((RK, oB) => {
      "use strict";
      var Xi = require("node:assert"), { kDestroyed: Wp, kBodyUsed: BA, kListeners: Ta, kBody: Jp } = ne(), { IncomingMessage: Jk } = require("node:http"), _p = require("node:stream"), Wk = require("node:net"), { Blob: _k } = require("node:buffer"), jk = require("node:util"), { stringify: Zk } = require("node:querystring"), { EventEmitter: Xk } = require("node:events"), { InvalidArgumentError: Re } = H(), { headerNameLowerCasedRecord: Kk } = Na(), { tree: jp } = qp(), [$k, zk] = process.versions.node.split(".").map((t) => Number(t)), Ua = class {
        constructor(e) {
          this[Jp] = e, this[BA] = false;
        }
        async *[Symbol.asyncIterator]() {
          Xi(!this[BA], "disturbed"), this[BA] = true, yield* this[Jp];
        }
      };
      function eM(t) {
        return ka(t) ? (zp(t) === 0 && t.on("data", function() {
          Xi(false);
        }), typeof t.readableDidRead != "boolean" && (t[BA] = false, Xk.prototype.on.call(t, "data", function() {
          this[BA] = true;
        })), t) : t && typeof t.pipeTo == "function" ? new Ua(t) : t && typeof t != "string" && !ArrayBuffer.isView(t) && $p(t) ? new Ua(t) : t;
      }
      function ka(t) {
        return t && typeof t == "object" && typeof t.pipe == "function" && typeof t.on == "function";
      }
      function Zp(t) {
        if (t === null) return false;
        if (t instanceof _k) return true;
        if (typeof t != "object") return false;
        {
          let e = t[Symbol.toStringTag];
          return (e === "Blob" || e === "File") && ("stream" in t && typeof t.stream == "function" || "arrayBuffer" in t && typeof t.arrayBuffer == "function");
        }
      }
      function tM(t, e) {
        if (t.includes("?") || t.includes("#")) throw new Error('Query params cannot be passed when url already contains "?" or "#".');
        let r = Zk(e);
        return r && (t += "?" + r), t;
      }
      function Xp(t) {
        let e = parseInt(t, 10);
        return e === Number(t) && e >= 0 && e <= 65535;
      }
      function xa(t) {
        return t != null && t[0] === "h" && t[1] === "t" && t[2] === "t" && t[3] === "p" && (t[4] === ":" || t[4] === "s" && t[5] === ":");
      }
      function Kp(t) {
        if (typeof t == "string") {
          if (t = new URL(t), !xa(t.origin || t.protocol)) throw new Re("Invalid URL protocol: the URL must start with `http:` or `https:`.");
          return t;
        }
        if (!t || typeof t != "object") throw new Re("Invalid URL: The URL argument must be a non-null object.");
        if (!(t instanceof URL)) {
          if (t.port != null && t.port !== "" && Xp(t.port) === false) throw new Re("Invalid URL: port must be a valid integer or a string representation of an integer.");
          if (t.path != null && typeof t.path != "string") throw new Re("Invalid URL path: the path must be a string or null/undefined.");
          if (t.pathname != null && typeof t.pathname != "string") throw new Re("Invalid URL pathname: the pathname must be a string or null/undefined.");
          if (t.hostname != null && typeof t.hostname != "string") throw new Re("Invalid URL hostname: the hostname must be a string or null/undefined.");
          if (t.origin != null && typeof t.origin != "string") throw new Re("Invalid URL origin: the origin must be a string or null/undefined.");
          if (!xa(t.origin || t.protocol)) throw new Re("Invalid URL protocol: the URL must start with `http:` or `https:`.");
          let e = t.port != null ? t.port : t.protocol === "https:" ? 443 : 80, r = t.origin != null ? t.origin : `${t.protocol || ""}//${t.hostname || ""}:${e}`, n = t.path != null ? t.path : `${t.pathname || ""}${t.search || ""}`;
          return r[r.length - 1] === "/" && (r = r.slice(0, r.length - 1)), n && n[0] !== "/" && (n = `/${n}`), new URL(`${r}${n}`);
        }
        if (!xa(t.origin || t.protocol)) throw new Re("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        return t;
      }
      function rM(t) {
        if (t = Kp(t), t.pathname !== "/" || t.search || t.hash) throw new Re("invalid url");
        return t;
      }
      function nM(t) {
        if (t[0] === "[") {
          let r = t.indexOf("]");
          return Xi(r !== -1), t.substring(1, r);
        }
        let e = t.indexOf(":");
        return e === -1 ? t : t.substring(0, e);
      }
      function AM(t) {
        if (!t) return null;
        Xi(typeof t == "string");
        let e = nM(t);
        return Wk.isIP(e) ? "" : e;
      }
      function iM(t) {
        return JSON.parse(JSON.stringify(t));
      }
      function sM(t) {
        return t != null && typeof t[Symbol.asyncIterator] == "function";
      }
      function $p(t) {
        return t != null && (typeof t[Symbol.iterator] == "function" || typeof t[Symbol.asyncIterator] == "function");
      }
      function zp(t) {
        if (t == null) return 0;
        if (ka(t)) {
          let e = t._readableState;
          return e && e.objectMode === false && e.ended === true && Number.isFinite(e.length) ? e.length : null;
        } else {
          if (Zp(t)) return t.size != null ? t.size : null;
          if (rB(t)) return t.byteLength;
        }
        return null;
      }
      function eB(t) {
        return t && !!(t.destroyed || t[Wp] || _p.isDestroyed?.(t));
      }
      function oM(t, e) {
        t == null || !ka(t) || eB(t) || (typeof t.destroy == "function" ? (Object.getPrototypeOf(t).constructor === Jk && (t.socket = null), t.destroy(e)) : e && queueMicrotask(() => {
          t.emit("error", e);
        }), t.destroyed !== true && (t[Wp] = true));
      }
      var aM = /timeout=(\d+)/;
      function cM(t) {
        let e = t.match(aM);
        return e ? parseInt(e[1], 10) * 1e3 : null;
      }
      function tB(t) {
        return typeof t == "string" ? Kk[t] ?? t.toLowerCase() : jp.lookup(t) ?? t.toString("latin1").toLowerCase();
      }
      function lM(t) {
        return jp.lookup(t) ?? t.toString("latin1").toLowerCase();
      }
      function uM(t, e) {
        e === void 0 && (e = {});
        for (let r = 0; r < t.length; r += 2) {
          let n = tB(t[r]), A = e[n];
          if (A) typeof A == "string" && (A = [A], e[n] = A), A.push(t[r + 1].toString("utf8"));
          else {
            let i = t[r + 1];
            typeof i == "string" ? e[n] = i : e[n] = Array.isArray(i) ? i.map((s) => s.toString("utf8")) : i.toString("utf8");
          }
        }
        return "content-length" in e && "content-disposition" in e && (e["content-disposition"] = Buffer.from(e["content-disposition"]).toString("latin1")), e;
      }
      function gM(t) {
        let e = t.length, r = new Array(e), n = false, A = -1, i, s, o = 0;
        for (let a = 0; a < e; a += 2) i = t[a], s = t[a + 1], typeof i != "string" && (i = i.toString()), typeof s != "string" && (s = s.toString("utf8")), o = i.length, o === 14 && i[7] === "-" && (i === "content-length" || i.toLowerCase() === "content-length") ? n = true : o === 19 && i[7] === "-" && (i === "content-disposition" || i.toLowerCase() === "content-disposition") && (A = a + 1), r[a] = i, r[a + 1] = s;
        return n && A !== -1 && (r[A] = Buffer.from(r[A]).toString("latin1")), r;
      }
      function EM(t) {
        if (!Array.isArray(t)) throw new TypeError("expected headers to be an array");
        return t.map((e) => Buffer.from(e));
      }
      function rB(t) {
        return t instanceof Uint8Array || Buffer.isBuffer(t);
      }
      function dM(t, e, r) {
        if (!t || typeof t != "object") throw new Re("handler must be an object");
        if (typeof t.onRequestStart != "function") {
          if (typeof t.onConnect != "function") throw new Re("invalid onConnect method");
          if (typeof t.onError != "function") throw new Re("invalid onError method");
          if (typeof t.onBodySent != "function" && t.onBodySent !== void 0) throw new Re("invalid onBodySent method");
          if (r || e === "CONNECT") {
            if (typeof t.onUpgrade != "function") throw new Re("invalid onUpgrade method");
          } else {
            if (typeof t.onHeaders != "function") throw new Re("invalid onHeaders method");
            if (typeof t.onData != "function") throw new Re("invalid onData method");
            if (typeof t.onComplete != "function") throw new Re("invalid onComplete method");
          }
        }
      }
      function hM(t) {
        return !!(t && (_p.isDisturbed(t) || t[BA]));
      }
      function fM(t) {
        return { localAddress: t.localAddress, localPort: t.localPort, remoteAddress: t.remoteAddress, remotePort: t.remotePort, remoteFamily: t.remoteFamily, timeout: t.timeout, bytesWritten: t.bytesWritten, bytesRead: t.bytesRead };
      }
      function QM(t) {
        let e;
        return new ReadableStream({ async start() {
          e = t[Symbol.asyncIterator]();
        }, pull(r) {
          async function n() {
            let { done: A, value: i } = await e.next();
            if (A) queueMicrotask(() => {
              r.close(), r.byobRequest?.respond(0);
            });
            else {
              let s = Buffer.isBuffer(i) ? i : Buffer.from(i);
              if (s.byteLength) r.enqueue(new Uint8Array(s));
              else return await n();
            }
          }
          return n();
        }, async cancel() {
          await e.return();
        }, type: "bytes" });
      }
      function CM(t) {
        return t && typeof t == "object" && typeof t.append == "function" && typeof t.delete == "function" && typeof t.get == "function" && typeof t.getAll == "function" && typeof t.has == "function" && typeof t.set == "function" && t[Symbol.toStringTag] === "FormData";
      }
      function IM(t, e) {
        return "addEventListener" in t ? (t.addEventListener("abort", e, { once: true }), () => t.removeEventListener("abort", e)) : (t.once("abort", e), () => t.removeListener("abort", e));
      }
      var nB = typeof String.prototype.toWellFormed == "function" ? (t) => `${t}`.toWellFormed() : jk.toUSVString, pM = typeof String.prototype.isWellFormed == "function" ? (t) => `${t}`.isWellFormed() : (t) => nB(t) === `${t}`;
      function AB(t) {
        switch (t) {
          case 34:
          case 40:
          case 41:
          case 44:
          case 47:
          case 58:
          case 59:
          case 60:
          case 61:
          case 62:
          case 63:
          case 64:
          case 91:
          case 92:
          case 93:
          case 123:
          case 125:
            return false;
          default:
            return t >= 33 && t <= 126;
        }
      }
      function BM(t) {
        if (t.length === 0) return false;
        for (let e = 0; e < t.length; ++e) if (!AB(t.charCodeAt(e))) return false;
        return true;
      }
      var mM = /[^\t\x20-\x7e\x80-\xff]/;
      function yM(t) {
        return !mM.test(t);
      }
      var wM = /^bytes (\d+)-(\d+)\/(\d+)?$/;
      function DM(t) {
        if (t == null || t === "") return { start: 0, end: null, size: null };
        let e = t ? t.match(wM) : null;
        return e ? { start: parseInt(e[1]), end: e[2] ? parseInt(e[2]) : null, size: e[3] ? parseInt(e[3]) : null } : null;
      }
      function RM(t, e, r) {
        return (t[Ta] ??= []).push([e, r]), t.on(e, r), t;
      }
      function SM(t) {
        if (t[Ta] != null) {
          for (let [e, r] of t[Ta]) t.removeListener(e, r);
          t[Ta] = null;
        }
        return t;
      }
      function bM(t, e, r) {
        try {
          e.onError(r), Xi(e.aborted);
        } catch (n) {
          t.emit("error", n);
        }
      }
      var iB = /* @__PURE__ */ Object.create(null);
      iB.enumerable = true;
      var bg = { delete: "DELETE", DELETE: "DELETE", get: "GET", GET: "GET", head: "HEAD", HEAD: "HEAD", options: "OPTIONS", OPTIONS: "OPTIONS", post: "POST", POST: "POST", put: "PUT", PUT: "PUT" }, sB = { ...bg, patch: "patch", PATCH: "PATCH" };
      Object.setPrototypeOf(bg, null);
      Object.setPrototypeOf(sB, null);
      oB.exports = { kEnumerableProperty: iB, isDisturbed: hM, toUSVString: nB, isUSVString: pM, isBlobLike: Zp, parseOrigin: rM, parseURL: Kp, getServerName: AM, isStream: ka, isIterable: $p, isAsyncIterable: sM, isDestroyed: eB, headerNameToString: tB, bufferToLowerCasedHeaderName: lM, addListener: RM, removeAllListeners: SM, errorRequest: bM, parseRawHeaders: gM, encodeRawHeaders: EM, parseHeaders: uM, parseKeepAliveTimeout: cM, destroy: oM, bodyLength: zp, deepClone: iM, ReadableStreamFrom: QM, isBuffer: rB, assertRequestHandler: dM, getSocketInfo: fM, isFormDataLike: CM, serializePathWithQuery: tM, addAbortListener: IM, isValidHTTPToken: BM, isValidHeaderValue: yM, isTokenCharCode: AB, parseRangeHeader: DM, normalizedMethodRecordsBase: bg, normalizedMethodRecords: sB, isValidPort: Xp, isHttpOrHttpsPrefixed: xa, nodeMajor: $k, nodeMinor: zk, safeHTTPMethods: Object.freeze(["GET", "HEAD", "OPTIONS", "TRACE"]), wrapRequestBody: eM };
    });
    var lr = C((SK, gB) => {
      "use strict";
      var se = require("node:diagnostics_channel"), Ng = require("node:util"), En = Ng.debuglog("undici"), Ki = Ng.debuglog("fetch"), Ma = Ng.debuglog("websocket"), NM = { beforeConnect: se.channel("undici:client:beforeConnect"), connected: se.channel("undici:client:connected"), connectError: se.channel("undici:client:connectError"), sendHeaders: se.channel("undici:client:sendHeaders"), create: se.channel("undici:request:create"), bodySent: se.channel("undici:request:bodySent"), headers: se.channel("undici:request:headers"), trailers: se.channel("undici:request:trailers"), error: se.channel("undici:request:error"), open: se.channel("undici:websocket:open"), close: se.channel("undici:websocket:close"), socketError: se.channel("undici:websocket:socket_error"), ping: se.channel("undici:websocket:ping"), pong: se.channel("undici:websocket:pong") }, aB = false;
      function uB(t = En) {
        aB || (aB = true, se.subscribe("undici:client:beforeConnect", (e) => {
          let { connectParams: { version: r, protocol: n, port: A, host: i } } = e;
          t("connecting to %s%s using %s%s", i, A ? `:${A}` : "", n, r);
        }), se.subscribe("undici:client:connected", (e) => {
          let { connectParams: { version: r, protocol: n, port: A, host: i } } = e;
          t("connected to %s%s using %s%s", i, A ? `:${A}` : "", n, r);
        }), se.subscribe("undici:client:connectError", (e) => {
          let { connectParams: { version: r, protocol: n, port: A, host: i }, error: s } = e;
          t("connection to %s%s using %s%s errored - %s", i, A ? `:${A}` : "", n, r, s.message);
        }), se.subscribe("undici:client:sendHeaders", (e) => {
          let { request: { method: r, path: n, origin: A } } = e;
          t("sending request to %s %s/%s", r, A, n);
        }));
      }
      var cB = false;
      function FM(t = En) {
        cB || (cB = true, se.subscribe("undici:request:headers", (e) => {
          let { request: { method: r, path: n, origin: A }, response: { statusCode: i } } = e;
          t("received response to %s %s/%s - HTTP %d", r, A, n, i);
        }), se.subscribe("undici:request:trailers", (e) => {
          let { request: { method: r, path: n, origin: A } } = e;
          t("trailers received from %s %s/%s", r, A, n);
        }), se.subscribe("undici:request:error", (e) => {
          let { request: { method: r, path: n, origin: A }, error: i } = e;
          t("request to %s %s/%s errored - %s", r, A, n, i.message);
        }));
      }
      var lB = false;
      function TM(t = Ma) {
        lB || (lB = true, se.subscribe("undici:websocket:open", (e) => {
          let { address: { address: r, port: n } } = e;
          t("connection opened %s%s", r, n ? `:${n}` : "");
        }), se.subscribe("undici:websocket:close", (e) => {
          let { websocket: r, code: n, reason: A } = e;
          t("closed connection to %s - %s %s", r.url, n, A);
        }), se.subscribe("undici:websocket:socket_error", (e) => {
          t("connection errored - %s", e.message);
        }), se.subscribe("undici:websocket:ping", (e) => {
          t("ping received");
        }), se.subscribe("undici:websocket:pong", (e) => {
          t("pong received");
        }));
      }
      (En.enabled || Ki.enabled) && (uB(Ki.enabled ? Ki : En), FM(Ki.enabled ? Ki : En));
      Ma.enabled && (uB(En.enabled ? En : Ma), TM(Ma));
      gB.exports = { channels: NM };
    });
    var QB = C((bK, fB) => {
      "use strict";
      var { InvalidArgumentError: ge, NotSupportedError: xM } = H(), Gt = require("node:assert"), { isValidHTTPToken: hB, isValidHeaderValue: EB, isStream: UM, destroy: kM, isBuffer: MM, isFormDataLike: LM, isIterable: vM, isBlobLike: PM, serializePathWithQuery: YM, assertRequestHandler: GM, getServerName: OM, normalizedMethodRecords: VM } = Y(), { channels: Ot } = lr(), { headerNameLowerCasedRecord: dB } = Na(), HM = /[^\u0021-\u00ff]/, gt = /* @__PURE__ */ Symbol("handler"), Fg = class {
        constructor(e, { path: r, method: n, body: A, headers: i, query: s, idempotent: o, blocking: a, upgrade: c, headersTimeout: l, bodyTimeout: u, reset: g, expectContinue: E, servername: h, throwOnError: f }, p) {
          if (typeof r != "string") throw new ge("path must be a string");
          if (r[0] !== "/" && !(r.startsWith("http://") || r.startsWith("https://")) && n !== "CONNECT") throw new ge("path must be an absolute URL or start with a slash");
          if (HM.test(r)) throw new ge("invalid request path");
          if (typeof n != "string") throw new ge("method must be a string");
          if (VM[n] === void 0 && !hB(n)) throw new ge("invalid request method");
          if (c && typeof c != "string") throw new ge("upgrade must be a string");
          if (l != null && (!Number.isFinite(l) || l < 0)) throw new ge("invalid headersTimeout");
          if (u != null && (!Number.isFinite(u) || u < 0)) throw new ge("invalid bodyTimeout");
          if (g != null && typeof g != "boolean") throw new ge("invalid reset");
          if (E != null && typeof E != "boolean") throw new ge("invalid expectContinue");
          if (f != null) throw new ge("invalid throwOnError");
          if (this.headersTimeout = l, this.bodyTimeout = u, this.method = n, this.abort = null, A == null) this.body = null;
          else if (UM(A)) {
            this.body = A;
            let Q = this.body._readableState;
            (!Q || !Q.autoDestroy) && (this.endHandler = function() {
              kM(this);
            }, this.body.on("end", this.endHandler)), this.errorHandler = (I) => {
              this.abort ? this.abort(I) : this.error = I;
            }, this.body.on("error", this.errorHandler);
          } else if (MM(A)) this.body = A.byteLength ? A : null;
          else if (ArrayBuffer.isView(A)) this.body = A.buffer.byteLength ? Buffer.from(A.buffer, A.byteOffset, A.byteLength) : null;
          else if (A instanceof ArrayBuffer) this.body = A.byteLength ? Buffer.from(A) : null;
          else if (typeof A == "string") this.body = A.length ? Buffer.from(A) : null;
          else if (LM(A) || vM(A) || PM(A)) this.body = A;
          else throw new ge("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
          if (this.completed = false, this.aborted = false, this.upgrade = c || null, this.path = s ? YM(r, s) : r, this.origin = e, this.idempotent = o ?? (n === "HEAD" || n === "GET"), this.blocking = a ?? this.method !== "HEAD", this.reset = g ?? null, this.host = null, this.contentLength = null, this.contentType = null, this.headers = [], this.expectContinue = E ?? false, Array.isArray(i)) {
            if (i.length % 2 !== 0) throw new ge("headers array must be even");
            for (let Q = 0; Q < i.length; Q += 2) La(this, i[Q], i[Q + 1]);
          } else if (i && typeof i == "object") if (i[Symbol.iterator]) for (let Q of i) {
            if (!Array.isArray(Q) || Q.length !== 2) throw new ge("headers must be in key-value pair format");
            La(this, Q[0], Q[1]);
          }
          else {
            let Q = Object.keys(i);
            for (let I = 0; I < Q.length; ++I) La(this, Q[I], i[Q[I]]);
          }
          else if (i != null) throw new ge("headers must be an object or an array");
          GM(p, n, c), this.servername = h || OM(this.host) || null, this[gt] = p, Ot.create.hasSubscribers && Ot.create.publish({ request: this });
        }
        onBodySent(e) {
          if (this[gt].onBodySent) try {
            return this[gt].onBodySent(e);
          } catch (r) {
            this.abort(r);
          }
        }
        onRequestSent() {
          if (Ot.bodySent.hasSubscribers && Ot.bodySent.publish({ request: this }), this[gt].onRequestSent) try {
            return this[gt].onRequestSent();
          } catch (e) {
            this.abort(e);
          }
        }
        onConnect(e) {
          if (Gt(!this.aborted), Gt(!this.completed), this.error) e(this.error);
          else return this.abort = e, this[gt].onConnect(e);
        }
        onResponseStarted() {
          return this[gt].onResponseStarted?.();
        }
        onHeaders(e, r, n, A) {
          Gt(!this.aborted), Gt(!this.completed), Ot.headers.hasSubscribers && Ot.headers.publish({ request: this, response: { statusCode: e, headers: r, statusText: A } });
          try {
            return this[gt].onHeaders(e, r, n, A);
          } catch (i) {
            this.abort(i);
          }
        }
        onData(e) {
          Gt(!this.aborted), Gt(!this.completed);
          try {
            return this[gt].onData(e);
          } catch (r) {
            return this.abort(r), false;
          }
        }
        onUpgrade(e, r, n) {
          return Gt(!this.aborted), Gt(!this.completed), this[gt].onUpgrade(e, r, n);
        }
        onComplete(e) {
          this.onFinally(), Gt(!this.aborted), Gt(!this.completed), this.completed = true, Ot.trailers.hasSubscribers && Ot.trailers.publish({ request: this, trailers: e });
          try {
            return this[gt].onComplete(e);
          } catch (r) {
            this.onError(r);
          }
        }
        onError(e) {
          if (this.onFinally(), Ot.error.hasSubscribers && Ot.error.publish({ request: this, error: e }), !this.aborted) return this.aborted = true, this[gt].onError(e);
        }
        onFinally() {
          this.errorHandler && (this.body.off("error", this.errorHandler), this.errorHandler = null), this.endHandler && (this.body.off("end", this.endHandler), this.endHandler = null);
        }
        addHeader(e, r) {
          return La(this, e, r), this;
        }
      };
      function La(t, e, r) {
        if (r && typeof r == "object" && !Array.isArray(r)) throw new ge(`invalid ${e} header`);
        if (r === void 0) return;
        let n = dB[e];
        if (n === void 0 && (n = e.toLowerCase(), dB[n] === void 0 && !hB(n))) throw new ge("invalid header key");
        if (Array.isArray(r)) {
          let A = [];
          for (let i = 0; i < r.length; i++) if (typeof r[i] == "string") {
            if (!EB(r[i])) throw new ge(`invalid ${e} header`);
            A.push(r[i]);
          } else if (r[i] === null) A.push("");
          else {
            if (typeof r[i] == "object") throw new ge(`invalid ${e} header`);
            A.push(`${r[i]}`);
          }
          r = A;
        } else if (typeof r == "string") {
          if (!EB(r)) throw new ge(`invalid ${e} header`);
        } else r === null ? r = "" : r = `${r}`;
        if (t.host === null && n === "host") {
          if (typeof r != "string") throw new ge("invalid host header");
          t.host = r;
        } else if (t.contentLength === null && n === "content-length") {
          if (t.contentLength = parseInt(r, 10), !Number.isFinite(t.contentLength)) throw new ge("invalid content-length header");
        } else if (t.contentType === null && n === "content-type") t.contentType = r, t.headers.push(e, r);
        else {
          if (n === "transfer-encoding" || n === "keep-alive" || n === "upgrade") throw new ge(`invalid ${n} header`);
          if (n === "connection") {
            let A = typeof r == "string" ? r.toLowerCase() : null;
            if (A !== "close" && A !== "keep-alive") throw new ge("invalid connection header");
            A === "close" && (t.reset = true);
          } else {
            if (n === "expect") throw new xM("expect header not supported");
            t.headers.push(e, r);
          }
        }
      }
      fB.exports = Fg;
    });
    var va = C((NK, IB) => {
      "use strict";
      var { InvalidArgumentError: qM } = H();
      IB.exports = class CB {
        #e;
        constructor(e) {
          this.#e = e;
        }
        static wrap(e) {
          return e.onRequestStart ? e : new CB(e);
        }
        onConnect(e, r) {
          return this.#e.onConnect?.(e, r);
        }
        onHeaders(e, r, n, A) {
          return this.#e.onHeaders?.(e, r, n, A);
        }
        onUpgrade(e, r, n) {
          return this.#e.onUpgrade?.(e, r, n);
        }
        onData(e) {
          return this.#e.onData?.(e);
        }
        onComplete(e) {
          return this.#e.onComplete?.(e);
        }
        onError(e) {
          if (!this.#e.onError) throw e;
          return this.#e.onError?.(e);
        }
        onRequestStart(e, r) {
          this.#e.onConnect?.((n) => e.abort(n), r);
        }
        onRequestUpgrade(e, r, n, A) {
          let i = [];
          for (let [s, o] of Object.entries(n)) i.push(Buffer.from(s), Array.isArray(o) ? o.map((a) => Buffer.from(a)) : Buffer.from(o));
          this.#e.onUpgrade?.(r, i, A);
        }
        onResponseStart(e, r, n, A) {
          let i = [];
          for (let [s, o] of Object.entries(n)) i.push(Buffer.from(s), Array.isArray(o) ? o.map((a) => Buffer.from(a)) : Buffer.from(o));
          this.#e.onHeaders?.(r, i, () => e.resume(), A) === false && e.pause();
        }
        onResponseData(e, r) {
          this.#e.onData?.(r) === false && e.pause();
        }
        onResponseEnd(e, r) {
          let n = [];
          for (let [A, i] of Object.entries(r)) n.push(Buffer.from(A), Array.isArray(i) ? i.map((s) => Buffer.from(s)) : Buffer.from(i));
          this.#e.onComplete?.(n);
        }
        onResponseError(e, r) {
          if (!this.#e.onError) throw new qM("invalid onError method");
          this.#e.onError?.(r);
        }
      };
    });
    var $i = C((FK, pB) => {
      "use strict";
      var JM = require("node:events"), WM = va(), _M = (t) => (e, r) => t(e, WM.wrap(r)), Tg = class extends JM {
        dispatch() {
          throw new Error("not implemented");
        }
        close() {
          throw new Error("not implemented");
        }
        destroy() {
          throw new Error("not implemented");
        }
        compose(...e) {
          let r = Array.isArray(e[0]) ? e[0] : e, n = this.dispatch.bind(this);
          for (let A of r) if (A != null) {
            if (typeof A != "function") throw new TypeError(`invalid interceptor, expected function received ${typeof A}`);
            if (n = A(n), n = _M(n), n == null || typeof n != "function" || n.length !== 2) throw new TypeError("invalid interceptor");
          }
          return new Proxy(this, { get: (A, i) => i === "dispatch" ? n : A[i] });
        }
      };
      pB.exports = Tg;
    });
    var yB = C((TK, mB) => {
      "use strict";
      var { parseHeaders: xg } = Y(), { InvalidArgumentError: jM } = H(), Ug = /* @__PURE__ */ Symbol("resume"), kg = class {
        #e = false;
        #t = null;
        #r = false;
        #n;
        [Ug] = null;
        constructor(e) {
          this.#n = e;
        }
        pause() {
          this.#e = true;
        }
        resume() {
          this.#e && (this.#e = false, this[Ug]?.());
        }
        abort(e) {
          this.#r || (this.#r = true, this.#t = e, this.#n(e));
        }
        get aborted() {
          return this.#r;
        }
        get reason() {
          return this.#t;
        }
        get paused() {
          return this.#e;
        }
      };
      mB.exports = class BB {
        #e;
        #t;
        constructor(e) {
          this.#e = e;
        }
        static unwrap(e) {
          return e.onRequestStart ? new BB(e) : e;
        }
        onConnect(e, r) {
          this.#t = new kg(e), this.#e.onRequestStart?.(this.#t, r);
        }
        onUpgrade(e, r, n) {
          this.#e.onRequestUpgrade?.(this.#t, e, xg(r), n);
        }
        onHeaders(e, r, n, A) {
          return this.#t[Ug] = n, this.#e.onResponseStart?.(this.#t, e, xg(r), A), !this.#t.paused;
        }
        onData(e) {
          return this.#e.onResponseData?.(this.#t, e), !this.#t.paused;
        }
        onComplete(e) {
          this.#e.onResponseEnd?.(this.#t, xg(e));
        }
        onError(e) {
          if (!this.#e.onResponseError) throw new jM("invalid onError method");
          this.#e.onResponseError?.(this.#t, e);
        }
      };
    });
    var wA = C((xK, wB) => {
      "use strict";
      var ZM = $i(), XM = yB(), { ClientDestroyedError: Mg, ClientClosedError: KM, InvalidArgumentError: Pa } = H(), { kDestroy: $M, kClose: zM, kClosed: zi, kDestroyed: mA, kDispatch: eL } = ne(), ur = /* @__PURE__ */ Symbol("onDestroyed"), yA = /* @__PURE__ */ Symbol("onClosed"), Lg = class extends ZM {
        constructor() {
          super(), this[mA] = false, this[ur] = null, this[zi] = false, this[yA] = [];
        }
        get destroyed() {
          return this[mA];
        }
        get closed() {
          return this[zi];
        }
        close(e) {
          if (e === void 0) return new Promise((n, A) => {
            this.close((i, s) => i ? A(i) : n(s));
          });
          if (typeof e != "function") throw new Pa("invalid callback");
          if (this[mA]) {
            queueMicrotask(() => e(new Mg(), null));
            return;
          }
          if (this[zi]) {
            this[yA] ? this[yA].push(e) : queueMicrotask(() => e(null, null));
            return;
          }
          this[zi] = true, this[yA].push(e);
          let r = () => {
            let n = this[yA];
            this[yA] = null;
            for (let A = 0; A < n.length; A++) n[A](null, null);
          };
          this[zM]().then(() => this.destroy()).then(() => {
            queueMicrotask(r);
          });
        }
        destroy(e, r) {
          if (typeof e == "function" && (r = e, e = null), r === void 0) return new Promise((A, i) => {
            this.destroy(e, (s, o) => s ? i(s) : A(o));
          });
          if (typeof r != "function") throw new Pa("invalid callback");
          if (this[mA]) {
            this[ur] ? this[ur].push(r) : queueMicrotask(() => r(null, null));
            return;
          }
          e || (e = new Mg()), this[mA] = true, this[ur] = this[ur] || [], this[ur].push(r);
          let n = () => {
            let A = this[ur];
            this[ur] = null;
            for (let i = 0; i < A.length; i++) A[i](null, null);
          };
          this[$M](e).then(() => {
            queueMicrotask(n);
          });
        }
        dispatch(e, r) {
          if (!r || typeof r != "object") throw new Pa("handler must be an object");
          r = XM.unwrap(r);
          try {
            if (!e || typeof e != "object") throw new Pa("opts must be an object.");
            if (this[mA] || this[ur]) throw new Mg();
            if (this[zi]) throw new KM();
            return this[eL](e, r);
          } catch (n) {
            if (typeof r.onError != "function") throw n;
            return r.onError(n), false;
          }
        }
      };
      wB.exports = Lg;
    });
    var Hg = C((UK, bB) => {
      "use strict";
      var DA = 0, vg = 1e3, Pg = (vg >> 1) - 1, gr, Yg = /* @__PURE__ */ Symbol("kFastTimer"), Er = [], Gg = -2, Og = -1, RB = 0, DB = 1;
      function Vg() {
        DA += Pg;
        let t = 0, e = Er.length;
        for (; t < e; ) {
          let r = Er[t];
          r._state === RB ? (r._idleStart = DA - Pg, r._state = DB) : r._state === DB && DA >= r._idleStart + r._idleTimeout && (r._state = Og, r._idleStart = -1, r._onTimeout(r._timerArg)), r._state === Og ? (r._state = Gg, --e !== 0 && (Er[t] = Er[e])) : ++t;
        }
        Er.length = e, Er.length !== 0 && SB();
      }
      function SB() {
        gr ? gr.refresh() : (clearTimeout(gr), gr = setTimeout(Vg, Pg), gr.unref && gr.unref());
      }
      var Ya = class {
        [Yg] = true;
        _state = Gg;
        _idleTimeout = -1;
        _idleStart = -1;
        _onTimeout;
        _timerArg;
        constructor(e, r, n) {
          this._onTimeout = e, this._idleTimeout = r, this._timerArg = n, this.refresh();
        }
        refresh() {
          this._state === Gg && Er.push(this), (!gr || Er.length === 1) && SB(), this._state = RB;
        }
        clear() {
          this._state = Og, this._idleStart = -1;
        }
      };
      bB.exports = { setTimeout(t, e, r) {
        return e <= vg ? setTimeout(t, e, r) : new Ya(t, e, r);
      }, clearTimeout(t) {
        t[Yg] ? t.clear() : clearTimeout(t);
      }, setFastTimeout(t, e, r) {
        return new Ya(t, e, r);
      }, clearFastTimeout(t) {
        t.clear();
      }, now() {
        return DA;
      }, tick(t = 0) {
        DA += t - vg + 1, Vg(), Vg();
      }, reset() {
        DA = 0, Er.length = 0, clearTimeout(gr), gr = null;
      }, kFastTimer: Yg };
    });
    var es = C((LK, UB) => {
      "use strict";
      var tL = require("node:net"), NB = require("node:assert"), xB = Y(), { InvalidArgumentError: rL, ConnectTimeoutError: nL } = H(), Ga = Hg();
      function FB() {
      }
      var qg, Jg;
      global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG) ? Jg = class {
        constructor(e) {
          this._maxCachedSessions = e, this._sessionCache = /* @__PURE__ */ new Map(), this._sessionRegistry = new global.FinalizationRegistry((r) => {
            if (this._sessionCache.size < this._maxCachedSessions) return;
            let n = this._sessionCache.get(r);
            n !== void 0 && n.deref() === void 0 && this._sessionCache.delete(r);
          });
        }
        get(e) {
          let r = this._sessionCache.get(e);
          return r ? r.deref() : null;
        }
        set(e, r) {
          this._maxCachedSessions !== 0 && (this._sessionCache.set(e, new WeakRef(r)), this._sessionRegistry.register(r, e));
        }
      } : Jg = class {
        constructor(e) {
          this._maxCachedSessions = e, this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(e) {
          return this._sessionCache.get(e);
        }
        set(e, r) {
          if (this._maxCachedSessions !== 0) {
            if (this._sessionCache.size >= this._maxCachedSessions) {
              let { value: n } = this._sessionCache.keys().next();
              this._sessionCache.delete(n);
            }
            this._sessionCache.set(e, r);
          }
        }
      };
      function AL({ allowH2: t, maxCachedSessions: e, socketPath: r, timeout: n, session: A, ...i }) {
        if (e != null && (!Number.isInteger(e) || e < 0)) throw new rL("maxCachedSessions must be a positive integer or zero");
        let s = { path: r, ...i }, o = new Jg(e ?? 100);
        return n = n ?? 1e4, t = t ?? false, function({ hostname: c, host: l, protocol: u, port: g, servername: E, localAddress: h, httpSocket: f }, p) {
          let Q;
          if (u === "https:") {
            qg || (qg = require("node:tls")), E = E || s.servername || xB.getServerName(l) || null;
            let B = E || c;
            NB(B);
            let w = A || o.get(B) || null;
            g = g || 443, Q = qg.connect({ highWaterMark: 16384, ...s, servername: E, session: w, localAddress: h, ALPNProtocols: t ? ["http/1.1", "h2"] : ["http/1.1"], socket: f, port: g, host: c }), Q.on("session", function(D) {
              o.set(B, D);
            });
          } else NB(!f, "httpSocket can only be sent on TLS update"), g = g || 80, Q = tL.connect({ highWaterMark: 64 * 1024, ...s, localAddress: h, port: g, host: c });
          if (s.keepAlive == null || s.keepAlive) {
            let B = s.keepAliveInitialDelay === void 0 ? 6e4 : s.keepAliveInitialDelay;
            Q.setKeepAlive(true, B);
          }
          let I = iL(new WeakRef(Q), { timeout: n, hostname: c, port: g });
          return Q.setNoDelay(true).once(u === "https:" ? "secureConnect" : "connect", function() {
            if (queueMicrotask(I), p) {
              let B = p;
              p = null, B(null, this);
            }
          }).on("error", function(B) {
            if (queueMicrotask(I), p) {
              let w = p;
              p = null, w(B);
            }
          }), Q;
        };
      }
      var iL = process.platform === "win32" ? (t, e) => {
        if (!e.timeout) return FB;
        let r = null, n = null, A = Ga.setFastTimeout(() => {
          r = setImmediate(() => {
            n = setImmediate(() => TB(t.deref(), e));
          });
        }, e.timeout);
        return () => {
          Ga.clearFastTimeout(A), clearImmediate(r), clearImmediate(n);
        };
      } : (t, e) => {
        if (!e.timeout) return FB;
        let r = null, n = Ga.setFastTimeout(() => {
          r = setImmediate(() => {
            TB(t.deref(), e);
          });
        }, e.timeout);
        return () => {
          Ga.clearFastTimeout(n), clearImmediate(r);
        };
      };
      function TB(t, e) {
        if (t == null) return;
        let r = "Connect Timeout Error";
        Array.isArray(t.autoSelectFamilyAttemptedAddresses) ? r += ` (attempted addresses: ${t.autoSelectFamilyAttemptedAddresses.join(", ")},` : r += ` (attempted address: ${e.hostname}:${e.port},`, r += ` timeout: ${e.timeout}ms)`, xB.destroy(t, new nL(r));
      }
      UB.exports = AL;
    });
    var kB = C((Oa) => {
      "use strict";
      Object.defineProperty(Oa, "__esModule", { value: true });
      Oa.enumToMap = void 0;
      function sL(t, e = [], r = []) {
        var n, A;
        let i = ((n = e?.length) !== null && n !== void 0 ? n : 0) === 0, s = ((A = r?.length) !== null && A !== void 0 ? A : 0) === 0;
        return Object.fromEntries(Object.entries(t).filter(([, o]) => typeof o == "number" && (i || e.includes(o)) && (s || !r.includes(o))));
      }
      Oa.enumToMap = sL;
    });
    var MB = C((d) => {
      "use strict";
      Object.defineProperty(d, "__esModule", { value: true });
      d.SPECIAL_HEADERS = d.MINOR = d.MAJOR = d.HTAB_SP_VCHAR_OBS_TEXT = d.QUOTED_STRING = d.CONNECTION_TOKEN_CHARS = d.HEADER_CHARS = d.TOKEN = d.HEX = d.URL_CHAR = d.USERINFO_CHARS = d.MARK = d.ALPHANUM = d.NUM = d.HEX_MAP = d.NUM_MAP = d.ALPHA = d.STATUSES_HTTP = d.H_METHOD_MAP = d.METHOD_MAP = d.METHODS_RTSP = d.METHODS_ICE = d.METHODS_HTTP = d.HEADER_STATE = d.FINISH = d.STATUSES = d.METHODS = d.LENIENT_FLAGS = d.FLAGS = d.TYPE = d.ERROR = void 0;
      var oL = kB();
      d.ERROR = { OK: 0, INTERNAL: 1, STRICT: 2, CR_EXPECTED: 25, LF_EXPECTED: 3, UNEXPECTED_CONTENT_LENGTH: 4, UNEXPECTED_SPACE: 30, CLOSED_CONNECTION: 5, INVALID_METHOD: 6, INVALID_URL: 7, INVALID_CONSTANT: 8, INVALID_VERSION: 9, INVALID_HEADER_TOKEN: 10, INVALID_CONTENT_LENGTH: 11, INVALID_CHUNK_SIZE: 12, INVALID_STATUS: 13, INVALID_EOF_STATE: 14, INVALID_TRANSFER_ENCODING: 15, CB_MESSAGE_BEGIN: 16, CB_HEADERS_COMPLETE: 17, CB_MESSAGE_COMPLETE: 18, CB_CHUNK_HEADER: 19, CB_CHUNK_COMPLETE: 20, PAUSED: 21, PAUSED_UPGRADE: 22, PAUSED_H2_UPGRADE: 23, USER: 24, CB_URL_COMPLETE: 26, CB_STATUS_COMPLETE: 27, CB_METHOD_COMPLETE: 32, CB_VERSION_COMPLETE: 33, CB_HEADER_FIELD_COMPLETE: 28, CB_HEADER_VALUE_COMPLETE: 29, CB_CHUNK_EXTENSION_NAME_COMPLETE: 34, CB_CHUNK_EXTENSION_VALUE_COMPLETE: 35, CB_RESET: 31 };
      d.TYPE = { BOTH: 0, REQUEST: 1, RESPONSE: 2 };
      d.FLAGS = { CONNECTION_KEEP_ALIVE: 1, CONNECTION_CLOSE: 2, CONNECTION_UPGRADE: 4, CHUNKED: 8, UPGRADE: 16, CONTENT_LENGTH: 32, SKIPBODY: 64, TRAILING: 128, TRANSFER_ENCODING: 512 };
      d.LENIENT_FLAGS = { HEADERS: 1, CHUNKED_LENGTH: 2, KEEP_ALIVE: 4, TRANSFER_ENCODING: 8, VERSION: 16, DATA_AFTER_CLOSE: 32, OPTIONAL_LF_AFTER_CR: 64, OPTIONAL_CRLF_AFTER_CHUNK: 128, OPTIONAL_CR_BEFORE_LF: 256, SPACES_AFTER_CHUNK_SIZE: 512 };
      d.METHODS = { DELETE: 0, GET: 1, HEAD: 2, POST: 3, PUT: 4, CONNECT: 5, OPTIONS: 6, TRACE: 7, COPY: 8, LOCK: 9, MKCOL: 10, MOVE: 11, PROPFIND: 12, PROPPATCH: 13, SEARCH: 14, UNLOCK: 15, BIND: 16, REBIND: 17, UNBIND: 18, ACL: 19, REPORT: 20, MKACTIVITY: 21, CHECKOUT: 22, MERGE: 23, "M-SEARCH": 24, NOTIFY: 25, SUBSCRIBE: 26, UNSUBSCRIBE: 27, PATCH: 28, PURGE: 29, MKCALENDAR: 30, LINK: 31, UNLINK: 32, SOURCE: 33, PRI: 34, DESCRIBE: 35, ANNOUNCE: 36, SETUP: 37, PLAY: 38, PAUSE: 39, TEARDOWN: 40, GET_PARAMETER: 41, SET_PARAMETER: 42, REDIRECT: 43, RECORD: 44, FLUSH: 45, QUERY: 46 };
      d.STATUSES = { CONTINUE: 100, SWITCHING_PROTOCOLS: 101, PROCESSING: 102, EARLY_HINTS: 103, RESPONSE_IS_STALE: 110, REVALIDATION_FAILED: 111, DISCONNECTED_OPERATION: 112, HEURISTIC_EXPIRATION: 113, MISCELLANEOUS_WARNING: 199, OK: 200, CREATED: 201, ACCEPTED: 202, NON_AUTHORITATIVE_INFORMATION: 203, NO_CONTENT: 204, RESET_CONTENT: 205, PARTIAL_CONTENT: 206, MULTI_STATUS: 207, ALREADY_REPORTED: 208, TRANSFORMATION_APPLIED: 214, IM_USED: 226, MISCELLANEOUS_PERSISTENT_WARNING: 299, MULTIPLE_CHOICES: 300, MOVED_PERMANENTLY: 301, FOUND: 302, SEE_OTHER: 303, NOT_MODIFIED: 304, USE_PROXY: 305, SWITCH_PROXY: 306, TEMPORARY_REDIRECT: 307, PERMANENT_REDIRECT: 308, BAD_REQUEST: 400, UNAUTHORIZED: 401, PAYMENT_REQUIRED: 402, FORBIDDEN: 403, NOT_FOUND: 404, METHOD_NOT_ALLOWED: 405, NOT_ACCEPTABLE: 406, PROXY_AUTHENTICATION_REQUIRED: 407, REQUEST_TIMEOUT: 408, CONFLICT: 409, GONE: 410, LENGTH_REQUIRED: 411, PRECONDITION_FAILED: 412, PAYLOAD_TOO_LARGE: 413, URI_TOO_LONG: 414, UNSUPPORTED_MEDIA_TYPE: 415, RANGE_NOT_SATISFIABLE: 416, EXPECTATION_FAILED: 417, IM_A_TEAPOT: 418, PAGE_EXPIRED: 419, ENHANCE_YOUR_CALM: 420, MISDIRECTED_REQUEST: 421, UNPROCESSABLE_ENTITY: 422, LOCKED: 423, FAILED_DEPENDENCY: 424, TOO_EARLY: 425, UPGRADE_REQUIRED: 426, PRECONDITION_REQUIRED: 428, TOO_MANY_REQUESTS: 429, REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL: 430, REQUEST_HEADER_FIELDS_TOO_LARGE: 431, LOGIN_TIMEOUT: 440, NO_RESPONSE: 444, RETRY_WITH: 449, BLOCKED_BY_PARENTAL_CONTROL: 450, UNAVAILABLE_FOR_LEGAL_REASONS: 451, CLIENT_CLOSED_LOAD_BALANCED_REQUEST: 460, INVALID_X_FORWARDED_FOR: 463, REQUEST_HEADER_TOO_LARGE: 494, SSL_CERTIFICATE_ERROR: 495, SSL_CERTIFICATE_REQUIRED: 496, HTTP_REQUEST_SENT_TO_HTTPS_PORT: 497, INVALID_TOKEN: 498, CLIENT_CLOSED_REQUEST: 499, INTERNAL_SERVER_ERROR: 500, NOT_IMPLEMENTED: 501, BAD_GATEWAY: 502, SERVICE_UNAVAILABLE: 503, GATEWAY_TIMEOUT: 504, HTTP_VERSION_NOT_SUPPORTED: 505, VARIANT_ALSO_NEGOTIATES: 506, INSUFFICIENT_STORAGE: 507, LOOP_DETECTED: 508, BANDWIDTH_LIMIT_EXCEEDED: 509, NOT_EXTENDED: 510, NETWORK_AUTHENTICATION_REQUIRED: 511, WEB_SERVER_UNKNOWN_ERROR: 520, WEB_SERVER_IS_DOWN: 521, CONNECTION_TIMEOUT: 522, ORIGIN_IS_UNREACHABLE: 523, TIMEOUT_OCCURED: 524, SSL_HANDSHAKE_FAILED: 525, INVALID_SSL_CERTIFICATE: 526, RAILGUN_ERROR: 527, SITE_IS_OVERLOADED: 529, SITE_IS_FROZEN: 530, IDENTITY_PROVIDER_AUTHENTICATION_ERROR: 561, NETWORK_READ_TIMEOUT: 598, NETWORK_CONNECT_TIMEOUT: 599 };
      d.FINISH = { SAFE: 0, SAFE_WITH_CB: 1, UNSAFE: 2 };
      d.HEADER_STATE = { GENERAL: 0, CONNECTION: 1, CONTENT_LENGTH: 2, TRANSFER_ENCODING: 3, UPGRADE: 4, CONNECTION_KEEP_ALIVE: 5, CONNECTION_CLOSE: 6, CONNECTION_UPGRADE: 7, TRANSFER_ENCODING_CHUNKED: 8 };
      d.METHODS_HTTP = [d.METHODS.DELETE, d.METHODS.GET, d.METHODS.HEAD, d.METHODS.POST, d.METHODS.PUT, d.METHODS.CONNECT, d.METHODS.OPTIONS, d.METHODS.TRACE, d.METHODS.COPY, d.METHODS.LOCK, d.METHODS.MKCOL, d.METHODS.MOVE, d.METHODS.PROPFIND, d.METHODS.PROPPATCH, d.METHODS.SEARCH, d.METHODS.UNLOCK, d.METHODS.BIND, d.METHODS.REBIND, d.METHODS.UNBIND, d.METHODS.ACL, d.METHODS.REPORT, d.METHODS.MKACTIVITY, d.METHODS.CHECKOUT, d.METHODS.MERGE, d.METHODS["M-SEARCH"], d.METHODS.NOTIFY, d.METHODS.SUBSCRIBE, d.METHODS.UNSUBSCRIBE, d.METHODS.PATCH, d.METHODS.PURGE, d.METHODS.MKCALENDAR, d.METHODS.LINK, d.METHODS.UNLINK, d.METHODS.PRI, d.METHODS.SOURCE, d.METHODS.QUERY];
      d.METHODS_ICE = [d.METHODS.SOURCE];
      d.METHODS_RTSP = [d.METHODS.OPTIONS, d.METHODS.DESCRIBE, d.METHODS.ANNOUNCE, d.METHODS.SETUP, d.METHODS.PLAY, d.METHODS.PAUSE, d.METHODS.TEARDOWN, d.METHODS.GET_PARAMETER, d.METHODS.SET_PARAMETER, d.METHODS.REDIRECT, d.METHODS.RECORD, d.METHODS.FLUSH, d.METHODS.GET, d.METHODS.POST];
      d.METHOD_MAP = (0, oL.enumToMap)(d.METHODS);
      d.H_METHOD_MAP = Object.fromEntries(Object.entries(d.METHODS).filter(([t]) => t.startsWith("H")));
      d.STATUSES_HTTP = [d.STATUSES.CONTINUE, d.STATUSES.SWITCHING_PROTOCOLS, d.STATUSES.PROCESSING, d.STATUSES.EARLY_HINTS, d.STATUSES.RESPONSE_IS_STALE, d.STATUSES.REVALIDATION_FAILED, d.STATUSES.DISCONNECTED_OPERATION, d.STATUSES.HEURISTIC_EXPIRATION, d.STATUSES.MISCELLANEOUS_WARNING, d.STATUSES.OK, d.STATUSES.CREATED, d.STATUSES.ACCEPTED, d.STATUSES.NON_AUTHORITATIVE_INFORMATION, d.STATUSES.NO_CONTENT, d.STATUSES.RESET_CONTENT, d.STATUSES.PARTIAL_CONTENT, d.STATUSES.MULTI_STATUS, d.STATUSES.ALREADY_REPORTED, d.STATUSES.TRANSFORMATION_APPLIED, d.STATUSES.IM_USED, d.STATUSES.MISCELLANEOUS_PERSISTENT_WARNING, d.STATUSES.MULTIPLE_CHOICES, d.STATUSES.MOVED_PERMANENTLY, d.STATUSES.FOUND, d.STATUSES.SEE_OTHER, d.STATUSES.NOT_MODIFIED, d.STATUSES.USE_PROXY, d.STATUSES.SWITCH_PROXY, d.STATUSES.TEMPORARY_REDIRECT, d.STATUSES.PERMANENT_REDIRECT, d.STATUSES.BAD_REQUEST, d.STATUSES.UNAUTHORIZED, d.STATUSES.PAYMENT_REQUIRED, d.STATUSES.FORBIDDEN, d.STATUSES.NOT_FOUND, d.STATUSES.METHOD_NOT_ALLOWED, d.STATUSES.NOT_ACCEPTABLE, d.STATUSES.PROXY_AUTHENTICATION_REQUIRED, d.STATUSES.REQUEST_TIMEOUT, d.STATUSES.CONFLICT, d.STATUSES.GONE, d.STATUSES.LENGTH_REQUIRED, d.STATUSES.PRECONDITION_FAILED, d.STATUSES.PAYLOAD_TOO_LARGE, d.STATUSES.URI_TOO_LONG, d.STATUSES.UNSUPPORTED_MEDIA_TYPE, d.STATUSES.RANGE_NOT_SATISFIABLE, d.STATUSES.EXPECTATION_FAILED, d.STATUSES.IM_A_TEAPOT, d.STATUSES.PAGE_EXPIRED, d.STATUSES.ENHANCE_YOUR_CALM, d.STATUSES.MISDIRECTED_REQUEST, d.STATUSES.UNPROCESSABLE_ENTITY, d.STATUSES.LOCKED, d.STATUSES.FAILED_DEPENDENCY, d.STATUSES.TOO_EARLY, d.STATUSES.UPGRADE_REQUIRED, d.STATUSES.PRECONDITION_REQUIRED, d.STATUSES.TOO_MANY_REQUESTS, d.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL, d.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE, d.STATUSES.LOGIN_TIMEOUT, d.STATUSES.NO_RESPONSE, d.STATUSES.RETRY_WITH, d.STATUSES.BLOCKED_BY_PARENTAL_CONTROL, d.STATUSES.UNAVAILABLE_FOR_LEGAL_REASONS, d.STATUSES.CLIENT_CLOSED_LOAD_BALANCED_REQUEST, d.STATUSES.INVALID_X_FORWARDED_FOR, d.STATUSES.REQUEST_HEADER_TOO_LARGE, d.STATUSES.SSL_CERTIFICATE_ERROR, d.STATUSES.SSL_CERTIFICATE_REQUIRED, d.STATUSES.HTTP_REQUEST_SENT_TO_HTTPS_PORT, d.STATUSES.INVALID_TOKEN, d.STATUSES.CLIENT_CLOSED_REQUEST, d.STATUSES.INTERNAL_SERVER_ERROR, d.STATUSES.NOT_IMPLEMENTED, d.STATUSES.BAD_GATEWAY, d.STATUSES.SERVICE_UNAVAILABLE, d.STATUSES.GATEWAY_TIMEOUT, d.STATUSES.HTTP_VERSION_NOT_SUPPORTED, d.STATUSES.VARIANT_ALSO_NEGOTIATES, d.STATUSES.INSUFFICIENT_STORAGE, d.STATUSES.LOOP_DETECTED, d.STATUSES.BANDWIDTH_LIMIT_EXCEEDED, d.STATUSES.NOT_EXTENDED, d.STATUSES.NETWORK_AUTHENTICATION_REQUIRED, d.STATUSES.WEB_SERVER_UNKNOWN_ERROR, d.STATUSES.WEB_SERVER_IS_DOWN, d.STATUSES.CONNECTION_TIMEOUT, d.STATUSES.ORIGIN_IS_UNREACHABLE, d.STATUSES.TIMEOUT_OCCURED, d.STATUSES.SSL_HANDSHAKE_FAILED, d.STATUSES.INVALID_SSL_CERTIFICATE, d.STATUSES.RAILGUN_ERROR, d.STATUSES.SITE_IS_OVERLOADED, d.STATUSES.SITE_IS_FROZEN, d.STATUSES.IDENTITY_PROVIDER_AUTHENTICATION_ERROR, d.STATUSES.NETWORK_READ_TIMEOUT, d.STATUSES.NETWORK_CONNECT_TIMEOUT];
      d.ALPHA = [];
      for (let t = 65; t <= 90; t++) d.ALPHA.push(String.fromCharCode(t)), d.ALPHA.push(String.fromCharCode(t + 32));
      d.NUM_MAP = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9 };
      d.HEX_MAP = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
      d.NUM = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
      d.ALPHANUM = d.ALPHA.concat(d.NUM);
      d.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
      d.USERINFO_CHARS = d.ALPHANUM.concat(d.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
      d.URL_CHAR = ["!", '"', "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "@", "[", "\\", "]", "^", "_", "`", "{", "|", "}", "~"].concat(d.ALPHANUM);
      d.HEX = d.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
      d.TOKEN = ["!", "#", "$", "%", "&", "'", "*", "+", "-", ".", "^", "_", "`", "|", "~"].concat(d.ALPHANUM);
      d.HEADER_CHARS = ["	"];
      for (let t = 32; t <= 255; t++) t !== 127 && d.HEADER_CHARS.push(t);
      d.CONNECTION_TOKEN_CHARS = d.HEADER_CHARS.filter((t) => t !== 44);
      d.QUOTED_STRING = ["	", " "];
      for (let t = 33; t <= 255; t++) t !== 34 && t !== 92 && d.QUOTED_STRING.push(t);
      d.HTAB_SP_VCHAR_OBS_TEXT = ["	", " "];
      for (let t = 33; t <= 126; t++) d.HTAB_SP_VCHAR_OBS_TEXT.push(t);
      for (let t = 128; t <= 255; t++) d.HTAB_SP_VCHAR_OBS_TEXT.push(t);
      d.MAJOR = d.NUM_MAP;
      d.MINOR = d.MAJOR;
      d.SPECIAL_HEADERS = { connection: d.HEADER_STATE.CONNECTION, "content-length": d.HEADER_STATE.CONTENT_LENGTH, "proxy-connection": d.HEADER_STATE.CONNECTION, "transfer-encoding": d.HEADER_STATE.TRANSFER_ENCODING, upgrade: d.HEADER_STATE.UPGRADE };
    });
    var _g = C((YK, LB) => {
      "use strict";
      var { Buffer: aL } = require("node:buffer"), cL = "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzQzBQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEDAAADAAAABAUBcAESEgUDAQACBggBfwFBgNgECwfFBygGbWVtb3J5AgALX2luaXRpYWxpemUACBlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQACRhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUANgxsbGh0dHBfYWxsb2MACwZtYWxsb2MAOAtsbGh0dHBfZnJlZQAMBGZyZWUADA9sbGh0dHBfZ2V0X3R5cGUADRVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADhVsbGh0dHBfZ2V0X2h0dHBfbWlub3IADxFsbGh0dHBfZ2V0X21ldGhvZAAQFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAERJsbGh0dHBfZ2V0X3VwZ3JhZGUAEgxsbGh0dHBfcmVzZXQAEw5sbGh0dHBfZXhlY3V0ZQAUFGxsaHR0cF9zZXR0aW5nc19pbml0ABUNbGxodHRwX2ZpbmlzaAAWDGxsaHR0cF9wYXVzZQAXDWxsaHR0cF9yZXN1bWUAGBtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGRBsbGh0dHBfZ2V0X2Vycm5vABoXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AGxdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAcFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB0RbGxodHRwX2Vycm5vX25hbWUAHhJsbGh0dHBfbWV0aG9kX25hbWUAHxJsbGh0dHBfc3RhdHVzX25hbWUAIBpsbGh0dHBf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a0E+aiECCyABIAI2AhwgAUIANwIQIAJBAnRBsNYAaiEAAkBBhNQAKAIAIgNBASACdCIHcUUEQCAAIAE2AgBBhNQAIAMgB3I2AgAgASAANgIYIAEgATYCCCABIAE2AgwMAQsgBEEZIAJBAXZrQQAgAkEfRxt0IQIgACgCACEAAkADQCAAIgMoAgRBeHEgBEYNASACQR12IQAgAkEBdCECIAMgAEEEcWpBEGoiBygCACIADQALIAcgATYCACABIAM2AhggASABNgIMIAEgATYCCAwBCyADKAIIIgAgATYCDCADIAE2AgggAUEANgIYIAEgAzYCDCABIAA2AggLQaDUAEGg1AAoAgBBAWsiAEF/IAAbNgIACwsHACAALQAoCwcAIAAtACoLBwAgAC0AKwsHACAALQApCwcAIAAvATQLBwAgAC0AMAtAAQR/IAAoAhghASAALwEuIQIgAC0AKCEDIAAoAjghBCAAEDcgACAENgI4IAAgAzoAKCAAIAI7AS4gACABNgIYC8X4AQIHfwN+IAEgAmohBAJAIAAiAygCDCIADQAgAygCBARAIAMgATYCBAsjAEEQayIJJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJ/AkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDtQBAAECAwQFBgcICQoLDA0ODxARFBUWFxgZGhscHR4fICEjJCUnKCmIA4cDhQOEA/wC9QLuAusC6ALmAuMC4ALfAt0C2wLWAtUC1ALTAtICygLJAsgCxwLGAsUCxALDAr0CvAK6ArkCuAK3ArYCtQK0ArICsQKsAqoCqAKnAqYCpQKkAqMCogKhAqACnwKbApoCmQKYApcCkAKIAoQCgwKCAvkB9gH1AfQB8wHyAfEB8AHvAe0B6wHoAeMB4QHgAd8B3gHdAdwB2wHaAdkB2AHXAdYB1QHUAdIB0QHQAc8BzgHNAcwBywHKAckByAHHAcYBxQHEAcMBwgHBAcABvwG+Ab0BvAG7AboBuQG4AbcBtgG1AbQBswGyAbEBsAGvAa4BrQGsAasBqgGpAagBpwGmAaUBpAGjAaIBoQGgAZ8BngGdAZwBmwGaAZcBlgGRAZABjwGOAY0BjAGLAYoBiQGIAYUBhAGDAX59fHt6d3Z1LFFSU1RVVgsgASAERw1zQewBIQIMqQMLIAEgBEcNkAFB0QEhAgyoAwsgASAERw3pAUGEASECDKcDCyABIARHDfQBQfoAIQIMpgMLIAEgBEcNggJB9QAhAgylAwsgASAERw2JAkHzACECDKQDCyABIARHDYwCQfEAIQIMowMLIAEgBEcNHkEeIQIMogMLIAEgBEcNGUEYIQIMoQMLIAEgBEcNuAJBzQAhAgygAwsgASAERw3DAkHGACECDJ8DCyABIARHDcQCQcMAIQIMngMLIAEgBEcNygJBOCECDJ0DCyADLQAwQQFGDZUDDPICC0EAIQACQAJAAkAgAy0AKkUNACADLQArRQ0AIAMvATIiAkECcUUNAQwCCyADLwEyIgJBAXFFDQELQQEhACADLQAoQQFGDQAgAy8BNCIGQeQAa0HkAEkNACAGQcwBRg0AIAZBsAJGDQAgAkHAAHENAEEAIQAgAkGIBHFBgARGDQAgAkEocUEARyEACyADQQA7ATIgA0EAOgAxAkAgAEUEQCADQQA6ADEgAy0ALkEEcQ0BDJwDCyADQgA3AyALIANBADoAMSADQQE6ADYMSQtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAEUNSSAAQRVHDWMgA0EENgIcIAMgATYCFCADQb0aNgIQIANBFTYCDEEAIQIMmgMLIAEgBEYEQEEGIQIMmgMLIAEtAABBCkYNGQwBCyABIARGBEBBByECDJkDCwJAIAEtAABBCmsOBAIBAQABCyABQQFqIQFBECECDP4CCyADLQAuQYABcQ0YQQAhAiADQQA2AhwgAyABNgIUIANBqR82AhAgA0ECNgIMDJcDCyABQQFqIQEgA0Evai0AAEEBcQ0XQQAhAiADQQA2AhwgAyABNgIUIANBhB82AhAgA0EZNgIMDJYDCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMWg0ZQQghAgyVAwsgASAERwRAIANBCTYCCCADIAE2AgRBEiECDPsCC0EJIQIMlAMLIAMpAyBQDZwCDEQLIAEgBEYEQEELIQIMkwMLIAEtAABBCkcNFyABQQFqIQEMGAsgA0Evai0AAEEBcUUNGgwnC0EAIQACQCADKAI4IgJFDQAgAigCSCICRQ0AIAMgAhEAACEACyAADRoMQwtBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0bDCULQQAhAAJAIAMoAjgiAkUNACACKAJIIgJFDQAgAyACEQAAIQALIAANHAwzCyADQS9qLQAAQQFxRQ0dDCMLQQAhAAJAIAMoAjgiAkUNACACKAJMIgJFDQAgAyACEQAAIQALIAANHQxDC0EAIQACQCADKAI4IgJFDQAgAigCTCICRQ0AIAMgAhEAACEACyAADR4MIQsgASAERgRAQRMhAgyLAwsCQCABLQAAIgBBCmsOBCAkJAAjCyABQQFqIQEMIAtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0jDEMLIAEgBEYEQEEWIQIMiQMLIAEtAABB8D9qLQAAQQFHDSQM7QILAkADQCABLQAAQeA5ai0AACIAQQFHBEACQCAAQQJrDgIDACgLIAFBAWohAUEfIQIM8AILIAQgAUEBaiIBRw0AC0EYIQIMiAMLIAMoAgQhAEEAIQIgA0EANgIEIAMgACABQQFqIgEQMyIADSIMQgtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0kDCsLIAEgBEYEQEEcIQIMhgMLIANBCjYCCCADIAE2AgRBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0mQSIhAgzrAgsgASAERwRAA0AgAS0AAEHgO2otAAAiAEEDRwRAIABBAWsOBRkbJ+wCJicLIAQgAUEBaiIBRw0AC0EbIQIMhQMLQRshAgyEAwsDQCABLQAAQeA9ai0AACIAQQNHBEAgAEEBaw4FEBIoFCcoCyAEIAFBAWoiAUcNAAtBHiECDIMDCyABIARHBEAgA0ELNgIIIAMgATYCBEEHIQIM6QILQR8hAgyCAwsgASAERgRAQSAhAgyCAwsCQCABLQAAQQ1rDhQvQEBAQEBAQEBAQEBAQEBAQEBAAEALQQAhAiADQQA2AhwgA0G3CzYCECADQQI2AgwgAyABQQFqNgIUDIEDCyADQS9qIQIDQCABIARGBEBBISECDIIDCwJAAkACQCABLQAAIgBBCWsOGAIAKioBKioqKioqKioqKioqKioqKioqAigLIAFBAWohASADQS9qLQAAQQFxRQ0LDBkLIAFBAWohAQwYCyABQQFqIQEgAi0AAEECcQ0AC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAyAAwsgAUEBaiEBC0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAADQEM0QILIANCADcDIAw8CyAAQRVGBEAgA0EkNgIcIAMgATYCFCADQYYaNgIQIANBFTYCDEEAIQIM/QILQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDPwCCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDSsgA0EHNgIcIAMgATYCFCADIAA2AgwM+wILIAMtAC5BwABxRQ0BC0EAIQACQCADKAI4IgJFDQAgAigCUCICRQ0AIAMgAhEAACEACyAARQ0rIABBFUYEQCADQQo2AhwgAyABNgIUIANB8Rg2AhAgA0EVNgIMQQAhAgz6AgtBACECIANBADYCHCADIAE2AhQgA0GLDDYCECADQRM2AgwM+QILQQAhAiADQQA2AhwgAyABNgIUIANBsRQ2AhAgA0ECNgIMDPgCC0EAIQIgA0EANgIcIAMgATYCFCADQYwUNgIQIANBGTYCDAz3AgtBACECIANBADYCHCADIAE2AhQgA0HRHDYCECADQRk2AgwM9gILIABBFUYNPUEAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAz1AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQ0oIANBDTYCHCADIAE2AhQgAyAANgIMDPQCCyAAQRVGDTpBACECIANBADYCHCADIAE2AhQgA0GiDzYCECADQSI2AgwM8wILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDIiAEUEQCABQQFqIQEMKAsgA0EONgIcIAMgADYCDCADIAFBAWo2AhQM8gILIABBFUYNN0EAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAzxAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQRAIAFBAWohAQwnCyADQQ82AhwgAyAANgIMIAMgAUEBajYCFAzwAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM7wILIABBFUYNM0EAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzuAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMyIARQ0lIANBETYCHCADIAE2AhQgAyAANgIMDO0CCyAAQRVGDTBBACECIANBADYCHCADIAE2AhQgA0HODDYCECADQSM2AgwM7AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEMJQsgA0ESNgIcIAMgADYCDCADIAFBAWo2AhQM6wILIANBL2otAABBAXFFDQELQRUhAgzPAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM6AILIABBO0cNACABQQFqIQEMDAtBACECIANBADYCHCADIAE2AhQgA0GYFzYCECADQQI2AgwM5gILIABBFUYNKEEAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzlAgsgA0EUNgIcIAMgATYCFCADIAA2AgwM5AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEM3AILIANBFTYCHCADIAA2AgwgAyABQQFqNgIUDOMCCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNoCCyADQRc2AhwgAyAANgIMIAMgAUEBajYCFAziAgsgAEEVRg0jQQAhAiADQQA2AhwgAyABNgIUIANBzgw2AhAgA0EjNgIMDOECCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDB0LIANBGTYCHCADIAA2AgwgAyABQQFqNgIUDOACCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNYCCyADQRo2AhwgAyAANgIMIAMgAUEBajYCFAzfAgsgAEEVRg0fQQAhAiADQQA2AhwgAyABNgIUIANBog82AhAgA0EiNgIMDN4CCyADKAIEIQBBACEC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DLMCCyABIARGBEBB6QEhAgyzAgsgAS0AAEHIAEYNASADQQE6ACgLQbYBIQIMlwILQcoBIQIMlgILIAEgBEcEQCADQQw2AgggAyABNgIEQckBIQIMlgILQegBIQIMrwILIAEgBEYEQEHnASECDK8CCyABLQAAQcgARw0EIAFBAWohAUHIASECDJQCCyABIARGBEBB5gEhAgyuAgsCQAJAIAEtAABBxQBrDhAABQUFBQUFBQUFBQUFBQUBBQsgAUEBaiEBQcYBIQIMlAILIAFBAWohAUHHASECDJMCC0HlASECIAEgBEYNrAIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB99MAai0AAEcNAyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMrQILIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgBFBEBB1AEhAgyTAgsgA0HkATYCHCADIAE2AhQgAyAANgIMQQAhAgysAgtB4wEhAiABIARGDasCIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQfXTAGotAABHDQIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADKwCCyADQYEEOwEoIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgANAwwCCyADQQA2AgALQQAhAiADQQA2AhwgAyABNgIUIANB0B42AhAgA0EINgIMDKkCC0HFASECDI4CCyADQeIBNgIcIAMgATYCFCADIAA2AgxBACECDKcCC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ1lIABBFUcEQCADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgynAgsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDKYCC0HhASECIAQgASIARg2lAiAEIAFrIAMoAgAiAWohBSAAIAFrQQRqIQYCQANAIAAtAAAgAUHw0wBqLQAARw0BIAFBBEYNAyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBTYCAAymAgsgA0EANgIcIAMgADYCFCADQYQ3NgIQIANBCDYCDCADQQA2AgBBACECDKUCCyABIARHBEAgA0ENNgIIIAMgATYCBEHCASECDIsCC0HgASECDKQCCyADQQA2AgAgBkEBaiEBC0HDASECDIgCCyABIARGBEBB3wEhAgyiAgsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFBwQEhAgyIAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYgCIANB3gE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAEgBEYEQEHdASECDKECCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYkCIANB3AE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILQcABIQIMhgILIAEgBEYEQEHbASECDKACC0EAIQBBASEFQQEhB0EAIQICQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQCABLQAAQTBrDgoKCQABAgMEBQYICwtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshAkEAIQVBACEHDAILQQkhAkEBIQBBACEFQQAhBwwBC0EAIQVBASECCyADIAI6ACsgAUEBaiEBAkACQCADLQAuQRBxDQACQAJAAkAgAy0AKg4DAQACBAsgB0UNAwwCCyAADQEMAgsgBUUNAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDQIgA0HYATYCHCADIAE2AhQgAyAANgIMQQAhAgyiAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYsCIANB2QE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ2JAiADQdoBNgIcIAMgATYCFCADIAA2AgwMoAILQb8BIQIMhQILQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANBnA02AhAgA0EhNgIMQQAhAgygAgtBvgEhAgyFAgsgA0HXATYCHCADIAE2AhQgA0HWGTYCECADQRU2AgxBACECDJ4CCyABIARGBEBB1wEhAgyeAgsCQCABLQAAQSBGBEAgA0EAOwE0IAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANB6xA2AhAgA0EJNgIMQQAhAgyeAgtBvQEhAgyDAgsgASAERgRAQdYBIQIM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LgsgAUEBaiEBQZcBIQIM2AELIAFBAWohAUEiDCsLIAEgBEYEQEGvASECDPEBCyABLQAAQdAARw0rIAFBAWohAUGWASECDNYBCyABIARGBEBBrgEhAgzwAQsCQAJAIAEtAABBxgBrDgsALCwsLCwsLCwsASwLIAFBAWohAUGUASECDNYBCyABQQFqIQFBlQEhAgzVAQtBrQEhAiABIARGDe4BIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQazTAGotAABHDSggAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO8BCyADQQA2AgAgBkEBaiEBQQ0MKAtBrAEhAiABIARGDe0BIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQeHTAGotAABHDScgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO4BCyADQQA2AgAgBkEBaiEBQQwMJwtBqwEhAiABIARGDewBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQarTAGotAABHDSYgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO0BCyADQQA2AgAgBkEBaiEBQQMMJgtBqgEhAiABIARGDesBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQajTAGotAABHDSUgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADOwBCyADQQA2AgAgBkEBaiEBQSYMJQsgASAERgRAQakBIQIM6wELAkACQCABLQAAQdQAaw4CAAEnCyABQQFqIQFBjwEhAgzRAQsgAUEBaiEBQZABIQIM0AELQagBIQIgASAERg3pASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm0wBqLQAARw0jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzqAQsgA0EANgIAIAZBAWohAUEnDCMLQacBIQIgASAERg3oASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk0wBqLQAARw0iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzpAQsgA0EANgIAIAZBAWohAUEcDCILQaYBIQIgASAERg3nASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGe0wBqLQAARw0hIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzoAQsgA0EANgIAIAZBAWohAUEGDCELQaUBIQIgASAERg3mASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEGZ0wBqLQAARw0gIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAznAQsgA0EANgIAIAZBAWohAUEZDCALIAEgBEYEQEGkASECDOYBCwJAAkACQAJAIAEtAABBLWsOIwAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAEkJCQkJAIkJCQDJAsgAUEBaiEBQYQBIQIMzgELIAFBAWohAUGFASECDM0BCyABQQFqIQFBigEhAgzMAQsgAUEBaiEBQYsBIQIMywELQaMBIQIgASAERg3kASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGX0wBqLQAARw0eIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzlAQsgA0EANgIAIAZBAWohAUELDB4LIAEgBEYEQEGiASECDOQBCwJAAkAgAS0AAEHBAGsOAwAgASALIAFBAWohAUGGASECDMoBCyABQQFqIQFBiQEhAgzJAQsgASAERgRAQaEBIQIM4wELAkACQCABLQAAQcEAaw4PAB8fHx8fHx8fHx8fHx8BHwsgAUEBaiEBQYcBIQIMyQELIAFBAWohAUGIASECDMgBCyABIARGBEBBoAEhAgziAQsgAS0AAEHMAEcNHCABQQFqIQFBCgwbC0GfASECIAEgBEYN4AEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBkdMAai0AAEcNGiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4QELIANBADYCACAGQQFqIQFBHgwaC0GeASECIAEgBEYN3wEgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBitMAai0AAEcNGSAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4AELIANBADYCACAGQQFqIQFBFQwZC0GdASECIAEgBEYN3gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBh9MAai0AAEcNGCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3wELIANBADYCACAGQQFqIQFBFwwYC0GcASECIAEgBEYN3QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBgdMAai0AAEcNFyAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3gELIANBADYCACAGQQFqIQFBGAwXCyABIARGBEBBmwEhAgzdAQsCQAJAIAEtAABByQBrDgcAGRkZGRkBGQsgAUEBaiEBQYEBIQIMwwELIAFBAWohAUGCASECDMIBC0GaASECIAEgBEYN2wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5tMAai0AAEcNFSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3AELIANBADYCACAGQQFqIQFBCQwVC0GZASECIAEgBEYN2gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5NMAai0AAEcNFCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2wELIANBADYCACAGQQFqIQFBHwwUC0GYASECIAEgBEYN2QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB/tIAai0AAEcNEyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2gELIANBADYCACAGQQFqIQFBAgwTC0GXASECIAEgBEYN2AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGA0AgAS0AACAAQfzSAGotAABHDREgAEEBRg0CIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNgBCyABIARGBEBBlgEhAgzYAQtBASABLQAAQd8ARw0RGiABQQFqIQFB/QAhAgy9AQsgA0EANgIAIAZBAWohAUH+ACECDLwBC0GVASECIAEgBEYN1QEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNDyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1gELIANBADYCACAGQQFqIQFBKQwPC0GUASECIAEgBEYN1AEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB+NIAai0AAEcNDiAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1QELIANBADYCACAGQQFqIQFBLQwOCyABIARGBEBBkwEhAgzUAQsgAS0AAEHFAEcNDiABQQFqIQFB+gAhAgy5AQsgASAERgRAQZIBIQIM0wELAkACQCABLQAAQcwAaw4IAA8PDw8PDwEPCyABQQFqIQFB+AAhAgy5AQsgAUEBaiEBQfkAIQIMuAELQZEBIQIgASAERg3RASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHz0gBqLQAARw0LIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzSAQsgA0EANgIAIAZBAWohAUEjDAsLQZABIQIgASAERg3QASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHw0gBqLQAARw0KIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzRAQsgA0EANgIAIAZBAWohAUEADAoLIAEgBEYEQEGPASECDNABCwJAAkAgAS0AAEHIAGsOCAAMDAwMDAwBDAsgAUEBaiEBQfMAIQIMtgELIAFBAWohAUH2ACECDLUBCyABIARGBEBBjgEhAgzPAQsCQAJAIAEtAABBzgBrDgMACwELCyABQQFqIQFB9AAhAgy1AQsgAUEBaiEBQfUAIQIMtAELIAEgBEYEQEGNASECDM4BCyABLQAAQdkARw0IIAFBAWohAUEIDAcLQYwBIQIgASAERg3MASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHs0gBqLQAARw0GIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzNAQsgA0EANgIAIAZBAWohAUEFDAYLQYsBIQIgASAERg3LASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHm0gBqLQAARw0FIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzMAQsgA0EANgIAIAZBAWohAUEWDAULQYoBIQIgASAERg3KASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw0EIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzLAQsgA0EANgIAIAZBAWohAUEQDAQLIAEgBEYEQEGJASECDMoBCwJAAkAgAS0AAEHDAGsODAAGBgYGBgYGBgYGAQYLIAFBAWohAUHvACECDLABCyABQQFqIQFB8AAhAgyvAQtBiAEhAiABIARGDcgBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQeDSAGotAABHDQIgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMkBCyADQQA2AgAgBkEBaiEBQSQMAgsgA0EANgIADAILIAEgBEYEQEGHASECDMcBCyABLQAAQcwARw0BIAFBAWohAUETCzoAKSADKAIEIQAgA0EANgIEIAMgACABEC0iAA0CDAELQQAhAiADQQA2AhwgAyABNgIUIANB6R42AhAgA0EGNgIMDMQBC0HuACECDKkBCyADQYYBNgIcIAMgATYCFCADIAA2AgxBACECDMIBC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUYNASADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgzBAQtB7QAhAgymAQsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDL8BCyABIARGBEBBhQEhAgy/AQsCQCABLQAAQSBGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GGHjYCECADQQY2AgxBACECDL8BC0ECIQIMpAELA0AgAS0AAEEgRw0CIAQgAUEBaiIBRw0AC0GEASECDL0BCyABIARGBEBBgwEhAgy9AQsCQCABLQAAQQlrDgRAAABAAAtB6wAhAgyiAQsgAy0AKUEFRgRAQewAIQIMogELQeoAIQIMoQELIAEgBEYEQEGCASECDLsBCyADQQ82AgggAyABNgIEDAoLIAEgBEYEQEGBASECDLoBCwJAIAEtAABBCWsOBD0AAD0AC0HpACECDJ8BCyABIARHBEAgA0EPNgIIIAMgATYCBEHnACECDJ8BC0GAASECDLgBCwJAIAEgBEcEQANAIAEtAABB4M4Aai0AACIAQQNHBEACQCAAQQFrDgI/AAQLQeYAIQIMoQELIAQgAUEBaiIBRw0AC0H+ACECDLkBC0H+ACECDLgBCyADQQA2AhwgAyABNgIUIANBxh82AhAgA0EHNgIMQQAhAgy3AQsgASAERgRAQf8AIQIMtwELAkACQAJAIAEtAABB4NAAai0AAEEBaw4DPAIAAQtB6AAhAgyeAQsgA0EANgIcIAMgATYCFCADQYYSNgIQIANBBzYCDEEAIQIMtwELQeAAIQIMnAELIAEgBEcEQCABQQFqIQFB5QAhAgycAQtB/QAhAgy1AQsgBCABIgBGBEBB/AAhAgy1AQsgAC0AACIBQS9GBEAgAEEBaiEBQeQAIQIMmwELIAFBCWsiAkEXSw0BIAAhAUEBIAJ0QZuAgARxDTcMAQsgBCABIgBGBEBB+wAhAgy0AQsgAC0AAEEvRw0AIABBAWohAQwDC0EAIQIgA0EANgIcIAMgADYCFCADQcYfNgIQIANBBzYCDAyyAQsCQAJAAkACQAJAA0AgAS0AAEHgzABqLQAAIgBBBUcEQAJAAkAgAEEBaw4IPQUGBwgABAEIC0HhACECDJ8BCyABQQFqIQFB4wAhAgyeAQsgBCABQQFqIgFHDQALQfoAIQIMtgELIAFBAWoMFAsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgy0AQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyzAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyyAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMsQELIAEgBEYEQEH5ACECDLEBCwJAIAEtAABB4MwAai0AAEEBaw4INAQFBgAIAgMHCyABQQFqIQELQQMhAgyVAQsgAUEBagwNC0EAIQIgA0EANgIcIANBoxI2AhAgA0EHNgIMIAMgAUEBajYCFAytAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgysAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyrAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyqAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMqQELQeIAIQIMjgELIAEgBEYEQEH4ACECDKgBCyABQQFqDAILIAEgBEYEQEH3ACECDKcBCyABQQFqDAELIAEgBEYNASABQQFqCyEBQQQhAgyKAQtB9gAhAgyjAQsDQCABLQAAQeDKAGotAAAiAEECRwRAIABBAUcEQEHfACECDIsBCwwnCyAEIAFBAWoiAUcNAAtB9QAhAgyiAQsgASAERgRAQfQAIQIMogELAkAgAS0AAEEJaw43JQMGJQQGBgYGBgYGBgYGBgYGBgYGBgYFBgYCBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAAYLIAFBAWoLIQFBBSECDIYBCyABQQFqDAYLIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMngELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMnQELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB8AA2AhwgAyABNgIUIAMgADYCDEEAIQIMnAELIANBADYCHCADIAE2AhQgA0G8EzYCECADQQc2AgxBACECDJsBCwJAAkACQAJAA0AgAS0AAEHgyABqLQAAIgBBBUcEQAJAIABBAWsOBiQDBAUGAAYLQd4AIQIMhgELIAQgAUEBaiIBRw0AC0HzACECDJ4BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQdsANgIcIAMgATYCFCADIAA2AgxBACECDJ0BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDJwBCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQfAANgIcIAMgATYCFCADIAA2AgxBACECDJsBCyADQQA2AhwgAyABNgIUIANB3Ag2AhAgA0EHNgIMQQAhAgyaAQsgASAERg0BIAFBAWoLIQFBBiECDH4LQfIAIQIMlwELAkACQAJAAkADQCABLQAAQeDGAGotAAAiAEEFRwRAIABBAWsOBB8CAwQFCyAEIAFBAWoiAUcNAAtB8QAhAgyaAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgyZAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyYAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyXAQsgA0EANgIcIAMgATYCFCADQbQKNgIQIANBBzYCDEEAIQIMlgELQc4AIQIMewtB0AAhAgx6C0HdACECDHkLIAEgBEYEQEHwACECDJMBCwJAIAEtAABBCWsOBBYAABYACyABQQFqIQFB3AAhAgx4CyABIARGBEBB7wAhAgySAQsCQCABLQAAQQlrDgQVAAAVAAtBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUEQEHTASECDHgLIABBFUcEQCADQQA2AhwgAyABNgIUIANBwQ02AhAgA0EaNgIMQQAhAgySAQsgA0HuADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDJEBC0HtACECIAEgBEYNkAEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB18YAai0AAEcNBCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMkQELIANBADYCACAGQQFqIQEgAy0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACECIANBADYCHCADIAE2AhQgA0HlCTYCECADQQg2AgwMkAELQewAIQIgASAERg2PASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHUxgBqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyQAQsgA0EANgIAIAZBAWohASADLQApQSFGDQMgA0EANgIcIAMgATYCFCADQYkKNgIQIANBCDYCDEEAIQIMjwELQesAIQIgASAERg2OASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHQxgBqLQAARw0CIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyPAQsgA0EANgIAIAZBAWohASADLQApIgBBI0kNAiAAQS5GDQIgA0EANgIcIAMgATYCFCADQcEJNgIQIANBCDYCDEEAIQIMjgELIANBADYCAAtBACECIANBADYCHCADIAE2AhQgA0GENzYCECADQQg2AgwMjAELQdgAIQIMcQsgASAERwRAIANBDTYCCCADIAE2AgRB1wAhAgxxC0HqACECDIoBCyABIARGBEBB6QAhAgyKAQsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFB1gAhAgxwCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdCADQegANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyABIARGBEBB5wAhAgyJAQsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ11IANB5gA2AhwgAyABNgIUIAMgADYCDEEAIQIMiQELQdUAIQIMbgsgASAERgRAQeUAIQIMiAELQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNAiADQeIANgIcIAMgATYCFCADIAA2AgxBACECDIoBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdyADQeMANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdSADQeQANgIcIAMgATYCFCADIAA2AgwMiAELQdMAIQIMbQsgAy0AKUEiRg2AAUHSACECDGwLQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALIABFBEBB1AAhAgxsCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQZwNNgIQIANBITYCDEEAIQIMhgELIANB4QA2AhwgAyABNgIUIANB1hk2AhAgA0EVNgIMQQAhAgyFAQsgASAERgRAQeAAIQIMhQELAkACQAJAAkACQCABLQAAQQprDgQBBAQABAsgAUEBaiEBDAELIAFBAWohASADQS9qLQAAQQFxRQ0BC0HRACECDGwLIANBADYCHCADIAE2AhQgA0GIETYCECADQQk2AgxBACECDIUBCyADQQA2AhwgAyABNgIUIANBiBE2AhAgA0EJNgIMQQAhAgyEAQsgASAERgRAQd8AIQIMhAELIAEtAABBCkYEQCABQQFqIQEMCQsgAy0ALkHAAHENCCADQQA2AhwgAyABNgIUIANBiBE2AhAgA0ECNgIMQQAhAgyDAQsgASAERgRAQd0AIQIMgwELIAEtAAAiAkENRgRAIAFBAWohAUHPACECDGkLIAEhACACQQlrDgQFAQEFAQsgBCABIgBGBEBB3AAhAgyCAQsgAC0AAEEKRw0AIABBAWoMAgtBACECIANBADYCHCADIAA2AhQgA0G1LDYCECADQQc2AgwMgAELIAEgBEYEQEHbACECDIABCwJAIAEtAABBCWsOBAMAAAMACyABQQFqCyEBQc0AIQIMZAsgASAERgRAQdoAIQIMfgsgAS0AAEEJaw4EAAEBAAELQQAhAiADQQA2AhwgA0HsETYCECADQQc2AgwgAyABQQFqNgIUDHwLIANBgBI7ASpBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HZADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDHsLQcwAIQIMYAsgA0EANgIcIAMgATYCFCADQcENNgIQIANBGjYCDEEAIQIMeQsgASAERgRAQdkAIQIMeQsgAS0AAEEgRw06IAFBAWohASADLQAuQQFxDTogA0EANgIcIAMgATYCFCADQa0bNgIQIANBHjYCDEEAIQIMeAsgASAERgRAQdgAIQIMeAsCQAJAAkACQAJAIAEtAAAiAEEKaw4EAgMD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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQTBrDjcVFAABAgMEBQYHFhYWFhYWFggJCgsMDRYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWDg8QERITFgtCAiEKDBQLQgMhCgwTC0IEIQoMEgtCBSEKDBELQgYhCgwQC0IHIQoMDwtCCCEKDA4LQgkhCgwNC0IKIQoMDAtCCyEKDAsLQgwhCgwKC0INIQoMCQtCDiEKDAgLQg8hCgwHC0IKIQoMBgtCCyEKDAULQgwhCgwEC0INIQoMAwtCDiEKDAILQg8hCgwBC0IBIQoLIAFBAWohASADKQMgIgtC//////////8PWARAIAMgC0IEhiAKhDcDIAwCC0EAIQIgA0EANgIcIAMgATYCFCADQa0JNgIQIANBDDYCDAwfC0ElIQIMBAtBJiECDAMLIAMgAToALCADQQA2AgAgB0EBaiEBQQwhAgwCCyADQQA2AgAgBkEBaiEBQQohAgwBCyABQQFqIQFBCCECDAALAAtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMGAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMFwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMFgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMFQtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMFAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMEwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMEgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMEQtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMEAtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMDwtBACECIANBADYCHCADIAE2AhQgA0HIEjYCECADQQs2AgwMDgtBACECIANBADYCHCADIAE2AhQgA0GVCTYCECADQQs2AgwMDQtBACECIANBADYCHCADIAE2AhQgA0HpDzYCECADQQo2AgwMDAtBACECIANBADYCHCADIAE2AhQgA0GDEDYCECADQQo2AgwMCwtBACECIANBADYCHCADIAE2AhQgA0GmHDYCECADQQI2AgwMCgtBACECIANBADYCHCADIAE2AhQgA0HFFTYCECADQQI2AgwMCQtBACECIANBADYCHCADIAE2AhQgA0H/FzYCECADQQI2AgwMCAtBACECIANBADYCHCADIAE2AhQgA0HKFzYCECADQQI2AgwMBwsgA0ECNgIcIAMgATYCFCADQZQdNgIQIANBFjYCDEEAIQIMBgtB3gAhAiABIARGDQUgCUEIaiEHIAMoAgAhBQJAAkAgASAERwRAIAVBxsYAaiEIIAQgBWogAWshBiAFQX9zQQpqIgUgAWohAANAIAEtAAAgCC0AAEcEQEECIQgMAwsgBUUEQEEAIQggACEBDAMLIAVBAWshBSAIQQFqIQggBCABQQFqIgFHDQALIAYhBSAEIQELIAdBATYCACADIAU2AgAMAQsgA0EANgIAIAcgCDYCAAsgByABNgIEIAkoAgwhACAJKAIIDgMBBQIACwALIANBADYCHCADQa0dNgIQIANBFzYCDCADIABBAWo2AhRBACECDAMLIANBADYCHCADIAA2AhQgA0HCHTYCECADQQk2AgxBACECDAILIAEgBEYEQEEoIQIMAgsgA0EJNgIIIAMgATYCBEEnIQIMAQsgASAERgRAQQEhAgwBCwNAAkACQAJAIAEtAABBCmsOBAABAQABCyABQQFqIQEMAQsgAUEBaiEBIAMtAC5BIHENAEEAIQIgA0EANgIcIAMgATYCFCADQYwgNgIQIANBBTYCDAwCC0EBIQIgASAERw0ACwsgCUEQaiQAIAJFBEAgAygCDCEADAELIAMgAjYCHEEAIQAgAygCBCIBRQ0AIAMgASAEIAMoAggRAQAiAUUNACADIAQ2AhQgAyABNgIMIAEhAAsgAAu+AgECfyAAQQA6AAAgAEHcAGoiAUEBa0EAOgAAIABBADoAAiAAQQA6AAEgAUEDa0EAOgAAIAFBAmtBADoAACAAQQA6AAMgAUEEa0EAOgAAQQAgAGtBA3EiASAAaiIAQQA2AgBB3AAgAWtBfHEiAiAAaiIBQQRrQQA2AgACQCACQQlJDQAgAEEANgIIIABBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIAJBGUkNACAAQQA2AhggAEEANgIUIABBADYC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YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBFeHBlY3RlZCBMRiBhZnRlciBoZWFkZXJzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABUcmFuc2Zlci1FbmNvZGluZyBjYW4ndCBiZSBwcmVzZW50IHdpdGggQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBzaXplAEV4cGVjdGVkIExGIGFmdGVyIGNodW5rIHNpemUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBleHRlbnNpb24gdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIHF1b3RlZC1wYWlyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciByZXNwb25zZSBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIG5hbWUASW52YWxpZCBzdGF0dXMgY29kZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGRhdGEARXhwZWN0ZWQgTEYgYWZ0ZXIgY2h1bmsgZGF0YQBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AARGF0YSBhZnRlciBgQ29ubmVjdGlvbjogY2xvc2VgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBRVUVSWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAEV4cGVjdGVkIExGIGFmdGVyIENSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAUhUAABoVAAAPEgAA5BkAAJEVAAAJFAAALRkAAOQUAADpEQAAaRQAAKEUAAB2FQAAQxYAAF4SAACUFwAAFxYAAH0UAAB/FgAAQRcAALMTAADDFgAABBoAAL0YAADQGAAAoBMAANQZAACvFgAAaBYAAHAXAADZFgAA/BgAAP4RAABZFwAAlxYAABwXAAD2FgAAjRcAAAsSAAB/GwAALhEAALMQAABJEgAArRIAAPYYAABoEAAAYhUAABAVAABaFgAAShkAALUVAADBFQAAYBUAAFwZAABaGQAAUxkAABYVAACtEQAAQhAAALcQAABXGAAAvxUAAIkQAAAcGQAAGhkAALkVAABRGAAA3BMAAFsVAABZFQAA5hgAAGcVAAARGQAA7RgAAOcTAACuEAAAwhcAAAAUAACSEwAAhBMAAEASAAAmGQAArxUAAGIQAEHpOQsBAQBBgDoL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB6jsLBAEAAAIAQYE8C14DBAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAUAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEHqPQsEAQAAAgBBgT4LXgMAAwMDAwMAAAMDAAMDAAMDAwMDAwMDAwMABAAFAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAAMAQeA/Cw1sb3NlZWVwLWFsaXZlAEH5PwsBAQBBkMAAC+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnBAAsBAQBBkMIAC+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGhxAALXgEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAQYDGAAshZWN0aW9uZW50LWxlbmd0aG9ucm94eS1jb25uZWN0aW9uAEGwxgALK3JhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KU00NCg0KVFRQL0NFL1RTUC8AQenGAAsFAQIAAQMAQYDHAAtfBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQenIAAsFAQIAAQMAQYDJAAtfBAUFBgUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQenKAAsEAQAAAQBBgcsAC14CAgACAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAEHpzAALBQECAAEDAEGAzQALXwQFAAAFBQUFBQUFBQUFBQYFBQUFBQUFBQUFBQUABQAHCAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFAAUABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAAAAFAEHpzgALBQEBAAEBAEGAzwALAQEAQZrPAAtBAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQenQAAsFAQEAAQEAQYDRAAsBAQBBitEACwYCAAAAAAIAQaHRAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB4NIAC5oBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRVVFUllPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==", Wg;
      Object.defineProperty(LB, "exports", { get: () => Wg || (Wg = aL.from(cL, "base64")) });
    });
    var PB = C((GK, vB) => {
      "use strict";
      var { Buffer: lL } = require("node:buffer"), uL = "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzQzBQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEDAAADAAAABAUBcAESEgUDAQACBggBfwFBgNgECwfFBygGbWVtb3J5AgALX2luaXRpYWxpemUACBlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQACRhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUANgxsbGh0dHBfYWxsb2MACwZtYWxsb2MAOAtsbGh0dHBfZnJlZQAMBGZyZWUADA9sbGh0dHBfZ2V0X3R5cGUADRVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADhVsbGh0dHBfZ2V0X2h0dHBfbWlub3IADxFsbGh0dHBfZ2V0X21ldGhvZAAQFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAERJsbGh0dHBfZ2V0X3VwZ3JhZGUAEgxsbGh0dHBfcmVzZXQAEw5sbGh0dHBfZXhlY3V0ZQAUFGxsaHR0cF9zZXR0aW5nc19pbml0ABUNbGxodHRwX2ZpbmlzaAAWDGxsaHR0cF9wYXVzZQAXDWxsaHR0cF9yZXN1bWUAGBtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGRBsbGh0dHBfZ2V0X2Vycm5vABoXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AGxdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAcFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB0RbGxodHRwX2Vycm5vX25hbWUAHhJsbGh0dHBfbWV0aG9kX25hbWUAHxJsbGh0dHBfc3RhdHVzX25hbWUAIBpsbGh0dHBf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a0E+aiECCyABIAI2AhwgAUIANwIQIAJBAnRBsNYAaiEAAkBBhNQAKAIAIgNBASACdCIHcUUEQCAAIAE2AgBBhNQAIAMgB3I2AgAgASAANgIYIAEgATYCCCABIAE2AgwMAQsgBEEZIAJBAXZrQQAgAkEfRxt0IQIgACgCACEAAkADQCAAIgMoAgRBeHEgBEYNASACQR12IQAgAkEBdCECIAMgAEEEcWpBEGoiBygCACIADQALIAcgATYCACABIAM2AhggASABNgIMIAEgATYCCAwBCyADKAIIIgAgATYCDCADIAE2AgggAUEANgIYIAEgAzYCDCABIAA2AggLQaDUAEGg1AAoAgBBAWsiAEF/IAAbNgIACwsHACAALQAoCwcAIAAtACoLBwAgAC0AKwsHACAALQApCwcAIAAvATQLBwAgAC0AMAtAAQR/IAAoAhghASAALwEuIQIgAC0AKCEDIAAoAjghBCAAEDcgACAENgI4IAAgAzoAKCAAIAI7AS4gACABNgIYC8X4AQIHfwN+IAEgAmohBAJAIAAiAygCDCIADQAgAygCBARAIAMgATYCBAsjAEEQayIJJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJ/AkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDtQBAAECAwQFBgcICQoLDA0ODxARFBUWFxgZGhscHR4fICEjJCUnKCmIA4cDhQOEA/wC9QLuAusC6ALmAuMC4ALfAt0C2wLWAtUC1ALTAtICygLJAsgCxwLGAsUCxALDAr0CvAK6ArkCuAK3ArYCtQK0ArICsQKsAqoCqAKnAqYCpQKkAqMCogKhAqACnwKbApoCmQKYApcCkAKIAoQCgwKCAvkB9gH1AfQB8wHyAfEB8AHvAe0B6wHoAeMB4QHgAd8B3gHdAdwB2wHaAdkB2AHX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QEBAQEBAQEBAQEBAAEALQQAhAiADQQA2AhwgA0G3CzYCECADQQI2AgwgAyABQQFqNgIUDIEDCyADQS9qIQIDQCABIARGBEBBISECDIIDCwJAAkACQCABLQAAIgBBCWsOGAIAKioBKioqKioqKioqKioqKioqKioqAigLIAFBAWohASADQS9qLQAAQQFxRQ0LDBkLIAFBAWohAQwYCyABQQFqIQEgAi0AAEECcQ0AC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAyAAwsgAUEBaiEBC0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAADQEM0QILIANCADcDIAw8CyAAQRVGBEAgA0EkNgIcIAMgATYCFCADQYYaNgIQIANBFTYCDEEAIQIM/QILQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDPwCCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDSsgA0EHNgIcIAMgATYCFCADIAA2AgwM+wILIAMtAC5BwABxRQ0BC0EAIQACQCADKAI4IgJFDQAgAigCUCICRQ0AIAMgAhEAACEACyAARQ0rIABBFUYEQCADQQo2AhwgAyABNgIUIANB8Rg2AhAgA0EVNgIMQQAhAgz6AgtBACECIANBADYCHCADIAE2AhQgA0GLDDYCECADQRM2AgwM+QILQQAhAiADQQA2AhwgAyABNgIUIANBsRQ2AhAgA0ECNgIMDPgCC0EAIQIgA0EANgIcIAMgATYCFCADQYwUNgIQIANBGTYCDAz3AgtBACECIANBADYCHCADIAE2AhQgA0HRHDYCECADQRk2AgwM9gILIABBFUYNPUEAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAz1AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQ0oIANBDTYCHCADIAE2AhQgAyAANgIMDPQCCyAAQRVGDTpBACECIANBADYCHCADIAE2AhQgA0GiDzYCECADQSI2AgwM8wILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDIiAEUEQCABQQFqIQEMKAsgA0EONgIcIAMgADYCDCADIAFBAWo2AhQM8gILIABBFUYNN0EAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAzxAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQRAIAFBAWohAQwnCyADQQ82AhwgAyAANgIMIAMgAUEBajYCFAzwAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM7wILIABBFUYNM0EAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzuAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMyIARQ0lIANBETYCHCADIAE2AhQgAyAANgIMDO0CCyAAQRVGDTBBACECIANBADYCHCADIAE2AhQgA0HODDYCECADQSM2AgwM7AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEMJQsgA0ESNgIcIAMgADYCDCADIAFBAWo2AhQM6wILIANBL2otAABBAXFFDQELQRUhAgzPAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM6AILIABBO0cNACABQQFqIQEMDAtBACECIANBADYCHCADIAE2AhQgA0GYFzYCECADQQI2AgwM5gILIABBFUYNKEEAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzlAgsgA0EUNgIcIAMgATYCFCADIAA2AgwM5AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEM3AILIANBFTYCHCADIAA2AgwgAyABQQFqNgIUDOMCCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNoCCyADQRc2AhwgAyAANgIMIAMgAUEBajYCFAziAgsgAEEVRg0jQQAhAiADQQA2AhwgAyABNgIUIANBzgw2AhAgA0EjNgIMDOECCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDB0LIANBGTYCHCADIAA2AgwgAyABQQFqNgIUDOACCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNYCCyADQRo2AhwgAyAANgIMIAMgAUEBajYCFAzfAgsgAEEVRg0fQQAhAiADQQA2AhwgAyABNgIUIANBog82AhAgA0EiNgIMDN4CCyADKAIEIQBBACEC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DLMCCyABIARGBEBB6QEhAgyzAgsgAS0AAEHIAEYNASADQQE6ACgLQbYBIQIMlwILQcoBIQIMlgILIAEgBEcEQCADQQw2AgggAyABNgIEQckBIQIMlgILQegBIQIMrwILIAEgBEYEQEHnASECDK8CCyABLQAAQcgARw0EIAFBAWohAUHIASECDJQCCyABIARGBEBB5gEhAgyuAgsCQAJAIAEtAABBxQBrDhAABQUFBQUFBQUFBQUFBQUBBQsgAUEBaiEBQcYBIQIMlAILIAFBAWohAUHHASECDJMCC0HlASECIAEgBEYNrAIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB99MAai0AAEcNAyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMrQILIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgBFBEBB1AEhAgyTAgsgA0HkATYCHCADIAE2AhQgAyAANgIMQQAhAgysAgtB4wEhAiABIARGDasCIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQfXTAGotAABHDQIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADKwCCyADQYEEOwEoIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgANAwwCCyADQQA2AgALQQAhAiADQQA2AhwgAyABNgIUIANB0B42AhAgA0EINgIMDKkCC0HFASECDI4CCyADQeIBNgIcIAMgATYCFCADIAA2AgxBACECDKcCC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ1lIABBFUcEQCADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgynAgsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDKYCC0HhASECIAQgASIARg2lAiAEIAFrIAMoAgAiAWohBSAAIAFrQQRqIQYCQANAIAAtAAAgAUHw0wBqLQAARw0BIAFBBEYNAyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBTYCAAymAgsgA0EANgIcIAMgADYCFCADQYQ3NgIQIANBCDYCDCADQQA2AgBBACECDKUCCyABIARHBEAgA0ENNgIIIAMgATYCBEHCASECDIsCC0HgASECDKQCCyADQQA2AgAgBkEBaiEBC0HDASECDIgCCyABIARGBEBB3wEhAgyiAgsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFBwQEhAgyIAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYgCIANB3gE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAEgBEYEQEHdASECDKECCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYkCIANB3AE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILQcABIQIMhgILIAEgBEYEQEHbASECDKACC0EAIQBBASEFQQEhB0EAIQICQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQCABLQAAQTBrDgoKCQABAgMEBQYICwtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshAkEAIQVBACEHDAILQQkhAkEBIQBBACEFQQAhBwwBC0EAIQVBASECCyADIAI6ACsgAUEBaiEBAkACQCADLQAuQRBxDQACQAJAAkAgAy0AKg4DAQACBAsgB0UNAwwCCyAADQEMAgsgBUUNAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDQIgA0HYATYCHCADIAE2AhQgAyAANgIMQQAhAgyiAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYsCIANB2QE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ2JAiADQdoBNgIcIAMgATYCFCADIAA2AgwMoAILQb8BIQIMhQILQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANBnA02AhAgA0EhNgIMQQAhAgygAgtBvgEhAgyFAgsgA0HXATYCHCADIAE2AhQgA0HWGTYCECADQRU2AgxBACECDJ4CCyABIARGBEBB1wEhAgyeAgsCQCABLQAAQSBGBEAgA0EAOwE0IAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANB6xA2AhAgA0EJNgIMQQAhAgyeAgtBvQEhAgyDAgsgASAERgRAQdYBIQIM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LgsgAUEBaiEBQZcBIQIM2AELIAFBAWohAUEiDCsLIAEgBEYEQEGvASECDPEBCyABLQAAQdAARw0rIAFBAWohAUGWASECDNYBCyABIARGBEBBrgEhAgzwAQsCQAJAIAEtAABBxgBrDgsALCwsLCwsLCwsASwLIAFBAWohAUGUASECDNYBCyABQQFqIQFBlQEhAgzVAQtBrQEhAiABIARGDe4BIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQazTAGotAABHDSggAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO8BCyADQQA2AgAgBkEBaiEBQQ0MKAtBrAEhAiABIARGDe0BIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQeHTAGotAABHDScgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO4BCyADQQA2AgAgBkEBaiEBQQwMJwtBqwEhAiABIARGDewBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQarTAGotAABHDSYgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO0BCyADQQA2AgAgBkEBaiEBQQMMJgtBqgEhAiABIARGDesBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQajTAGotAABHDSUgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADOwBCyADQQA2AgAgBkEBaiEBQSYMJQsgASAERgRAQakBIQIM6wELAkACQCABLQAAQdQAaw4CAAEnCyABQQFqIQFBjwEhAgzRAQsgAUEBaiEBQZABIQIM0AELQagBIQIgASAERg3pASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm0wBqLQAARw0jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzqAQsgA0EANgIAIAZBAWohAUEnDCMLQacBIQIgASAERg3oASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk0wBqLQAARw0iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzpAQsgA0EANgIAIAZBAWohAUEcDCILQaYBIQIgASAERg3nASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGe0wBqLQAARw0hIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzoAQsgA0EANgIAIAZBAWohAUEGDCELQaUBIQIgASAERg3mASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEGZ0wBqLQAARw0gIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAznAQsgA0EANgIAIAZBAWohAUEZDCALIAEgBEYEQEGkASECDOYBCwJAAkACQAJAIAEtAABBLWsOIwAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAEkJCQkJAIkJCQDJAsgAUEBaiEBQYQBIQIMzgELIAFBAWohAUGFASECDM0BCyABQQFqIQFBigEhAgzMAQsgAUEBaiEBQYsBIQIMywELQaMBIQIgASAERg3kASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGX0wBqLQAARw0eIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzlAQsgA0EANgIAIAZBAWohAUELDB4LIAEgBEYEQEGiASECDOQBCwJAAkAgAS0AAEHBAGsOAwAgASALIAFBAWohAUGGASECDMoBCyABQQFqIQFBiQEhAgzJAQsgASAERgRAQaEBIQIM4wELAkACQCABLQAAQcEAaw4PAB8fHx8fHx8fHx8fHx8BHwsgAUEBaiEBQYcBIQIMyQELIAFBAWohAUGIASECDMgBCyABIARGBEBBoAEhAgziAQsgAS0AAEHMAEcNHCABQQFqIQFBCgwbC0GfASECIAEgBEYN4AEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBkdMAai0AAEcNGiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4QELIANBADYCACAGQQFqIQFBHgwaC0GeASECIAEgBEYN3wEgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBitMAai0AAEcNGSAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4AELIANBADYCACAGQQFqIQFBFQwZC0GdASECIAEgBEYN3gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBh9MAai0AAEcNGCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3wELIANBADYCACAGQQFqIQFBFwwYC0GcASECIAEgBEYN3QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBgdMAai0AAEcNFyAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3gELIANBADYCACAGQQFqIQFBGAwXCyABIARGBEBBmwEhAgzdAQsCQAJAIAEtAABByQBrDgcAGRkZGRkBGQsgAUEBaiEBQYEBIQIMwwELIAFBAWohAUGCASECDMIBC0GaASECIAEgBEYN2wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5tMAai0AAEcNFSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3AELIANBADYCACAGQQFqIQFBCQwVC0GZASECIAEgBEYN2gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5NMAai0AAEcNFCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2wELIANBADYCACAGQQFqIQFBHwwUC0GYASECIAEgBEYN2QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB/tIAai0AAEcNEyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2gELIANBADYCACAGQQFqIQFBAgwTC0GXASECIAEgBEYN2AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGA0AgAS0AACAAQfzSAGotAABHDREgAEEBRg0CIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNgBCyABIARGBEBBlgEhAgzYAQtBASABLQAAQd8ARw0RGiABQQFqIQFB/QAhAgy9AQsgA0EANgIAIAZBAWohAUH+ACECDLwBC0GVASECIAEgBEYN1QEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNDyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1gELIANBADYCACAGQQFqIQFBKQwPC0GUASECIAEgBEYN1AEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB+NIAai0AAEcNDiAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1QELIANBADYCACAGQQFqIQFBLQwOCyABIARGBEBBkwEhAgzUAQsgAS0AAEHFAEcNDiABQQFqIQFB+gAhAgy5AQsgASAERgRAQZIBIQIM0wELAkACQCABLQAAQcwAaw4IAA8PDw8PDwEPCyABQQFqIQFB+AAhAgy5AQsgAUEBaiEBQfkAIQIMuAELQZEBIQIgASAERg3RASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHz0gBqLQAARw0LIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzSAQsgA0EANgIAIAZBAWohAUEjDAsLQZABIQIgASAERg3QASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHw0gBqLQAARw0KIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzRAQsgA0EANgIAIAZBAWohAUEADAoLIAEgBEYEQEGPASECDNABCwJAAkAgAS0AAEHIAGsOCAAMDAwMDAwBDAsgAUEBaiEBQfMAIQIMtgELIAFBAWohAUH2ACECDLUBCyABIARGBEBBjgEhAgzPAQsCQAJAIAEtAABBzgBrDgMACwELCyABQQFqIQFB9AAhAgy1AQsgAUEBaiEBQfUAIQIMtAELIAEgBEYEQEGNASECDM4BCyABLQAAQdkARw0IIAFBAWohAUEIDAcLQYwBIQIgASAERg3MASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHs0gBqLQAARw0GIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzNAQsgA0EANgIAIAZBAWohAUEFDAYLQYsBIQIgASAERg3LASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHm0gBqLQAARw0FIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzMAQsgA0EANgIAIAZBAWohAUEWDAULQYoBIQIgASAERg3KASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw0EIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzLAQsgA0EANgIAIAZBAWohAUEQDAQLIAEgBEYEQEGJASECDMoBCwJAAkAgAS0AAEHDAGsODAAGBgYGBgYGBgYGAQYLIAFBAWohAUHvACECDLABCyABQQFqIQFB8AAhAgyvAQtBiAEhAiABIARGDcgBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQeDSAGotAABHDQIgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMkBCyADQQA2AgAgBkEBaiEBQSQMAgsgA0EANgIADAILIAEgBEYEQEGHASECDMcBCyABLQAAQcwARw0BIAFBAWohAUETCzoAKSADKAIEIQAgA0EANgIEIAMgACABEC0iAA0CDAELQQAhAiADQQA2AhwgAyABNgIUIANB6R42AhAgA0EGNgIMDMQBC0HuACECDKkBCyADQYYBNgIcIAMgATYCFCADIAA2AgxBACECDMIBC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUYNASADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgzBAQtB7QAhAgymAQsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDL8BCyABIARGBEBBhQEhAgy/AQsCQCABLQAAQSBGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GGHjYCECADQQY2AgxBACECDL8BC0ECIQIMpAELA0AgAS0AAEEgRw0CIAQgAUEBaiIBRw0AC0GEASECDL0BCyABIARGBEBBgwEhAgy9AQsCQCABLQAAQQlrDgRAAABAAAtB6wAhAgyiAQsgAy0AKUEFRgRAQewAIQIMogELQeoAIQIMoQELIAEgBEYEQEGCASECDLsBCyADQQ82AgggAyABNgIEDAoLIAEgBEYEQEGBASECDLoBCwJAIAEtAABBCWsOBD0AAD0AC0HpACECDJ8BCyABIARHBEAgA0EPNgIIIAMgATYCBEHnACECDJ8BC0GAASECDLgBCwJAIAEgBEcEQANAIAEtAABB4M4Aai0AACIAQQNHBEACQCAAQQFrDgI/AAQLQeYAIQIMoQELIAQgAUEBaiIBRw0AC0H+ACECDLkBC0H+ACECDLgBCyADQQA2AhwgAyABNgIUIANBxh82AhAgA0EHNgIMQQAhAgy3AQsgASAERgRAQf8AIQIMtwELAkACQAJAIAEtAABB4NAAai0AAEEBaw4DPAIAAQtB6AAhAgyeAQsgA0EANgIcIAMgATYCFCADQYYSNgIQIANBBzYCDEEAIQIMtwELQeAAIQIMnAELIAEgBEcEQCABQQFqIQFB5QAhAgycAQtB/QAhAgy1AQsgBCABIgBGBEBB/AAhAgy1AQsgAC0AACIBQS9GBEAgAEEBaiEBQeQAIQIMmwELIAFBCWsiAkEXSw0BIAAhAUEBIAJ0QZuAgARxDTcMAQsgBCABIgBGBEBB+wAhAgy0AQsgAC0AAEEvRw0AIABBAWohAQwDC0EAIQIgA0EANgIcIAMgADYCFCADQcYfNgIQIANBBzYCDAyyAQsCQAJAAkACQAJAA0AgAS0AAEHgzABqLQAAIgBBBUcEQAJAAkAgAEEBaw4IPQUGBwgABAEIC0HhACECDJ8BCyABQQFqIQFB4wAhAgyeAQsgBCABQQFqIgFHDQALQfoAIQIMtgELIAFBAWoMFAsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgy0AQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyzAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyyAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMsQELIAEgBEYEQEH5ACECDLEBCwJAIAEtAABB4MwAai0AAEEBaw4INAQFBgAIAgMHCyABQQFqIQELQQMhAgyVAQsgAUEBagwNC0EAIQIgA0EANgIcIANBoxI2AhAgA0EHNgIMIAMgAUEBajYCFAytAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgysAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyrAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyqAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMqQELQeIAIQIMjgELIAEgBEYEQEH4ACECDKgBCyABQQFqDAILIAEgBEYEQEH3ACECDKcBCyABQQFqDAELIAEgBEYNASABQQFqCyEBQQQhAgyKAQtB9gAhAgyjAQsDQCABLQAAQeDKAGotAAAiAEECRwRAIABBAUcEQEHfACECDIsBCwwnCyAEIAFBAWoiAUcNAAtB9QAhAgyiAQsgASAERgRAQfQAIQIMogELAkAgAS0AAEEJaw43JQMGJQQGBgYGBgYGBgYGBgYGBgYGBgYFBgYCBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAAYLIAFBAWoLIQFBBSECDIYBCyABQQFqDAYLIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMngELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMnQELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB8AA2AhwgAyABNgIUIAMgADYCDEEAIQIMnAELIANBADYCHCADIAE2AhQgA0G8EzYCECADQQc2AgxBACECDJsBCwJAAkACQAJAA0AgAS0AAEHgyABqLQAAIgBBBUcEQAJAIABBAWsOBiQDBAUGAAYLQd4AIQIMhgELIAQgAUEBaiIBRw0AC0HzACECDJ4BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQdsANgIcIAMgATYCFCADIAA2AgxBACECDJ0BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDJwBCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQfAANgIcIAMgATYCFCADIAA2AgxBACECDJsBCyADQQA2AhwgAyABNgIUIANB3Ag2AhAgA0EHNgIMQQAhAgyaAQsgASAERg0BIAFBAWoLIQFBBiECDH4LQfIAIQIMlwELAkACQAJAAkADQCABLQAAQeDGAGotAAAiAEEFRwRAIABBAWsOBB8CAwQFCyAEIAFBAWoiAUcNAAtB8QAhAgyaAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgyZAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyYAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyXAQsgA0EANgIcIAMgATYCFCADQbQKNgIQIANBBzYCDEEAIQIMlgELQc4AIQIMewtB0AAhAgx6C0HdACECDHkLIAEgBEYEQEHwACECDJMBCwJAIAEtAABBCWsOBBYAABYACyABQQFqIQFB3AAhAgx4CyABIARGBEBB7wAhAgySAQsCQCABLQAAQQlrDgQVAAAVAAtBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUEQEHTASECDHgLIABBFUcEQCADQQA2AhwgAyABNgIUIANBwQ02AhAgA0EaNgIMQQAhAgySAQsgA0HuADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDJEBC0HtACECIAEgBEYNkAEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB18YAai0AAEcNBCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMkQELIANBADYCACAGQQFqIQEgAy0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACECIANBADYCHCADIAE2AhQgA0HlCTYCECADQQg2AgwMkAELQewAIQIgASAERg2PASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHUxgBqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyQAQsgA0EANgIAIAZBAWohASADLQApQSFGDQMgA0EANgIcIAMgATYCFCADQYkKNgIQIANBCDYCDEEAIQIMjwELQesAIQIgASAERg2OASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHQxgBqLQAARw0CIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyPAQsgA0EANgIAIAZBAWohASADLQApIgBBI0kNAiAAQS5GDQIgA0EANgIcIAMgATYCFCADQcEJNgIQIANBCDYCDEEAIQIMjgELIANBADYCAAtBACECIANBADYCHCADIAE2AhQgA0GENzYCECADQQg2AgwMjAELQdgAIQIMcQsgASAERwRAIANBDTYCCCADIAE2AgRB1wAhAgxxC0HqACECDIoBCyABIARGBEBB6QAhAgyKAQsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFB1gAhAgxwCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdCADQegANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyABIARGBEBB5wAhAgyJAQsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ11IANB5gA2AhwgAyABNgIUIAMgADYCDEEAIQIMiQELQdUAIQIMbgsgASAERgRAQeUAIQIMiAELQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNAiADQeIANgIcIAMgATYCFCADIAA2AgxBACECDIoBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdyADQeMANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdSADQeQANgIcIAMgATYCFCADIAA2AgwMiAELQdMAIQIMbQsgAy0AKUEiRg2AAUHSACECDGwLQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALIABFBEBB1AAhAgxsCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQZwNNgIQIANBITYCDEEAIQIMhgELIANB4QA2AhwgAyABNgIUIANB1hk2AhAgA0EVNgIMQQAhAgyFAQsgASAERgRAQeAAIQIMhQELAkACQAJAAkACQCABLQAAQQprDgQBBAQABAsgAUEBaiEBDAELIAFBAWohASADQS9qLQAAQQFxRQ0BC0HRACECDGwLIANBADYCHCADIAE2AhQgA0GIETYCECADQQk2AgxBACECDIUBCyADQQA2AhwgAyABNgIUIANBiBE2AhAgA0EJNgIMQQAhAgyEAQsgASAERgRAQd8AIQIMhAELIAEtAABBCkYEQCABQQFqIQEMCQsgAy0ALkHAAHENCCADQQA2AhwgAyABNgIUIANBiBE2AhAgA0ECNgIMQQAhAgyDAQsgASAERgRAQd0AIQIMgwELIAEtAAAiAkENRgRAIAFBAWohAUHPACECDGkLIAEhACACQQlrDgQFAQEFAQsgBCABIgBGBEBB3AAhAgyCAQsgAC0AAEEKRw0AIABBAWoMAgtBACECIANBADYCHCADIAA2AhQgA0G1LDYCECADQQc2AgwMgAELIAEgBEYEQEHbACECDIABCwJAIAEtAABBCWsOBAMAAAMACyABQQFqCyEBQc0AIQIMZAsgASAERgRAQdoAIQIMfgsgAS0AAEEJaw4EAAEBAAELQQAhAiADQQA2AhwgA0HsETYCECADQQc2AgwgAyABQQFqNgIUDHwLIANBgBI7ASpBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HZADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDHsLQcwAIQIMYAsgA0EANgIcIAMgATYCFCADQcENNgIQIANBGjYCDEEAIQIMeQsgASAERgRAQdkAIQIMeQsgAS0AAEEgRw06IAFBAWohASADLQAuQQFxDTogA0EANgIcIAMgATYCFCADQa0bNgIQIANBHjYCDEEAIQIMeAsgASAERgRAQdgAIQIMeAsCQAJAAkACQAJAIAEtAAAiAEEKaw4EAgMD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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQTBrDjcVFAABAgMEBQYHFhYWFhYWFggJCgsMDRYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWDg8QERITFgtCAiEKDBQLQgMhCgwTC0IEIQoMEgtCBSEKDBELQgYhCgwQC0IHIQoMDwtCCCEKDA4LQgkhCgwNC0IKIQoMDAtCCyEKDAsLQgwhCgwKC0INIQoMCQtCDiEKDAgLQg8hCgwHC0IKIQoMBgtCCyEKDAULQgwhCgwEC0INIQoMAwtCDiEKDAILQg8hCgwBC0IBIQoLIAFBAWohASADKQMgIgtC//////////8PWARAIAMgC0IEhiAKhDcDIAwCC0EAIQIgA0EANgIcIAMgATYCFCADQa0JNgIQIANBDDYCDAwfC0ElIQIMBAtBJiECDAMLIAMgAToALCADQQA2AgAgB0EBaiEBQQwhAgwCCyADQQA2AgAgBkEBaiEBQQohAgwBCyABQQFqIQFBCCECDAALAAtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMGAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMFwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMFgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMFQtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMFAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMEwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMEgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMEQtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMEAtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMDwtBACECIANBADYCHCADIAE2AhQgA0HIEjYCECADQQs2AgwMDgtBACECIANBADYCHCADIAE2AhQgA0GVCTYCECADQQs2AgwMDQtBACECIANBADYCHCADIAE2AhQgA0HpDzYCECADQQo2AgwMDAtBACECIANBADYCHCADIAE2AhQgA0GDEDYCECADQQo2AgwMCwtBACECIANBADYCHCADIAE2AhQgA0GmHDYCECADQQI2AgwMCgtBACECIANBADYCHCADIAE2AhQgA0HFFTYCECADQQI2AgwMCQtBACECIANBADYCHCADIAE2AhQgA0H/FzYCECADQQI2AgwMCAtBACECIANBADYCHCADIAE2AhQgA0HKFzYCECADQQI2AgwMBwsgA0ECNgIcIAMgATYCFCADQZQdNgIQIANBFjYCDEEAIQIMBgtB3gAhAiABIARGDQUgCUEIaiEHIAMoAgAhBQJAAkAgASAERwRAIAVBxsYAaiEIIAQgBWogAWshBiAFQX9zQQpqIgUgAWohAANAIAEtAAAgCC0AAEcEQEECIQgMAwsgBUUEQEEAIQggACEBDAMLIAVBAWshBSAIQQFqIQggBCABQQFqIgFHDQALIAYhBSAEIQELIAdBATYCACADIAU2AgAMAQsgA0EANgIAIAcgCDYCAAsgByABNgIEIAkoAgwhACAJKAIIDgMBBQIACwALIANBADYCHCADQa0dNgIQIANBFzYCDCADIABBAWo2AhRBACECDAMLIANBADYCHCADIAA2AhQgA0HCHTYCECADQQk2AgxBACECDAILIAEgBEYEQEEoIQIMAgsgA0EJNgIIIAMgATYCBEEnIQIMAQsgASAERgRAQQEhAgwBCwNAAkACQAJAIAEtAABBCmsOBAABAQABCyABQQFqIQEMAQsgAUEBaiEBIAMtAC5BIHENAEEAIQIgA0EANgIcIAMgATYCFCADQYwgNgIQIANBBTYCDAwCC0EBIQIgASAERw0ACwsgCUEQaiQAIAJFBEAgAygCDCEADAELIAMgAjYCHEEAIQAgAygCBCIBRQ0AIAMgASAEIAMoAggRAQAiAUUNACADIAQ2AhQgAyABNgIMIAEhAAsgAAu+AgECfyAAQQA6AAAgAEHcAGoiAUEBa0EAOgAAIABBADoAAiAAQQA6AAEgAUEDa0EAOgAAIAFBAmtBADoAACAAQQA6AAMgAUEEa0EAOgAAQQAgAGtBA3EiASAAaiIAQQA2AgBB3AAgAWtBfHEiAiAAaiIBQQRrQQA2AgACQCACQQlJDQAgAEEANgIIIABBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIAJBGUkNACAAQQA2AhggAEEANgIUIABBADYC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U3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMARXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVycwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgAVHJhbnNmZXItRW5jb2RpbmcgY2FuJ3QgYmUgcHJlc2VudCB3aXRoIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgc2l6ZQBFeHBlY3RlZCBMRiBhZnRlciBjaHVuayBzaXplAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGhlYWRlciB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBxdW90ZWQtcGFpciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgcmVzcG9uc2UgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGV4dGVuc2lvbiBuYW1lAEludmFsaWQgc3RhdHVzIGNvZGUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBkYXRhAEV4cGVjdGVkIExGIGFmdGVyIGNodW5rIGRhdGEAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAERhdGEgYWZ0ZXIgYENvbm5lY3Rpb246IGNsb3NlYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAUVVFUlkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBFeHBlY3RlZCBMRiBhZnRlciBDUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAFIVAAAaFQAADxIAAOQZAACRFQAACRQAAC0ZAADkFAAA6REAAGkUAAChFAAAdhUAAEMWAABeEgAAlBcAABcWAAB9FAAAfxYAAEEXAACzEwAAwxYAAAQaAAC9GAAA0BgAAKATAADUGQAArxYAAGgWAABwFwAA2RYAAPwYAAD+EQAAWRcAAJcWAAAcFwAA9hYAAI0XAAALEgAAfxsAAC4RAACzEAAASRIAAK0SAAD2GAAAaBAAAGIVAAAQFQAAWhYAAEoZAAC1FQAAwRUAAGAVAABcGQAAWhkAAFMZAAAWFQAArREAAEIQAAC3EAAAVxgAAL8VAACJEAAAHBkAABoZAAC5FQAAURgAANwTAABbFQAAWRUAAOYYAABnFQAAERkAAO0YAADnEwAArhAAAMIXAAAAFAAAkhMAAIQTAABAEgAAJhkAAK8VAABiEABB6TkLAQEAQYA6C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAwEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQeo7CwQBAAACAEGBPAteAwQDAwMDAwAAAwMAAwMAAwMDAwMDAwMDAwAFAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMAAwBB6j0LBAEAAAIAQYE+C14DAAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAQABQAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEHgPwsNbG9zZWVlcC1hbGl2ZQBB+T8LAQEAQZDAAAvgAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5wQALAQEAQZDCAAvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBocQAC14BAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGAxgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBsMYACytyYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNClNNDQoNClRUUC9DRS9UU1AvAEHpxgALBQECAAEDAEGAxwALXwQFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAEHpyAALBQECAAEDAEGAyQALXwQFBQYFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAEHpygALBAEAAAEAQYHLAAteAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgBB6cwACwUBAgABAwBBgM0AC18EBQAABQUFBQUFBQUFBQUGBQUFBQUFBQUFBQUFAAUABwgFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUABQAFAAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAAAABQBB6c4ACwUBAQABAQBBgM8ACwEBAEGazwALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEHp0AALBQEBAAEBAEGA0QALAQEAQYrRAAsGAgAAAAACAEGh0QALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQeDSAAuaAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VVRVJZT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=", jg;
      Object.defineProperty(vB, "exports", { get: () => jg || (jg = lL.from(uL, "base64")) });
    });
    var ts = C((OK, WB) => {
      "use strict";
      var YB = ["GET", "HEAD", "POST"], gL = new Set(YB), EL = [101, 204, 205, 304], GB = [301, 302, 303, 307, 308], dL = new Set(GB), OB = ["1", "7", "9", "11", "13", "15", "17", "19", "20", "21", "22", "23", "25", "37", "42", "43", "53", "69", "77", "79", "87", "95", "101", "102", "103", "104", "109", "110", "111", "113", "115", "117", "119", "123", "135", "137", "139", "143", "161", "179", "389", "427", "465", "512", "513", "514", "515", "526", "530", "531", "532", "540", "548", "554", "556", "563", "587", "601", "636", "989", "990", "993", "995", "1719", "1720", "1723", "2049", "3659", "4045", "4190", "5060", "5061", "6000", "6566", "6665", "6666", "6667", "6668", "6669", "6679", "6697", "10080"], hL = new Set(OB), VB = ["no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url"], fL = ["", ...VB], QL = new Set(VB), CL = ["follow", "manual", "error"], HB = ["GET", "HEAD", "OPTIONS", "TRACE"], IL = new Set(HB), pL = ["navigate", "same-origin", "no-cors", "cors"], BL = ["omit", "same-origin", "include"], mL = ["default", "no-store", "reload", "no-cache", "force-cache", "only-if-cached"], yL = ["content-encoding", "content-language", "content-location", "content-type", "content-length"], wL = ["half"], qB = ["CONNECT", "TRACE", "TRACK"], DL = new Set(qB), JB = ["audio", "audioworklet", "font", "image", "manifest", "paintworklet", "script", "style", "track", "video", "xslt", ""], RL = new Set(JB);
      WB.exports = { subresource: JB, forbiddenMethods: qB, requestBodyHeader: yL, referrerPolicy: fL, requestRedirect: CL, requestMode: pL, requestCredentials: BL, requestCache: mL, redirectStatus: GB, corsSafeListedMethods: YB, nullBodyStatus: EL, safeMethods: HB, badPorts: OB, requestDuplex: wL, subresourceSet: RL, badPortsSet: hL, redirectStatusSet: dL, corsSafeListedMethodsSet: gL, safeMethodsSet: IL, forbiddenMethodsSet: DL, referrerPolicyTokens: QL };
    });
    var Xg = C((VK, _B) => {
      "use strict";
      var Zg = /* @__PURE__ */ Symbol.for("undici.globalOrigin.1");
      function SL() {
        return globalThis[Zg];
      }
      function bL(t) {
        if (t === void 0) {
          Object.defineProperty(globalThis, Zg, { value: void 0, writable: true, enumerable: false, configurable: false });
          return;
        }
        let e = new URL(t);
        if (e.protocol !== "http:" && e.protocol !== "https:") throw new TypeError(`Only http & https urls are allowed, received ${e.protocol}`);
        Object.defineProperty(globalThis, Zg, { value: e, writable: true, enumerable: false, configurable: false });
      }
      _B.exports = { getGlobalOrigin: SL, setGlobalOrigin: bL };
    });
    var tt = C((HK, em) => {
      "use strict";
      var Ha = require("node:assert"), NL = new TextEncoder(), rs = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/, FL = /[\u000A\u000D\u0009\u0020]/, TL = /[\u0009\u000A\u000C\u000D\u0020]/g, xL = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
      function UL(t) {
        Ha(t.protocol === "data:");
        let e = XB(t, true);
        e = e.slice(5);
        let r = { position: 0 }, n = RA(",", e, r), A = n.length;
        if (n = YL(n, true, true), r.position >= e.length) return "failure";
        r.position++;
        let i = e.slice(A + 1), s = KB(i);
        if (/;(\u0020){0,}base64$/i.test(n)) {
          let a = zB(s);
          if (s = ML(a), s === "failure") return "failure";
          n = n.slice(0, -6), n = n.replace(/(\u0020)+$/, ""), n = n.slice(0, -1);
        }
        n.startsWith(";") && (n = "text/plain" + n);
        let o = Kg(n);
        return o === "failure" && (o = Kg("text/plain;charset=US-ASCII")), { mimeType: o, body: s };
      }
      function XB(t, e = false) {
        if (!e) return t.href;
        let r = t.href, n = t.hash.length, A = n === 0 ? r : r.substring(0, r.length - n);
        return !n && r.endsWith("#") ? A.slice(0, -1) : A;
      }
      function qa(t, e, r) {
        let n = "";
        for (; r.position < e.length && t(e[r.position]); ) n += e[r.position], r.position++;
        return n;
      }
      function RA(t, e, r) {
        let n = e.indexOf(t, r.position), A = r.position;
        return n === -1 ? (r.position = e.length, e.slice(A)) : (r.position = n, e.slice(A, r.position));
      }
      function KB(t) {
        let e = NL.encode(t);
        return kL(e);
      }
      function jB(t) {
        return t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102;
      }
      function ZB(t) {
        return t >= 48 && t <= 57 ? t - 48 : (t & 223) - 55;
      }
      function kL(t) {
        let e = t.length, r = new Uint8Array(e), n = 0;
        for (let A = 0; A < e; ++A) {
          let i = t[A];
          i !== 37 ? r[n++] = i : i === 37 && !(jB(t[A + 1]) && jB(t[A + 2])) ? r[n++] = 37 : (r[n++] = ZB(t[A + 1]) << 4 | ZB(t[A + 2]), A += 2);
        }
        return e === n ? r : r.subarray(0, n);
      }
      function Kg(t) {
        t = Va(t, true, true);
        let e = { position: 0 }, r = RA("/", t, e);
        if (r.length === 0 || !rs.test(r) || e.position >= t.length) return "failure";
        e.position++;
        let n = RA(";", t, e);
        if (n = Va(n, false, true), n.length === 0 || !rs.test(n)) return "failure";
        let A = r.toLowerCase(), i = n.toLowerCase(), s = { type: A, subtype: i, parameters: /* @__PURE__ */ new Map(), essence: `${A}/${i}` };
        for (; e.position < t.length; ) {
          e.position++, qa((c) => FL.test(c), t, e);
          let o = qa((c) => c !== ";" && c !== "=", t, e);
          if (o = o.toLowerCase(), e.position < t.length) {
            if (t[e.position] === ";") continue;
            e.position++;
          }
          if (e.position >= t.length) break;
          let a = null;
          if (t[e.position] === '"') a = $B(t, e, true), RA(";", t, e);
          else if (a = RA(";", t, e), a = Va(a, false, true), a.length === 0) continue;
          o.length !== 0 && rs.test(o) && (a.length === 0 || xL.test(a)) && !s.parameters.has(o) && s.parameters.set(o, a);
        }
        return s;
      }
      function ML(t) {
        t = t.replace(TL, "");
        let e = t.length;
        if (e % 4 === 0 && t.charCodeAt(e - 1) === 61 && (--e, t.charCodeAt(e - 1) === 61 && --e), e % 4 === 1 || /[^+/0-9A-Za-z]/.test(t.length === e ? t : t.substring(0, e))) return "failure";
        let r = Buffer.from(t, "base64");
        return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
      }
      function $B(t, e, r = false) {
        let n = e.position, A = "";
        for (Ha(t[e.position] === '"'), e.position++; A += qa((s) => s !== '"' && s !== "\\", t, e), !(e.position >= t.length); ) {
          let i = t[e.position];
          if (e.position++, i === "\\") {
            if (e.position >= t.length) {
              A += "\\";
              break;
            }
            A += t[e.position], e.position++;
          } else {
            Ha(i === '"');
            break;
          }
        }
        return r ? A : t.slice(n, e.position);
      }
      function LL(t) {
        Ha(t !== "failure");
        let { parameters: e, essence: r } = t, n = r;
        for (let [A, i] of e.entries()) n += ";", n += A, n += "=", rs.test(i) || (i = i.replace(/(\\|")/g, "\\$1"), i = '"' + i, i += '"'), n += i;
        return n;
      }
      function vL(t) {
        return t === 13 || t === 10 || t === 9 || t === 32;
      }
      function Va(t, e = true, r = true) {
        return $g(t, e, r, vL);
      }
      function PL(t) {
        return t === 13 || t === 10 || t === 9 || t === 12 || t === 32;
      }
      function YL(t, e = true, r = true) {
        return $g(t, e, r, PL);
      }
      function $g(t, e, r, n) {
        let A = 0, i = t.length - 1;
        if (e) for (; A < t.length && n(t.charCodeAt(A)); ) A++;
        if (r) for (; i > 0 && n(t.charCodeAt(i)); ) i--;
        return A === 0 && i === t.length - 1 ? t : t.slice(A, i + 1);
      }
      function zB(t) {
        let e = t.length;
        if (65535 > e) return String.fromCharCode.apply(null, t);
        let r = "", n = 0, A = 65535;
        for (; n < e; ) n + A > e && (A = e - n), r += String.fromCharCode.apply(null, t.subarray(n, n += A));
        return r;
      }
      function GL(t) {
        switch (t.essence) {
          case "application/ecmascript":
          case "application/javascript":
          case "application/x-ecmascript":
          case "application/x-javascript":
          case "text/ecmascript":
          case "text/javascript":
          case "text/javascript1.0":
          case "text/javascript1.1":
          case "text/javascript1.2":
          case "text/javascript1.3":
          case "text/javascript1.4":
          case "text/javascript1.5":
          case "text/jscript":
          case "text/livescript":
          case "text/x-ecmascript":
          case "text/x-javascript":
            return "text/javascript";
          case "application/json":
          case "text/json":
            return "application/json";
          case "image/svg+xml":
            return "image/svg+xml";
          case "text/xml":
          case "application/xml":
            return "application/xml";
        }
        return t.subtype.endsWith("+json") ? "application/json" : t.subtype.endsWith("+xml") ? "application/xml" : "";
      }
      em.exports = { dataURLProcessor: UL, URLSerializer: XB, collectASequenceOfCodePoints: qa, collectASequenceOfCodePointsFast: RA, stringPercentDecode: KB, parseMIMEType: Kg, collectAnHTTPQuotedString: $B, serializeAMimeType: LL, removeChars: $g, removeHTTPWhitespace: Va, minimizeSupportedMimeType: GL, HTTP_TOKEN_CODEPOINTS: rs, isomorphicDecode: zB };
    });
    var Te = C((qK, rm) => {
      "use strict";
      var { types: dn, inspect: OL } = require("node:util"), { markAsUncloneable: VL } = require("node:worker_threads"), { toUSVString: HL } = Y(), zg = 1, eE = 2, Ja = 3, Wa = 4, tE = 5, rE = 6, nE = 7, Vt = 8, tm = Function.call.bind(Function.prototype[Symbol.hasInstance]), m = { converters: {}, util: {}, errors: {}, is: {} };
      m.errors.exception = function(t) {
        return new TypeError(`${t.header}: ${t.message}`);
      };
      m.errors.conversionFailed = function(t) {
        let e = t.types.length === 1 ? "" : " one of", r = `${t.argument} could not be converted to${e}: ${t.types.join(", ")}.`;
        return m.errors.exception({ header: t.prefix, message: r });
      };
      m.errors.invalidArgument = function(t) {
        return m.errors.exception({ header: t.prefix, message: `"${t.value}" is an invalid ${t.type}.` });
      };
      m.brandCheck = function(t, e) {
        if (!tm(e, t)) {
          let r = new TypeError("Illegal invocation");
          throw r.code = "ERR_INVALID_THIS", r;
        }
      };
      m.brandCheckMultiple = function(t) {
        let e = t.map((r) => m.util.MakeTypeAssertion(r));
        return (r) => {
          if (e.every((n) => !n(r))) {
            let n = new TypeError("Illegal invocation");
            throw n.code = "ERR_INVALID_THIS", n;
          }
        };
      };
      m.argumentLengthCheck = function({ length: t }, e, r) {
        if (t < e) throw m.errors.exception({ message: `${e} argument${e !== 1 ? "s" : ""} required, but${t ? " only" : ""} ${t} found.`, header: r });
      };
      m.illegalConstructor = function() {
        throw m.errors.exception({ header: "TypeError", message: "Illegal constructor" });
      };
      m.util.MakeTypeAssertion = function(t) {
        return (e) => tm(t, e);
      };
      m.util.Type = function(t) {
        switch (typeof t) {
          case "undefined":
            return zg;
          case "boolean":
            return eE;
          case "string":
            return Ja;
          case "symbol":
            return Wa;
          case "number":
            return tE;
          case "bigint":
            return rE;
          case "function":
          case "object":
            return t === null ? nE : Vt;
        }
      };
      m.util.Types = { UNDEFINED: zg, BOOLEAN: eE, STRING: Ja, SYMBOL: Wa, NUMBER: tE, BIGINT: rE, NULL: nE, OBJECT: Vt };
      m.util.TypeValueToString = function(t) {
        switch (m.util.Type(t)) {
          case zg:
            return "Undefined";
          case eE:
            return "Boolean";
          case Ja:
            return "String";
          case Wa:
            return "Symbol";
          case tE:
            return "Number";
          case rE:
            return "BigInt";
          case nE:
            return "Null";
          case Vt:
            return "Object";
        }
      };
      m.util.markAsUncloneable = VL || (() => {
      });
      m.util.ConvertToInt = function(t, e, r, n) {
        let A, i;
        e === 64 ? (A = Math.pow(2, 53) - 1, r === "unsigned" ? i = 0 : i = Math.pow(-2, 53) + 1) : r === "unsigned" ? (i = 0, A = Math.pow(2, e) - 1) : (i = Math.pow(-2, e) - 1, A = Math.pow(2, e - 1) - 1);
        let s = Number(t);
        if (s === 0 && (s = 0), n?.enforceRange === true) {
          if (Number.isNaN(s) || s === Number.POSITIVE_INFINITY || s === Number.NEGATIVE_INFINITY) throw m.errors.exception({ header: "Integer conversion", message: `Could not convert ${m.util.Stringify(t)} to an integer.` });
          if (s = m.util.IntegerPart(s), s < i || s > A) throw m.errors.exception({ header: "Integer conversion", message: `Value must be between ${i}-${A}, got ${s}.` });
          return s;
        }
        return !Number.isNaN(s) && n?.clamp === true ? (s = Math.min(Math.max(s, i), A), Math.floor(s) % 2 === 0 ? s = Math.floor(s) : s = Math.ceil(s), s) : Number.isNaN(s) || s === 0 && Object.is(0, s) || s === Number.POSITIVE_INFINITY || s === Number.NEGATIVE_INFINITY ? 0 : (s = m.util.IntegerPart(s), s = s % Math.pow(2, e), r === "signed" && s >= Math.pow(2, e) - 1 ? s - Math.pow(2, e) : s);
      };
      m.util.IntegerPart = function(t) {
        let e = Math.floor(Math.abs(t));
        return t < 0 ? -1 * e : e;
      };
      m.util.Stringify = function(t) {
        switch (m.util.Type(t)) {
          case Wa:
            return `Symbol(${t.description})`;
          case Vt:
            return OL(t);
          case Ja:
            return `"${t}"`;
          default:
            return `${t}`;
        }
      };
      m.sequenceConverter = function(t) {
        return (e, r, n, A) => {
          if (m.util.Type(e) !== Vt) throw m.errors.exception({ header: r, message: `${n} (${m.util.Stringify(e)}) is not iterable.` });
          let i = typeof A == "function" ? A() : e?.[Symbol.iterator]?.(), s = [], o = 0;
          if (i === void 0 || typeof i.next != "function") throw m.errors.exception({ header: r, message: `${n} is not iterable.` });
          for (; ; ) {
            let { done: a, value: c } = i.next();
            if (a) break;
            s.push(t(c, r, `${n}[${o++}]`));
          }
          return s;
        };
      };
      m.recordConverter = function(t, e) {
        return (r, n, A) => {
          if (m.util.Type(r) !== Vt) throw m.errors.exception({ header: n, message: `${A} ("${m.util.TypeValueToString(r)}") is not an Object.` });
          let i = {};
          if (!dn.isProxy(r)) {
            let o = [...Object.getOwnPropertyNames(r), ...Object.getOwnPropertySymbols(r)];
            for (let a of o) {
              let c = m.util.Stringify(a), l = t(a, n, `Key ${c} in ${A}`), u = e(r[a], n, `${A}[${c}]`);
              i[l] = u;
            }
            return i;
          }
          let s = Reflect.ownKeys(r);
          for (let o of s) if (Reflect.getOwnPropertyDescriptor(r, o)?.enumerable) {
            let c = t(o, n, A), l = e(r[o], n, A);
            i[c] = l;
          }
          return i;
        };
      };
      m.interfaceConverter = function(t, e) {
        return (r, n, A) => {
          if (!t(r)) throw m.errors.exception({ header: n, message: `Expected ${A} ("${m.util.Stringify(r)}") to be an instance of ${e}.` });
          return r;
        };
      };
      m.dictionaryConverter = function(t) {
        return (e, r, n) => {
          let A = {};
          if (e != null && m.util.Type(e) !== Vt) throw m.errors.exception({ header: r, message: `Expected ${e} to be one of: Null, Undefined, Object.` });
          for (let i of t) {
            let { key: s, defaultValue: o, required: a, converter: c } = i;
            if (a === true && (e == null || !Object.hasOwn(e, s))) throw m.errors.exception({ header: r, message: `Missing required key "${s}".` });
            let l = e?.[s], u = o !== void 0;
            if (u && l === void 0 && (l = o()), a || u || l !== void 0) {
              if (l = c(l, r, `${n}.${s}`), i.allowedValues && !i.allowedValues.includes(l)) throw m.errors.exception({ header: r, message: `${l} is not an accepted type. Expected one of ${i.allowedValues.join(", ")}.` });
              A[s] = l;
            }
          }
          return A;
        };
      };
      m.nullableConverter = function(t) {
        return (e, r, n) => e === null ? e : t(e, r, n);
      };
      m.is.ReadableStream = m.util.MakeTypeAssertion(ReadableStream);
      m.is.Blob = m.util.MakeTypeAssertion(Blob);
      m.is.URLSearchParams = m.util.MakeTypeAssertion(URLSearchParams);
      m.is.File = m.util.MakeTypeAssertion(globalThis.File ?? require("node:buffer").File);
      m.is.URL = m.util.MakeTypeAssertion(URL);
      m.is.AbortSignal = m.util.MakeTypeAssertion(AbortSignal);
      m.is.MessagePort = m.util.MakeTypeAssertion(MessagePort);
      m.converters.DOMString = function(t, e, r, n) {
        if (t === null && n?.legacyNullToEmptyString) return "";
        if (typeof t == "symbol") throw m.errors.exception({ header: e, message: `${r} is a symbol, which cannot be converted to a DOMString.` });
        return String(t);
      };
      m.converters.ByteString = function(t, e, r) {
        if (typeof t == "symbol") throw m.errors.exception({ header: e, message: `${r} is a symbol, which cannot be converted to a ByteString.` });
        let n = String(t);
        for (let A = 0; A < n.length; A++) if (n.charCodeAt(A) > 255) throw new TypeError(`Cannot convert argument to a ByteString because the character at index ${A} has a value of ${n.charCodeAt(A)} which is greater than 255.`);
        return n;
      };
      m.converters.USVString = HL;
      m.converters.boolean = function(t) {
        return !!t;
      };
      m.converters.any = function(t) {
        return t;
      };
      m.converters["long long"] = function(t, e, r) {
        return m.util.ConvertToInt(t, 64, "signed", void 0, e, r);
      };
      m.converters["unsigned long long"] = function(t, e, r) {
        return m.util.ConvertToInt(t, 64, "unsigned", void 0, e, r);
      };
      m.converters["unsigned long"] = function(t, e, r) {
        return m.util.ConvertToInt(t, 32, "unsigned", void 0, e, r);
      };
      m.converters["unsigned short"] = function(t, e, r, n) {
        return m.util.ConvertToInt(t, 16, "unsigned", n, e, r);
      };
      m.converters.ArrayBuffer = function(t, e, r, n) {
        if (m.util.Type(t) !== Vt || !dn.isAnyArrayBuffer(t)) throw m.errors.conversionFailed({ prefix: e, argument: `${r} ("${m.util.Stringify(t)}")`, types: ["ArrayBuffer"] });
        if (n?.allowShared === false && dn.isSharedArrayBuffer(t)) throw m.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
        if (t.resizable || t.growable) throw m.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
        return t;
      };
      m.converters.TypedArray = function(t, e, r, n, A) {
        if (m.util.Type(t) !== Vt || !dn.isTypedArray(t) || t.constructor.name !== e.name) throw m.errors.conversionFailed({ prefix: r, argument: `${n} ("${m.util.Stringify(t)}")`, types: [e.name] });
        if (A?.allowShared === false && dn.isSharedArrayBuffer(t.buffer)) throw m.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
        if (t.buffer.resizable || t.buffer.growable) throw m.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
        return t;
      };
      m.converters.DataView = function(t, e, r, n) {
        if (m.util.Type(t) !== Vt || !dn.isDataView(t)) throw m.errors.exception({ header: e, message: `${r} is not a DataView.` });
        if (n?.allowShared === false && dn.isSharedArrayBuffer(t.buffer)) throw m.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
        if (t.buffer.resizable || t.buffer.growable) throw m.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
        return t;
      };
      m.converters["sequence<ByteString>"] = m.sequenceConverter(m.converters.ByteString);
      m.converters["sequence<sequence<ByteString>>"] = m.sequenceConverter(m.converters["sequence<ByteString>"]);
      m.converters["record<ByteString, ByteString>"] = m.recordConverter(m.converters.ByteString, m.converters.ByteString);
      m.converters.Blob = m.interfaceConverter(m.is.Blob, "Blob");
      m.converters.AbortSignal = m.interfaceConverter(m.is.AbortSignal, "AbortSignal");
      rm.exports = { webidl: m };
    });
    var Ve = C((JK, Cm) => {
      "use strict";
      var { Transform: qL } = require("node:stream"), nm = require("node:zlib"), { redirectStatusSet: JL, referrerPolicyTokens: WL, badPortsSet: _L } = ts(), { getGlobalOrigin: Am } = Xg(), { collectASequenceOfCodePoints: hn, collectAnHTTPQuotedString: jL, removeChars: ZL, parseMIMEType: XL } = tt(), { performance: KL } = require("node:perf_hooks"), { ReadableStreamFrom: $L, isValidHTTPToken: im, normalizedMethodRecordsBase: zL } = Y(), Cn = require("node:assert"), { isUint8Array: ev } = require("node:util/types"), { webidl: Hr } = Te(), sm = [], ja;
      try {
        ja = require("node:crypto");
        let t = ["sha256", "sha384", "sha512"];
        sm = ja.getHashes().filter((e) => t.includes(e));
      } catch {
      }
      function om(t) {
        let e = t.urlList, r = e.length;
        return r === 0 ? null : e[r - 1].toString();
      }
      function tv(t, e) {
        if (!JL.has(t.status)) return null;
        let r = t.headersList.get("location", true);
        return r !== null && cm(r) && (am(r) || (r = rv(r)), r = new URL(r, om(t))), r && !r.hash && (r.hash = e), r;
      }
      function am(t) {
        for (let e = 0; e < t.length; ++e) {
          let r = t.charCodeAt(e);
          if (r > 126 || r < 32) return false;
        }
        return true;
      }
      function rv(t) {
        return Buffer.from(t, "binary").toString("utf8");
      }
      function Qn(t) {
        return t.urlList[t.urlList.length - 1];
      }
      function nv(t) {
        let e = Qn(t);
        return fm(e) && _L.has(e.port) ? "blocked" : "allowed";
      }
      function Av(t) {
        return t instanceof Error || t?.constructor?.name === "Error" || t?.constructor?.name === "DOMException";
      }
      function iv(t) {
        for (let e = 0; e < t.length; ++e) {
          let r = t.charCodeAt(e);
          if (!(r === 9 || r >= 32 && r <= 126 || r >= 128 && r <= 255)) return false;
        }
        return true;
      }
      var sv = im;
      function cm(t) {
        return (t[0] === "	" || t[0] === " " || t[t.length - 1] === "	" || t[t.length - 1] === " " || t.includes(`
`) || t.includes("\r") || t.includes("\0")) === false;
      }
      function ov(t) {
        let e = (t.headersList.get("referrer-policy", true) ?? "").split(","), r = "";
        if (e.length) for (let n = e.length; n !== 0; n--) {
          let A = e[n - 1].trim();
          if (WL.has(A)) {
            r = A;
            break;
          }
        }
        return r;
      }
      function av(t, e) {
        let r = ov(e);
        r !== "" && (t.referrerPolicy = r);
      }
      function cv() {
        return "allowed";
      }
      function lv() {
        return "success";
      }
      function uv() {
        return "success";
      }
      function gv(t) {
        let e = null;
        e = t.mode, t.headersList.set("sec-fetch-mode", e, true);
      }
      function Ev(t) {
        let e = t.origin;
        if (!(e === "client" || e === void 0)) {
          if (t.responseTainting === "cors" || t.mode === "websocket") t.headersList.append("origin", e, true);
          else if (t.method !== "GET" && t.method !== "HEAD") {
            switch (t.referrerPolicy) {
              case "no-referrer":
                e = null;
                break;
              case "no-referrer-when-downgrade":
              case "strict-origin":
              case "strict-origin-when-cross-origin":
                t.origin && iE(t.origin) && !iE(Qn(t)) && (e = null);
                break;
              case "same-origin":
                ns(t, Qn(t)) || (e = null);
                break;
              default:
            }
            t.headersList.append("origin", e, true);
          }
        }
      }
      function SA(t, e) {
        return t;
      }
      function dv(t, e, r) {
        return !t?.startTime || t.startTime < e ? { domainLookupStartTime: e, domainLookupEndTime: e, connectionStartTime: e, connectionEndTime: e, secureConnectionStartTime: e, ALPNNegotiatedProtocol: t?.ALPNNegotiatedProtocol } : { domainLookupStartTime: SA(t.domainLookupStartTime, r), domainLookupEndTime: SA(t.domainLookupEndTime, r), connectionStartTime: SA(t.connectionStartTime, r), connectionEndTime: SA(t.connectionEndTime, r), secureConnectionStartTime: SA(t.secureConnectionStartTime, r), ALPNNegotiatedProtocol: t.ALPNNegotiatedProtocol };
      }
      function hv(t) {
        return SA(KL.now(), t);
      }
      function fv(t) {
        return { startTime: t.startTime ?? 0, redirectStartTime: 0, redirectEndTime: 0, postRedirectStartTime: t.startTime ?? 0, finalServiceWorkerStartTime: 0, finalNetworkResponseStartTime: 0, finalNetworkRequestStartTime: 0, endTime: 0, encodedBodySize: 0, decodedBodySize: 0, finalConnectionTimingInfo: null };
      }
      function lm() {
        return { referrerPolicy: "strict-origin-when-cross-origin" };
      }
      function Qv(t) {
        return { referrerPolicy: t.referrerPolicy };
      }
      function Cv(t) {
        let e = t.referrerPolicy;
        Cn(e);
        let r = null;
        if (t.referrer === "client") {
          let i = Am();
          if (!i || i.origin === "null") return "no-referrer";
          r = new URL(i);
        } else Hr.is.URL(t.referrer) && (r = t.referrer);
        let n = AE(r), A = AE(r, true);
        switch (n.toString().length > 4096 && (n = A), e) {
          case "no-referrer":
            return "no-referrer";
          case "origin":
            return A ?? AE(r, true);
          case "unsafe-url":
            return n;
          case "strict-origin": {
            let i = Qn(t);
            return fn(n) && !fn(i) ? "no-referrer" : A;
          }
          case "strict-origin-when-cross-origin": {
            let i = Qn(t);
            return ns(n, i) ? n : fn(n) && !fn(i) ? "no-referrer" : A;
          }
          case "same-origin":
            return ns(t, n) ? n : "no-referrer";
          case "origin-when-cross-origin":
            return ns(t, n) ? n : A;
          case "no-referrer-when-downgrade": {
            let i = Qn(t);
            return fn(n) && !fn(i) ? "no-referrer" : A;
          }
        }
      }
      function AE(t, e = false) {
        return Cn(Hr.is.URL(t)), t = new URL(t), hm(t) ? "no-referrer" : (t.username = "", t.password = "", t.hash = "", e === true && (t.pathname = "", t.search = ""), t);
      }
      var Iv = new RegExp("^(?:(?:127\\.)(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){2}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9]))$"), pv = new RegExp("^(?:(?:(?:0{1,4}):){7}(?:(?:0{0,3}1))|(?:(?:0{1,4}):){1,6}(?::(?:0{0,3}1))|(?:::(?:0{0,3}1))|)$");
      function um(t) {
        return t.includes(":") ? (t[0] === "[" && t[t.length - 1] === "]" && (t = t.slice(1, -1)), pv.test(t)) : Iv.test(t);
      }
      function Bv(t) {
        return t == null || t === "null" ? false : (t = new URL(t), !!(t.protocol === "https:" || t.protocol === "wss:" || um(t.hostname) || t.hostname === "localhost" || t.hostname === "localhost." || t.hostname.endsWith(".localhost") || t.hostname.endsWith(".localhost.") || t.protocol === "file:"));
      }
      function fn(t) {
        return Hr.is.URL(t) ? t.href === "about:blank" || t.href === "about:srcdoc" || t.protocol === "data:" || t.protocol === "blob:" ? true : Bv(t.origin) : false;
      }
      function mv(t, e) {
        if (ja === void 0) return true;
        let r = gm(e);
        if (r === "no metadata" || r.length === 0) return true;
        let n = wv(r), A = Dv(r, n);
        for (let i of A) {
          let s = i.algo, o = i.hash, a = ja.createHash(s).update(t).digest("base64");
          if (a[a.length - 1] === "=" && (a[a.length - 2] === "=" ? a = a.slice(0, -2) : a = a.slice(0, -1)), Rv(a, o)) return true;
        }
        return false;
      }
      var yv = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
      function gm(t) {
        let e = [], r = true;
        for (let n of t.split(" ")) {
          r = false;
          let A = yv.exec(n);
          if (A === null || A.groups === void 0 || A.groups.algo === void 0) continue;
          let i = A.groups.algo.toLowerCase();
          sm.includes(i) && e.push(A.groups);
        }
        return r === true ? "no metadata" : e;
      }
      function wv(t) {
        let e = t[0].algo;
        if (e[3] === "5") return e;
        for (let r = 1; r < t.length; ++r) {
          let n = t[r];
          if (n.algo[3] === "5") {
            e = "sha512";
            break;
          } else {
            if (e[3] === "3") continue;
            n.algo[3] === "3" && (e = "sha384");
          }
        }
        return e;
      }
      function Dv(t, e) {
        if (t.length === 1) return t;
        let r = 0;
        for (let n = 0; n < t.length; ++n) t[n].algo === e && (t[r++] = t[n]);
        return t.length = r, t;
      }
      function Rv(t, e) {
        if (t.length !== e.length) return false;
        for (let r = 0; r < t.length; ++r) if (t[r] !== e[r]) {
          if (t[r] === "+" && e[r] === "-" || t[r] === "/" && e[r] === "_") continue;
          return false;
        }
        return true;
      }
      function Sv(t) {
      }
      function ns(t, e) {
        return t.origin === e.origin && t.origin === "null" || t.protocol === e.protocol && t.hostname === e.hostname && t.port === e.port;
      }
      function bv() {
        let t, e;
        return { promise: new Promise((n, A) => {
          t = n, e = A;
        }), resolve: t, reject: e };
      }
      function Nv(t) {
        return t.controller.state === "aborted";
      }
      function Fv(t) {
        return t.controller.state === "aborted" || t.controller.state === "terminated";
      }
      function Tv(t) {
        return zL[t.toLowerCase()] ?? t;
      }
      function xv(t) {
        let e = JSON.stringify(t);
        if (e === void 0) throw new TypeError("Value is not JSON serializable");
        return Cn(typeof e == "string"), e;
      }
      var Uv = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
      function Em(t, e, r = 0, n = 1) {
        class A {
          #e;
          #t;
          #r;
          constructor(s, o) {
            this.#e = s, this.#t = o, this.#r = 0;
          }
          next() {
            if (typeof this != "object" || this === null || !(#e in this)) throw new TypeError(`'next' called on an object that does not implement interface ${t} Iterator.`);
            let s = this.#r, o = e(this.#e), a = o.length;
            if (s >= a) return { value: void 0, done: true };
            let { [r]: c, [n]: l } = o[s];
            this.#r = s + 1;
            let u;
            switch (this.#t) {
              case "key":
                u = c;
                break;
              case "value":
                u = l;
                break;
              case "key+value":
                u = [c, l];
                break;
            }
            return { value: u, done: false };
          }
        }
        return delete A.prototype.constructor, Object.setPrototypeOf(A.prototype, Uv), Object.defineProperties(A.prototype, { [Symbol.toStringTag]: { writable: false, enumerable: false, configurable: true, value: `${t} Iterator` }, next: { writable: true, enumerable: true, configurable: true } }), function(i, s) {
          return new A(i, s);
        };
      }
      function kv(t, e, r, n = 0, A = 1) {
        let i = Em(t, r, n, A), s = { keys: { writable: true, enumerable: true, configurable: true, value: function() {
          return Hr.brandCheck(this, e), i(this, "key");
        } }, values: { writable: true, enumerable: true, configurable: true, value: function() {
          return Hr.brandCheck(this, e), i(this, "value");
        } }, entries: { writable: true, enumerable: true, configurable: true, value: function() {
          return Hr.brandCheck(this, e), i(this, "key+value");
        } }, forEach: { writable: true, enumerable: true, configurable: true, value: function(a, c = globalThis) {
          if (Hr.brandCheck(this, e), Hr.argumentLengthCheck(arguments, 1, `${t}.forEach`), typeof a != "function") throw new TypeError(`Failed to execute 'forEach' on '${t}': parameter 1 is not of type 'Function'.`);
          for (let { 0: l, 1: u } of i(this, "key+value")) a.call(c, u, l, this);
        } } };
        return Object.defineProperties(e.prototype, { ...s, [Symbol.iterator]: { writable: true, enumerable: false, configurable: true, value: s.entries.value } });
      }
      function Mv(t, e, r) {
        let n = e, A = r, i;
        try {
          i = t.stream.getReader();
        } catch (s) {
          A(s);
          return;
        }
        dm(i, n, A);
      }
      function Lv(t) {
        try {
          t.close(), t.byobRequest?.respond(0);
        } catch (e) {
          if (!e.message.includes("Controller is already closed") && !e.message.includes("ReadableStream is already closed")) throw e;
        }
      }
      var vv = /[^\x00-\xFF]/;
      function _a2(t) {
        return Cn(!vv.test(t)), t;
      }
      async function dm(t, e, r) {
        let n = [], A = 0;
        try {
          do {
            let { done: i, value: s } = await t.read();
            if (i) {
              e(Buffer.concat(n, A));
              return;
            }
            if (!ev(s)) {
              r(TypeError("Received non-Uint8Array chunk"));
              return;
            }
            n.push(s), A += s.length;
          } while (true);
        } catch (i) {
          r(i);
        }
      }
      function hm(t) {
        Cn("protocol" in t);
        let e = t.protocol;
        return e === "about:" || e === "blob:" || e === "data:";
      }
      function iE(t) {
        return typeof t == "string" && t[5] === ":" && t[0] === "h" && t[1] === "t" && t[2] === "t" && t[3] === "p" && t[4] === "s" || t.protocol === "https:";
      }
      function fm(t) {
        Cn("protocol" in t);
        let e = t.protocol;
        return e === "http:" || e === "https:";
      }
      function Pv(t, e) {
        let r = t;
        if (!r.startsWith("bytes")) return "failure";
        let n = { position: 5 };
        if (e && hn((a) => a === "	" || a === " ", r, n), r.charCodeAt(n.position) !== 61) return "failure";
        n.position++, e && hn((a) => a === "	" || a === " ", r, n);
        let A = hn((a) => {
          let c = a.charCodeAt(0);
          return c >= 48 && c <= 57;
        }, r, n), i = A.length ? Number(A) : null;
        if (e && hn((a) => a === "	" || a === " ", r, n), r.charCodeAt(n.position) !== 45) return "failure";
        n.position++, e && hn((a) => a === "	" || a === " ", r, n);
        let s = hn((a) => {
          let c = a.charCodeAt(0);
          return c >= 48 && c <= 57;
        }, r, n), o = s.length ? Number(s) : null;
        return n.position < r.length || o === null && i === null || i > o ? "failure" : { rangeStartValue: i, rangeEndValue: o };
      }
      function Yv(t, e, r) {
        let n = "bytes ";
        return n += _a2(`${t}`), n += "-", n += _a2(`${e}`), n += "/", n += _a2(`${r}`), n;
      }
      var sE = class extends qL {
        #e;
        constructor(e) {
          super(), this.#e = e;
        }
        _transform(e, r, n) {
          if (!this._inflateStream) {
            if (e.length === 0) {
              n();
              return;
            }
            this._inflateStream = (e[0] & 15) === 8 ? nm.createInflate(this.#e) : nm.createInflateRaw(this.#e), this._inflateStream.on("data", this.push.bind(this)), this._inflateStream.on("end", () => this.push(null)), this._inflateStream.on("error", (A) => this.destroy(A));
          }
          this._inflateStream.write(e, r, n);
        }
        _final(e) {
          this._inflateStream && (this._inflateStream.end(), this._inflateStream = null), e();
        }
      };
      function Gv(t) {
        return new sE(t);
      }
      function Ov(t) {
        let e = null, r = null, n = null, A = Qm("content-type", t);
        if (A === null) return "failure";
        for (let i of A) {
          let s = XL(i);
          s === "failure" || s.essence === "*/*" || (n = s, n.essence !== r ? (e = null, n.parameters.has("charset") && (e = n.parameters.get("charset")), r = n.essence) : !n.parameters.has("charset") && e !== null && n.parameters.set("charset", e));
        }
        return n ?? "failure";
      }
      function Vv(t) {
        let e = t, r = { position: 0 }, n = [], A = "";
        for (; r.position < e.length; ) {
          if (A += hn((i) => i !== '"' && i !== ",", e, r), r.position < e.length) if (e.charCodeAt(r.position) === 34) {
            if (A += jL(e, r), r.position < e.length) continue;
          } else Cn(e.charCodeAt(r.position) === 44), r.position++;
          A = ZL(A, true, true, (i) => i === 9 || i === 32), n.push(A), A = "";
        }
        return n;
      }
      function Qm(t, e) {
        let r = e.get(t, true);
        return r === null ? null : Vv(r);
      }
      var Hv = new TextDecoder();
      function qv(t) {
        return t.length === 0 ? "" : (t[0] === 239 && t[1] === 187 && t[2] === 191 && (t = t.subarray(3)), Hv.decode(t));
      }
      var oE = class {
        get baseUrl() {
          return Am();
        }
        get origin() {
          return this.baseUrl?.origin;
        }
        policyContainer = lm();
      }, aE = class {
        settingsObject = new oE();
      }, Jv = new aE();
      Cm.exports = { isAborted: Nv, isCancelled: Fv, isValidEncodedURL: am, createDeferredPromise: bv, ReadableStreamFrom: $L, tryUpgradeRequestToAPotentiallyTrustworthyURL: Sv, clampAndCoarsenConnectionTimingInfo: dv, coarsenedSharedCurrentTime: hv, determineRequestsReferrer: Cv, makePolicyContainer: lm, clonePolicyContainer: Qv, appendFetchMetadata: gv, appendRequestOriginHeader: Ev, TAOCheck: uv, corsCheck: lv, crossOriginResourcePolicyCheck: cv, createOpaqueTimingInfo: fv, setRequestReferrerPolicyOnRedirect: av, isValidHTTPToken: im, requestBadPort: nv, requestCurrentURL: Qn, responseURL: om, responseLocationURL: tv, isURLPotentiallyTrustworthy: fn, isValidReasonPhrase: iv, sameOrigin: ns, normalizeMethod: Tv, serializeJavascriptValueToJSONString: xv, iteratorMixin: kv, createIterator: Em, isValidHeaderName: sv, isValidHeaderValue: cm, isErrorLike: Av, fullyReadBody: Mv, bytesMatch: mv, readableStreamClose: Lv, isomorphicEncode: _a2, urlIsLocal: hm, urlHasHttpsScheme: iE, urlIsHttpHttpsScheme: fm, readAllBytes: dm, simpleRangeHeaderValue: Pv, buildContentRange: Yv, parseMetadata: gm, createInflate: Gv, extractMimeType: Ov, getDecodeSplit: Qm, utf8DecodeBytes: qv, environmentSettingsObject: Jv, isOriginIPPotentiallyTrustworthy: um };
    });
    var Za = C((WK, Bm) => {
      "use strict";
      var { iteratorMixin: Wv } = Ve(), { kEnumerableProperty: bA } = Y(), { webidl: X } = Te(), { File: _v } = require("node:buffer"), Im = require("node:util"), pm = globalThis.File ?? _v, dr = class t {
        #e = [];
        constructor(e) {
          if (X.util.markAsUncloneable(this), e !== void 0) throw X.errors.conversionFailed({ prefix: "FormData constructor", argument: "Argument 1", types: ["undefined"] });
        }
        append(e, r, n = void 0) {
          X.brandCheck(this, t);
          let A = "FormData.append";
          X.argumentLengthCheck(arguments, 2, A), e = X.converters.USVString(e), arguments.length === 3 || X.is.Blob(r) ? (r = X.converters.Blob(r, A, "value"), n !== void 0 && (n = X.converters.USVString(n))) : r = X.converters.USVString(r);
          let i = cE(e, r, n);
          this.#e.push(i);
        }
        delete(e) {
          X.brandCheck(this, t), X.argumentLengthCheck(arguments, 1, "FormData.delete"), e = X.converters.USVString(e), this.#e = this.#e.filter((n) => n.name !== e);
        }
        get(e) {
          X.brandCheck(this, t), X.argumentLengthCheck(arguments, 1, "FormData.get"), e = X.converters.USVString(e);
          let n = this.#e.findIndex((A) => A.name === e);
          return n === -1 ? null : this.#e[n].value;
        }
        getAll(e) {
          return X.brandCheck(this, t), X.argumentLengthCheck(arguments, 1, "FormData.getAll"), e = X.converters.USVString(e), this.#e.filter((n) => n.name === e).map((n) => n.value);
        }
        has(e) {
          return X.brandCheck(this, t), X.argumentLengthCheck(arguments, 1, "FormData.has"), e = X.converters.USVString(e), this.#e.findIndex((n) => n.name === e) !== -1;
        }
        set(e, r, n = void 0) {
          X.brandCheck(this, t);
          let A = "FormData.set";
          X.argumentLengthCheck(arguments, 2, A), e = X.converters.USVString(e), arguments.length === 3 || X.is.Blob(r) ? (r = X.converters.Blob(r, A, "value"), n !== void 0 && (n = X.converters.USVString(n))) : r = X.converters.USVString(r);
          let i = cE(e, r, n), s = this.#e.findIndex((o) => o.name === e);
          s !== -1 ? this.#e = [...this.#e.slice(0, s), i, ...this.#e.slice(s + 1).filter((o) => o.name !== e)] : this.#e.push(i);
        }
        [Im.inspect.custom](e, r) {
          let n = this.#e.reduce((i, s) => (i[s.name] ? Array.isArray(i[s.name]) ? i[s.name].push(s.value) : i[s.name] = [i[s.name], s.value] : i[s.name] = s.value, i), { __proto__: null });
          r.depth ??= e, r.colors ??= true;
          let A = Im.formatWithOptions(r, n);
          return `FormData ${A.slice(A.indexOf("]") + 2)}`;
        }
        static getFormDataState(e) {
          return e.#e;
        }
        static setFormDataState(e, r) {
          e.#e = r;
        }
      }, { getFormDataState: jv, setFormDataState: Zv } = dr;
      Reflect.deleteProperty(dr, "getFormDataState");
      Reflect.deleteProperty(dr, "setFormDataState");
      Wv("FormData", dr, jv, "name", "value");
      Object.defineProperties(dr.prototype, { append: bA, delete: bA, get: bA, getAll: bA, has: bA, set: bA, [Symbol.toStringTag]: { value: "FormData", configurable: true } });
      function cE(t, e, r) {
        if (typeof e != "string") {
          if (X.is.File(e) || (e = new pm([e], "blob", { type: e.type })), r !== void 0) {
            let n = { type: e.type, lastModified: e.lastModified };
            e = new pm([e], r, n);
          }
        }
        return { name: t, value: e };
      }
      X.is.FormData = X.util.MakeTypeAssertion(dr);
      Bm.exports = { FormData: dr, makeEntry: cE, setFormDataState: Zv };
    });
    var Rm = C((_K, Dm) => {
      "use strict";
      var { isUSVString: mm, bufferToLowerCasedHeaderName: Xv } = Y(), { utf8DecodeBytes: Kv } = Ve(), { HTTP_TOKEN_CODEPOINTS: $v, isomorphicDecode: ym } = tt(), { makeEntry: zv } = Za(), { webidl: eP } = Te(), Xa = require("node:assert"), { File: tP } = require("node:buffer"), rP = globalThis.File ?? tP, nP = Buffer.from('form-data; name="'), AP = Buffer.from("filename"), iP = Buffer.from("--"), sP = Buffer.from(`--\r
`);
      function oP(t) {
        for (let e = 0; e < t.length; ++e) if ((t.charCodeAt(e) & -128) !== 0) return false;
        return true;
      }
      function aP(t) {
        let e = t.length;
        if (e < 27 || e > 70) return false;
        for (let r = 0; r < e; ++r) {
          let n = t.charCodeAt(r);
          if (!(n >= 48 && n <= 57 || n >= 65 && n <= 90 || n >= 97 && n <= 122 || n === 39 || n === 45 || n === 95)) return false;
        }
        return true;
      }
      function cP(t, e) {
        Xa(e !== "failure" && e.essence === "multipart/form-data");
        let r = e.parameters.get("boundary");
        if (r === void 0) throw Et("missing boundary in content-type header");
        let n = Buffer.from(`--${r}`, "utf8"), A = [], i = { position: 0 };
        for (; t[i.position] === 13 && t[i.position + 1] === 10; ) i.position += 2;
        let s = t.length;
        for (; t[s - 1] === 10 && t[s - 2] === 13; ) s -= 2;
        for (s !== t.length && (t = t.subarray(0, s)); ; ) {
          if (t.subarray(i.position, i.position + n.length).equals(n)) i.position += n.length;
          else throw Et("expected a value starting with -- and the boundary");
          if (i.position === t.length - 2 && Ka(t, iP, i) || i.position === t.length - 4 && Ka(t, sP, i)) return A;
          if (t[i.position] !== 13 || t[i.position + 1] !== 10) throw Et("expected CRLF");
          i.position += 2;
          let o = lP(t, i), { name: a, filename: c, contentType: l, encoding: u } = o;
          i.position += 2;
          let g;
          {
            let h = t.indexOf(n.subarray(2), i.position);
            if (h === -1) throw Et("expected boundary after body");
            g = t.subarray(i.position, h - 4), i.position += g.length, u === "base64" && (g = Buffer.from(g.toString(), "base64"));
          }
          if (t[i.position] !== 13 || t[i.position + 1] !== 10) throw Et("expected CRLF");
          i.position += 2;
          let E;
          c !== null ? (l ??= "text/plain", oP(l) || (l = ""), E = new rP([g], c, { type: l })) : E = Kv(Buffer.from(g)), Xa(mm(a)), Xa(typeof E == "string" && mm(E) || eP.is.File(E)), A.push(zv(a, E, c));
        }
      }
      function lP(t, e) {
        let r = null, n = null, A = null, i = null;
        for (; ; ) {
          if (t[e.position] === 13 && t[e.position + 1] === 10) {
            if (r === null) throw Et("header name is null");
            return { name: r, filename: n, contentType: A, encoding: i };
          }
          let s = hr((o) => o !== 10 && o !== 13 && o !== 58, t, e);
          if (s = lE(s, true, true, (o) => o === 9 || o === 32), !$v.test(s.toString())) throw Et("header name does not match the field-name token production");
          if (t[e.position] !== 58) throw Et("expected :");
          switch (e.position++, hr((o) => o === 32 || o === 9, t, e), Xv(s)) {
            case "content-disposition": {
              if (r = n = null, !Ka(t, nP, e)) throw Et('expected form-data; name=" for content-disposition header');
              if (e.position += 17, r = wm(t, e), t[e.position] === 59 && t[e.position + 1] === 32) {
                let o = { position: e.position + 2 };
                if (Ka(t, AP, o)) if (t[o.position + 8] === 42) {
                  o.position += 10, hr((c) => c === 32 || c === 9, t, o);
                  let a = hr((c) => c !== 32 && c !== 13 && c !== 10, t, o);
                  if (a[0] !== 117 && a[0] !== 85 || a[1] !== 116 && a[1] !== 84 || a[2] !== 102 && a[2] !== 70 || a[3] !== 45 || a[4] !== 56) throw Et("unknown encoding, expected utf-8''");
                  n = decodeURIComponent(new TextDecoder().decode(a.subarray(7))), e.position = o.position;
                } else e.position += 11, hr((a) => a === 32 || a === 9, t, e), e.position++, n = wm(t, e);
              }
              break;
            }
            case "content-type": {
              let o = hr((a) => a !== 10 && a !== 13, t, e);
              o = lE(o, false, true, (a) => a === 9 || a === 32), A = ym(o);
              break;
            }
            case "content-transfer-encoding": {
              let o = hr((a) => a !== 10 && a !== 13, t, e);
              o = lE(o, false, true, (a) => a === 9 || a === 32), i = ym(o);
              break;
            }
            default:
              hr((o) => o !== 10 && o !== 13, t, e);
          }
          if (t[e.position] !== 13 && t[e.position + 1] !== 10) throw Et("expected CRLF");
          e.position += 2;
        }
      }
      function wm(t, e) {
        Xa(t[e.position - 1] === 34);
        let r = hr((n) => n !== 10 && n !== 13 && n !== 34, t, e);
        if (t[e.position] !== 34) throw Et('expected "');
        return e.position++, r = new TextDecoder().decode(r).replace(/%0A/ig, `
`).replace(/%0D/ig, "\r").replace(/%22/g, '"'), r;
      }
      function hr(t, e, r) {
        let n = r.position;
        for (; n < e.length && t(e[n]); ) ++n;
        return e.subarray(r.position, r.position = n);
      }
      function lE(t, e, r, n) {
        let A = 0, i = t.length - 1;
        if (e) for (; A < t.length && n(t[A]); ) A++;
        if (r) for (; i > 0 && n(t[i]); ) i--;
        return A === 0 && i === t.length - 1 ? t : t.subarray(A, i + 1);
      }
      function Ka(t, e, r) {
        if (t.length < e.length) return false;
        for (let n = 0; n < e.length; n++) if (e[n] !== t[r.position + n]) return false;
        return true;
      }
      function Et(t) {
        return new TypeError("Failed to parse body as FormData.", { cause: new TypeError(t) });
      }
      Dm.exports = { multipartFormDataParser: cP, validateBoundary: aP };
    });
    var FA = C((jK, Um) => {
      "use strict";
      var za = Y(), { ReadableStreamFrom: uP, readableStreamClose: gP, createDeferredPromise: EP, fullyReadBody: dP, extractMimeType: hP, utf8DecodeBytes: Nm } = Ve(), { FormData: Sm, setFormDataState: fP } = Za(), { webidl: fr } = Te(), { Blob: QP } = require("node:buffer"), uE = require("node:assert"), { isErrored: Fm, isDisturbed: CP } = require("node:stream"), { isArrayBuffer: IP } = require("node:util/types"), { serializeAMimeType: pP } = tt(), { multipartFormDataParser: BP } = Rm(), gE;
      try {
        let t = require("node:crypto");
        gE = (e) => t.randomInt(0, e);
      } catch {
        gE = (t) => Math.floor(Math.random() * t);
      }
      var $a = new TextEncoder();
      function mP() {
      }
      var EE = globalThis.FinalizationRegistry && process.version.indexOf("v18") !== 0, dE;
      EE && (dE = new FinalizationRegistry((t) => {
        let e = t.deref();
        e && !e.locked && !CP(e) && !Fm(e) && e.cancel("Response object has been garbage collected").catch(mP);
      }));
      function Tm(t, e = false) {
        let r = null;
        fr.is.ReadableStream(t) ? r = t : fr.is.Blob(t) ? r = t.stream() : r = new ReadableStream({ async pull(a) {
          let c = typeof A == "string" ? $a.encode(A) : A;
          c.byteLength && a.enqueue(c), queueMicrotask(() => gP(a));
        }, start() {
        }, type: "bytes" }), uE(fr.is.ReadableStream(r));
        let n = null, A = null, i = null, s = null;
        if (typeof t == "string") A = t, s = "text/plain;charset=UTF-8";
        else if (fr.is.URLSearchParams(t)) A = t.toString(), s = "application/x-www-form-urlencoded;charset=UTF-8";
        else if (IP(t)) A = new Uint8Array(t.slice());
        else if (ArrayBuffer.isView(t)) A = new Uint8Array(t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength));
        else if (fr.is.FormData(t)) {
          let a = `----formdata-undici-0${`${gE(1e11)}`.padStart(11, "0")}`, c = `--${a}\r
Content-Disposition: form-data`;
          let l = (p) => p.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), u = (p) => p.replace(/\r?\n|\r/g, `\r
`), g = [], E = new Uint8Array([13, 10]);
          i = 0;
          let h = false;
          for (let [p, Q] of t) if (typeof Q == "string") {
            let I = $a.encode(c + `; name="${l(u(p))}"\r
\r
${u(Q)}\r
`);
            g.push(I), i += I.byteLength;
          } else {
            let I = $a.encode(`${c}; name="${l(u(p))}"` + (Q.name ? `; filename="${l(Q.name)}"` : "") + `\r
Content-Type: ${Q.type || "application/octet-stream"}\r
\r
`);
            g.push(I, Q, E), typeof Q.size == "number" ? i += I.byteLength + Q.size + E.byteLength : h = true;
          }
          let f = $a.encode(`--${a}--\r
`);
          g.push(f), i += f.byteLength, h && (i = null), A = t, n = async function* () {
            for (let p of g) p.stream ? yield* p.stream() : yield p;
          }, s = `multipart/form-data; boundary=${a}`;
        } else if (fr.is.Blob(t)) A = t, i = t.size, t.type && (s = t.type);
        else if (typeof t[Symbol.asyncIterator] == "function") {
          if (e) throw new TypeError("keepalive");
          if (za.isDisturbed(t) || t.locked) throw new TypeError("Response body object should not be disturbed or locked");
          r = fr.is.ReadableStream(t) ? t : uP(t);
        }
        if ((typeof A == "string" || za.isBuffer(A)) && (i = Buffer.byteLength(A)), n != null) {
          let a;
          r = new ReadableStream({ async start() {
            a = n(t)[Symbol.asyncIterator]();
          }, async pull(c) {
            let { value: l, done: u } = await a.next();
            if (u) queueMicrotask(() => {
              c.close(), c.byobRequest?.respond(0);
            });
            else if (!Fm(r)) {
              let g = new Uint8Array(l);
              g.byteLength && c.enqueue(g);
            }
            return c.desiredSize > 0;
          }, async cancel(c) {
            await a.return();
          }, type: "bytes" });
        }
        return [{ stream: r, source: A, length: i }, s];
      }
      function yP(t, e = false) {
        return fr.is.ReadableStream(t) && (uE(!za.isDisturbed(t), "The body has already been consumed."), uE(!t.locked, "The stream is locked.")), Tm(t, e);
      }
      function wP(t, e) {
        let [r, n] = e.stream.tee();
        return EE && dE.register(t, new WeakRef(r)), e.stream = r, { stream: n, length: e.length, source: e.source };
      }
      function DP(t) {
        if (t.aborted) throw new DOMException("The operation was aborted.", "AbortError");
      }
      function RP(t, e) {
        return { blob() {
          return NA(this, (n) => {
            let A = bm(e(this));
            return A === null ? A = "" : A && (A = pP(A)), new QP([n], { type: A });
          }, t, e);
        }, arrayBuffer() {
          return NA(this, (n) => new Uint8Array(n).buffer, t, e);
        }, text() {
          return NA(this, Nm, t, e);
        }, json() {
          return NA(this, bP, t, e);
        }, formData() {
          return NA(this, (n) => {
            let A = bm(e(this));
            if (A !== null) switch (A.essence) {
              case "multipart/form-data": {
                let i = BP(n, A), s = new Sm();
                return fP(s, i), s;
              }
              case "application/x-www-form-urlencoded": {
                let i = new URLSearchParams(n.toString()), s = new Sm();
                for (let [o, a] of i) s.append(o, a);
                return s;
              }
            }
            throw new TypeError('Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".');
          }, t, e);
        }, bytes() {
          return NA(this, (n) => new Uint8Array(n), t, e);
        } };
      }
      function SP(t, e) {
        Object.assign(t.prototype, RP(t, e));
      }
      async function NA(t, e, r, n) {
        fr.brandCheck(t, r);
        let A = n(t);
        if (xm(A)) throw new TypeError("Body is unusable: Body has already been read");
        DP(A);
        let i = EP(), s = (a) => i.reject(a), o = (a) => {
          try {
            i.resolve(e(a));
          } catch (c) {
            s(c);
          }
        };
        return A.body == null ? (o(Buffer.allocUnsafe(0)), i.promise) : (dP(A.body, o, s), i.promise);
      }
      function xm(t) {
        let e = t.body;
        return e != null && (e.stream.locked || za.isDisturbed(e.stream));
      }
      function bP(t) {
        return JSON.parse(Nm(t));
      }
      function bm(t) {
        let e = t.headersList, r = hP(e);
        return r === "failure" ? null : r;
      }
      Um.exports = { extractBody: Tm, safelyExtractBody: yP, cloneBody: wP, mixinBody: SP, streamRegistry: dE, hasFinalizationRegistry: EE, bodyUnusable: xm };
    });
    var qm = C((ZK, Hm) => {
      "use strict";
      var U = require("node:assert"), k = Y(), { channels: km } = lr(), hE = Hg(), { RequestContentLengthMismatchError: In, ResponseContentLengthMismatchError: NP, RequestAbortedError: Gm, HeadersTimeoutError: FP, HeadersOverflowError: TP, SocketError: ss, InformationalError: TA, BodyTimeoutError: xP, HTTPParserError: UP, ResponseExceededMaxSizeError: kP } = H(), { kUrl: Om, kReset: je, kClient: yE, kParser: de, kBlocking: os, kRunning: Me, kPending: MP, kSize: Mm, kWriting: Jr, kQueue: yt, kNoRef: As, kKeepAliveDefaultTimeout: LP, kHostHeader: vP, kPendingIdx: PP, kRunningIdx: dt, kError: ht, kPipelining: rc, kSocket: xA, kKeepAliveTimeoutValue: Ac, kMaxHeadersSize: YP, kKeepAliveMaxTimeout: GP, kKeepAliveTimeoutThreshold: OP, kHeadersTimeout: VP, kBodyTimeout: HP, kStrictContentLength: CE, kMaxRequests: Lm, kCounter: qP, kMaxResponseSize: JP, kOnError: WP, kResume: qr, kHTTPContext: Vm, kClosed: IE } = ne(), Ht = MB(), _P = Buffer.alloc(0), ec = Buffer[Symbol.species], jP = k.removeAllListeners, fE;
      async function ZP() {
        let t = process.env.JEST_WORKER_ID ? _g() : void 0, e;
        try {
          e = await WebAssembly.compile(PB());
        } catch {
          e = await WebAssembly.compile(t || _g());
        }
        return await WebAssembly.instantiate(e, { env: { wasm_on_url: (r, n, A) => 0, wasm_on_status: (r, n, A) => {
          U(ye.ptr === r);
          let i = n - Jt + qt.byteOffset;
          return ye.onStatus(new ec(qt.buffer, i, A));
        }, wasm_on_message_begin: (r) => (U(ye.ptr === r), ye.onMessageBegin()), wasm_on_header_field: (r, n, A) => {
          U(ye.ptr === r);
          let i = n - Jt + qt.byteOffset;
          return ye.onHeaderField(new ec(qt.buffer, i, A));
        }, wasm_on_header_value: (r, n, A) => {
          U(ye.ptr === r);
          let i = n - Jt + qt.byteOffset;
          return ye.onHeaderValue(new ec(qt.buffer, i, A));
        }, wasm_on_headers_complete: (r, n, A, i) => (U(ye.ptr === r), ye.onHeadersComplete(n, A === 1, i === 1)), wasm_on_body: (r, n, A) => {
          U(ye.ptr === r);
          let i = n - Jt + qt.byteOffset;
          return ye.onBody(new ec(qt.buffer, i, A));
        }, wasm_on_message_complete: (r) => (U(ye.ptr === r), ye.onMessageComplete()) } });
      }
      var QE = null, pE = ZP();
      pE.catch();
      var ye = null, qt = null, tc = 0, Jt = null, XP = 0, is = 1, UA = 2 | is, nc = 4 | is, BE = 8 | XP, mE = class {
        constructor(e, r, { exports: n }) {
          this.llhttp = n, this.ptr = this.llhttp.llhttp_alloc(Ht.TYPE.RESPONSE), this.client = e, this.socket = r, this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.statusCode = 0, this.statusText = "", this.upgrade = false, this.headers = [], this.headersSize = 0, this.headersMaxSize = e[YP], this.shouldKeepAlive = false, this.paused = false, this.resume = this.resume.bind(this), this.bytesRead = 0, this.keepAlive = "", this.contentLength = "", this.connection = "", this.maxResponseSize = e[JP];
        }
        setTimeout(e, r) {
          e !== this.timeoutValue || r & is ^ this.timeoutType & is ? (this.timeout && (hE.clearTimeout(this.timeout), this.timeout = null), e && (r & is ? this.timeout = hE.setFastTimeout(vm, e, new WeakRef(this)) : (this.timeout = setTimeout(vm, e, new WeakRef(this)), this.timeout.unref())), this.timeoutValue = e) : this.timeout && this.timeout.refresh && this.timeout.refresh(), this.timeoutType = r;
        }
        resume() {
          this.socket.destroyed || !this.paused || (U(this.ptr != null), U(ye === null), this.llhttp.llhttp_resume(this.ptr), U(this.timeoutType === nc), this.timeout && this.timeout.refresh && this.timeout.refresh(), this.paused = false, this.execute(this.socket.read() || _P), this.readMore());
        }
        readMore() {
          for (; !this.paused && this.ptr; ) {
            let e = this.socket.read();
            if (e === null) break;
            this.execute(e);
          }
        }
        execute(e) {
          U(ye === null), U(this.ptr != null), U(!this.paused);
          let { socket: r, llhttp: n } = this;
          e.length > tc && (Jt && n.free(Jt), tc = Math.ceil(e.length / 4096) * 4096, Jt = n.malloc(tc)), new Uint8Array(n.memory.buffer, Jt, tc).set(e);
          try {
            let A;
            try {
              qt = e, ye = this, A = n.llhttp_execute(this.ptr, Jt, e.length);
            } catch (i) {
              throw i;
            } finally {
              ye = null, qt = null;
            }
            if (A !== Ht.ERROR.OK) {
              let i = e.subarray(n.llhttp_get_error_pos(this.ptr) - Jt);
              if (A === Ht.ERROR.PAUSED_UPGRADE) this.onUpgrade(i);
              else if (A === Ht.ERROR.PAUSED) this.paused = true, r.unshift(i);
              else {
                let s = n.llhttp_get_error_reason(this.ptr), o = "";
                if (s) {
                  let a = new Uint8Array(n.memory.buffer, s).indexOf(0);
                  o = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(n.memory.buffer, s, a).toString() + ")";
                }
                throw new UP(o, Ht.ERROR[A], i);
              }
            }
          } catch (A) {
            k.destroy(r, A);
          }
        }
        destroy() {
          U(ye === null), U(this.ptr != null), this.llhttp.llhttp_free(this.ptr), this.ptr = null, this.timeout && hE.clearTimeout(this.timeout), this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.paused = false;
        }
        onStatus(e) {
          return this.statusText = e.toString(), 0;
        }
        onMessageBegin() {
          let { socket: e, client: r } = this;
          if (e.destroyed) return -1;
          let n = r[yt][r[dt]];
          return n ? (n.onResponseStarted(), 0) : -1;
        }
        onHeaderField(e) {
          let r = this.headers.length;
          return (r & 1) === 0 ? this.headers.push(e) : this.headers[r - 1] = Buffer.concat([this.headers[r - 1], e]), this.trackHeader(e.length), 0;
        }
        onHeaderValue(e) {
          let r = this.headers.length;
          (r & 1) === 1 ? (this.headers.push(e), r += 1) : this.headers[r - 1] = Buffer.concat([this.headers[r - 1], e]);
          let n = this.headers[r - 2];
          if (n.length === 10) {
            let A = k.bufferToLowerCasedHeaderName(n);
            A === "keep-alive" ? this.keepAlive += e.toString() : A === "connection" && (this.connection += e.toString());
          } else n.length === 14 && k.bufferToLowerCasedHeaderName(n) === "content-length" && (this.contentLength += e.toString());
          return this.trackHeader(e.length), 0;
        }
        trackHeader(e) {
          this.headersSize += e, this.headersSize >= this.headersMaxSize && k.destroy(this.socket, new TP());
        }
        onUpgrade(e) {
          let { upgrade: r, client: n, socket: A, headers: i, statusCode: s } = this;
          U(r), U(n[xA] === A), U(!A.destroyed), U(!this.paused), U((i.length & 1) === 0);
          let o = n[yt][n[dt]];
          U(o), U(o.upgrade || o.method === "CONNECT"), this.statusCode = 0, this.statusText = "", this.shouldKeepAlive = false, this.headers = [], this.headersSize = 0, A.unshift(e), A[de].destroy(), A[de] = null, A[yE] = null, A[ht] = null, jP(A), n[xA] = null, n[Vm] = null, n[yt][n[dt]++] = null, n.emit("disconnect", n[Om], [n], new TA("upgrade"));
          try {
            o.onUpgrade(s, i, A);
          } catch (a) {
            k.destroy(A, a);
          }
          n[qr]();
        }
        onHeadersComplete(e, r, n) {
          let { client: A, socket: i, headers: s, statusText: o } = this;
          if (i.destroyed) return -1;
          let a = A[yt][A[dt]];
          if (!a) return -1;
          if (U(!this.upgrade), U(this.statusCode < 200), e === 100) return k.destroy(i, new ss("bad response", k.getSocketInfo(i))), -1;
          if (r && !a.upgrade) return k.destroy(i, new ss("bad upgrade", k.getSocketInfo(i))), -1;
          if (U(this.timeoutType === UA), this.statusCode = e, this.shouldKeepAlive = n || a.method === "HEAD" && !i[je] && this.connection.toLowerCase() === "keep-alive", this.statusCode >= 200) {
            let l = a.bodyTimeout != null ? a.bodyTimeout : A[HP];
            this.setTimeout(l, nc);
          } else this.timeout && this.timeout.refresh && this.timeout.refresh();
          if (a.method === "CONNECT") return U(A[Me] === 1), this.upgrade = true, 2;
          if (r) return U(A[Me] === 1), this.upgrade = true, 2;
          if (U((this.headers.length & 1) === 0), this.headers = [], this.headersSize = 0, this.shouldKeepAlive && A[rc]) {
            let l = this.keepAlive ? k.parseKeepAliveTimeout(this.keepAlive) : null;
            if (l != null) {
              let u = Math.min(l - A[OP], A[GP]);
              u <= 0 ? i[je] = true : A[Ac] = u;
            } else A[Ac] = A[LP];
          } else i[je] = true;
          let c = a.onHeaders(e, s, this.resume, o) === false;
          return a.aborted ? -1 : a.method === "HEAD" || e < 200 ? 1 : (i[os] && (i[os] = false, A[qr]()), c ? Ht.ERROR.PAUSED : 0);
        }
        onBody(e) {
          let { client: r, socket: n, statusCode: A, maxResponseSize: i } = this;
          if (n.destroyed) return -1;
          let s = r[yt][r[dt]];
          return U(s), U(this.timeoutType === nc), this.timeout && this.timeout.refresh && this.timeout.refresh(), U(A >= 200), i > -1 && this.bytesRead + e.length > i ? (k.destroy(n, new kP()), -1) : (this.bytesRead += e.length, s.onData(e) === false ? Ht.ERROR.PAUSED : 0);
        }
        onMessageComplete() {
          let { client: e, socket: r, statusCode: n, upgrade: A, headers: i, contentLength: s, bytesRead: o, shouldKeepAlive: a } = this;
          if (r.destroyed && (!n || a)) return -1;
          if (A) return 0;
          U(n >= 100), U((this.headers.length & 1) === 0);
          let c = e[yt][e[dt]];
          if (U(c), this.statusCode = 0, this.statusText = "", this.bytesRead = 0, this.contentLength = "", this.keepAlive = "", this.connection = "", this.headers = [], this.headersSize = 0, n < 200) return 0;
          if (c.method !== "HEAD" && s && o !== parseInt(s, 10)) return k.destroy(r, new NP()), -1;
          if (c.onComplete(i), e[yt][e[dt]++] = null, r[Jr]) return U(e[Me] === 0), k.destroy(r, new TA("reset")), Ht.ERROR.PAUSED;
          if (a) {
            if (r[je] && e[Me] === 0) return k.destroy(r, new TA("reset")), Ht.ERROR.PAUSED;
            e[rc] == null || e[rc] === 1 ? setImmediate(() => e[qr]()) : e[qr]();
          } else return k.destroy(r, new TA("reset")), Ht.ERROR.PAUSED;
          return 0;
        }
      };
      function vm(t) {
        let { socket: e, timeoutType: r, client: n, paused: A } = t.deref();
        r === UA ? (!e[Jr] || e.writableNeedDrain || n[Me] > 1) && (U(!A, "cannot be paused while waiting for headers"), k.destroy(e, new FP())) : r === nc ? A || k.destroy(e, new xP()) : r === BE && (U(n[Me] === 0 && n[Ac]), k.destroy(e, new TA("socket idle timeout")));
      }
      async function KP(t, e) {
        if (t[xA] = e, !QE) {
          let r = () => {
          };
          e.on("error", r), QE = await pE, pE = null, e.off("error", r);
        }
        if (e.errored) throw e.errored;
        if (e.destroyed) throw new ss("destroyed");
        return e[As] = false, e[Jr] = false, e[je] = false, e[os] = false, e[de] = new mE(t, e, QE), k.addListener(e, "error", $P), k.addListener(e, "readable", zP), k.addListener(e, "end", e1), k.addListener(e, "close", t1), e[IE] = false, e.on("close", r1), { version: "h1", defaultPipelining: 1, write(r) {
          return i1(t, r);
        }, resume() {
          n1(t);
        }, destroy(r, n) {
          e[IE] ? queueMicrotask(n) : (e.on("close", n), e.destroy(r));
        }, get destroyed() {
          return e.destroyed;
        }, busy(r) {
          return !!(e[Jr] || e[je] || e[os] || r && (t[Me] > 0 && !r.idempotent || t[Me] > 0 && (r.upgrade || r.method === "CONNECT") || t[Me] > 0 && k.bodyLength(r.body) !== 0 && (k.isStream(r.body) || k.isAsyncIterable(r.body) || k.isFormDataLike(r.body))));
        } };
      }
      function $P(t) {
        U(t.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
        let e = this[de];
        if (t.code === "ECONNRESET" && e.statusCode && !e.shouldKeepAlive) {
          e.onMessageComplete();
          return;
        }
        this[ht] = t, this[yE][WP](t);
      }
      function zP() {
        this[de]?.readMore();
      }
      function e1() {
        let t = this[de];
        if (t.statusCode && !t.shouldKeepAlive) {
          t.onMessageComplete();
          return;
        }
        k.destroy(this, new ss("other side closed", k.getSocketInfo(this)));
      }
      function t1() {
        let t = this[de];
        t && (!this[ht] && t.statusCode && !t.shouldKeepAlive && t.onMessageComplete(), this[de].destroy(), this[de] = null);
        let e = this[ht] || new ss("closed", k.getSocketInfo(this)), r = this[yE];
        if (r[xA] = null, r[Vm] = null, r.destroyed) {
          U(r[MP] === 0);
          let n = r[yt].splice(r[dt]);
          for (let A = 0; A < n.length; A++) {
            let i = n[A];
            k.errorRequest(r, i, e);
          }
        } else if (r[Me] > 0 && e.code !== "UND_ERR_INFO") {
          let n = r[yt][r[dt]];
          r[yt][r[dt]++] = null, k.errorRequest(r, n, e);
        }
        r[PP] = r[dt], U(r[Me] === 0), r.emit("disconnect", r[Om], [r], e), r[qr]();
      }
      function r1() {
        this[IE] = true;
      }
      function n1(t) {
        let e = t[xA];
        if (e && !e.destroyed) {
          if (t[Mm] === 0 ? !e[As] && e.unref && (e.unref(), e[As] = true) : e[As] && e.ref && (e.ref(), e[As] = false), t[Mm] === 0) e[de].timeoutType !== BE && e[de].setTimeout(t[Ac], BE);
          else if (t[Me] > 0 && e[de].statusCode < 200 && e[de].timeoutType !== UA) {
            let r = t[yt][t[dt]], n = r.headersTimeout != null ? r.headersTimeout : t[VP];
            e[de].setTimeout(n, UA);
          }
        }
      }
      function A1(t) {
        return t !== "GET" && t !== "HEAD" && t !== "OPTIONS" && t !== "TRACE" && t !== "CONNECT";
      }
      function i1(t, e) {
        let { method: r, path: n, host: A, upgrade: i, blocking: s, reset: o } = e, { body: a, headers: c, contentLength: l } = e, u = r === "PUT" || r === "POST" || r === "PATCH" || r === "QUERY" || r === "PROPFIND" || r === "PROPPATCH";
        if (k.isFormDataLike(a)) {
          fE || (fE = FA().extractBody);
          let [p, Q] = fE(a);
          e.contentType == null && c.push("content-type", Q), a = p.stream, l = p.length;
        } else k.isBlobLike(a) && e.contentType == null && a.type && c.push("content-type", a.type);
        a && typeof a.read == "function" && a.read(0);
        let g = k.bodyLength(a);
        if (l = g ?? l, l === null && (l = e.contentLength), l === 0 && !u && (l = null), A1(r) && l > 0 && e.contentLength !== null && e.contentLength !== l) {
          if (t[CE]) return k.errorRequest(t, e, new In()), false;
          process.emitWarning(new In());
        }
        let E = t[xA], h = (p) => {
          e.aborted || e.completed || (k.errorRequest(t, e, p || new Gm()), k.destroy(a), k.destroy(E, new TA("aborted")));
        };
        try {
          e.onConnect(h);
        } catch (p) {
          k.errorRequest(t, e, p);
        }
        if (e.aborted) return false;
        r === "HEAD" && (E[je] = true), (i || r === "CONNECT") && (E[je] = true), o != null && (E[je] = o), t[Lm] && E[qP]++ >= t[Lm] && (E[je] = true), s && (E[os] = true);
        let f = `${r} ${n} HTTP/1.1\r
`;
        if (typeof A == "string" ? f += `host: ${A}\r
` : f += t[vP], i ? f += `connection: upgrade\r
upgrade: ${i}\r
` : t[rc] && !E[je] ? f += `connection: keep-alive\r
` : f += `connection: close\r
`, Array.isArray(c)) for (let p = 0; p < c.length; p += 2) {
          let Q = c[p + 0], I = c[p + 1];
          if (Array.isArray(I)) for (let B = 0; B < I.length; B++) f += `${Q}: ${I[B]}\r
`;
          else f += `${Q}: ${I}\r
`;
        }
        return km.sendHeaders.hasSubscribers && km.sendHeaders.publish({ request: e, headers: f, socket: E }), !a || g === 0 ? Pm(h, null, t, e, E, l, f, u) : k.isBuffer(a) ? Pm(h, a, t, e, E, l, f, u) : k.isBlobLike(a) ? typeof a.stream == "function" ? Ym(h, a.stream(), t, e, E, l, f, u) : o1(h, a, t, e, E, l, f, u) : k.isStream(a) ? s1(h, a, t, e, E, l, f, u) : k.isIterable(a) ? Ym(h, a, t, e, E, l, f, u) : U(false), true;
      }
      function s1(t, e, r, n, A, i, s, o) {
        U(i !== 0 || r[Me] === 0, "stream body cannot be pipelined");
        let a = false, c = new ic({ abort: t, socket: A, request: n, contentLength: i, client: r, expectsPayload: o, header: s }), l = function(h) {
          if (!a) try {
            !c.write(h) && this.pause && this.pause();
          } catch (f) {
            k.destroy(this, f);
          }
        }, u = function() {
          a || e.resume && e.resume();
        }, g = function() {
          if (queueMicrotask(() => {
            e.removeListener("error", E);
          }), !a) {
            let h = new Gm();
            queueMicrotask(() => E(h));
          }
        }, E = function(h) {
          if (!a) {
            if (a = true, U(A.destroyed || A[Jr] && r[Me] <= 1), A.off("drain", u).off("error", E), e.removeListener("data", l).removeListener("end", E).removeListener("close", g), !h) try {
              c.end();
            } catch (f) {
              h = f;
            }
            c.destroy(h), h && (h.code !== "UND_ERR_INFO" || h.message !== "reset") ? k.destroy(e, h) : k.destroy(e);
          }
        };
        e.on("data", l).on("end", E).on("error", E).on("close", g), e.resume && e.resume(), A.on("drain", u).on("error", E), e.errorEmitted ?? e.errored ? setImmediate(() => E(e.errored)) : (e.endEmitted ?? e.readableEnded) && setImmediate(() => E(null)), (e.closeEmitted ?? e.closed) && setImmediate(g);
      }
      function Pm(t, e, r, n, A, i, s, o) {
        try {
          e ? k.isBuffer(e) && (U(i === e.byteLength, "buffer body must have content length"), A.cork(), A.write(`${s}content-length: ${i}\r
\r
`, "latin1"), A.write(e), A.uncork(), n.onBodySent(e), !o && n.reset !== false && (A[je] = true)) : i === 0 ? A.write(`${s}content-length: 0\r
\r
`, "latin1") : (U(i === null, "no body must not have content length"), A.write(`${s}\r
`, "latin1")), n.onRequestSent(), r[qr]();
        } catch (a) {
          t(a);
        }
      }
      async function o1(t, e, r, n, A, i, s, o) {
        U(i === e.size, "blob body must have content length");
        try {
          if (i != null && i !== e.size) throw new In();
          let a = Buffer.from(await e.arrayBuffer());
          A.cork(), A.write(`${s}content-length: ${i}\r
\r
`, "latin1"), A.write(a), A.uncork(), n.onBodySent(a), n.onRequestSent(), !o && n.reset !== false && (A[je] = true), r[qr]();
        } catch (a) {
          t(a);
        }
      }
      async function Ym(t, e, r, n, A, i, s, o) {
        U(i !== 0 || r[Me] === 0, "iterator body cannot be pipelined");
        let a = null;
        function c() {
          if (a) {
            let g = a;
            a = null, g();
          }
        }
        let l = () => new Promise((g, E) => {
          U(a === null), A[ht] ? E(A[ht]) : a = g;
        });
        A.on("close", c).on("drain", c);
        let u = new ic({ abort: t, socket: A, request: n, contentLength: i, client: r, expectsPayload: o, header: s });
        try {
          for await (let g of e) {
            if (A[ht]) throw A[ht];
            u.write(g) || await l();
          }
          u.end();
        } catch (g) {
          u.destroy(g);
        } finally {
          A.off("close", c).off("drain", c);
        }
      }
      var ic = class {
        constructor({ abort: e, socket: r, request: n, contentLength: A, client: i, expectsPayload: s, header: o }) {
          this.socket = r, this.request = n, this.contentLength = A, this.client = i, this.bytesWritten = 0, this.expectsPayload = s, this.header = o, this.abort = e, r[Jr] = true;
        }
        write(e) {
          let { socket: r, request: n, contentLength: A, client: i, bytesWritten: s, expectsPayload: o, header: a } = this;
          if (r[ht]) throw r[ht];
          if (r.destroyed) return false;
          let c = Buffer.byteLength(e);
          if (!c) return true;
          if (A !== null && s + c > A) {
            if (i[CE]) throw new In();
            process.emitWarning(new In());
          }
          r.cork(), s === 0 && (!o && n.reset !== false && (r[je] = true), A === null ? r.write(`${a}transfer-encoding: chunked\r
`, "latin1") : r.write(`${a}content-length: ${A}\r
\r
`, "latin1")), A === null && r.write(`\r
${c.toString(16)}\r
`, "latin1"), this.bytesWritten += c;
          let l = r.write(e);
          return r.uncork(), n.onBodySent(e), l || r[de].timeout && r[de].timeoutType === UA && r[de].timeout.refresh && r[de].timeout.refresh(), l;
        }
        end() {
          let { socket: e, contentLength: r, client: n, bytesWritten: A, expectsPayload: i, header: s, request: o } = this;
          if (o.onRequestSent(), e[Jr] = false, e[ht]) throw e[ht];
          if (!e.destroyed) {
            if (A === 0 ? i ? e.write(`${s}content-length: 0\r
\r
`, "latin1") : e.write(`${s}\r
`, "latin1") : r === null && e.write(`\r
0\r
\r
`, "latin1"), r !== null && A !== r) {
              if (n[CE]) throw new In();
              process.emitWarning(new In());
            }
            e[de].timeout && e[de].timeoutType === UA && e[de].timeout.refresh && e[de].timeout.refresh(), n[qr]();
          }
        }
        destroy(e) {
          let { socket: r, client: n, abort: A } = this;
          r[Jr] = false, e && (U(n[Me] <= 1, "pipeline should only contain this request"), A(e));
        }
      };
      Hm.exports = KP;
    });
    var Km = C((XK, Xm) => {
      "use strict";
      var Qt = require("node:assert"), { pipeline: a1 } = require("node:stream"), J = Y(), { RequestContentLengthMismatchError: wE, RequestAbortedError: c1, SocketError: as, InformationalError: sc } = H(), { kUrl: ac, kReset: cc, kClient: pn, kRunning: lc, kPending: l1, kQueue: Wr, kPendingIdx: RE, kRunningIdx: wt, kError: Dt, kSocket: fe, kStrictContentLength: u1, kOnError: uc, kMaxConcurrentStreams: Zm, kHTTP2Session: Wt, kResume: Qr, kSize: g1, kHTTPContext: SE, kClosed: DE, kBodyTimeout: E1 } = ne(), { channels: Jm } = lr(), ft = /* @__PURE__ */ Symbol("open streams"), Wm, oc;
      try {
        oc = require("node:http2");
      } catch {
        oc = { constants: {} };
      }
      var { constants: { HTTP2_HEADER_AUTHORITY: d1, HTTP2_HEADER_METHOD: h1, HTTP2_HEADER_PATH: f1, HTTP2_HEADER_SCHEME: Q1, HTTP2_HEADER_CONTENT_LENGTH: C1, HTTP2_HEADER_EXPECT: I1, HTTP2_HEADER_STATUS: p1 } } = oc;
      function B1(t) {
        let e = [];
        for (let [r, n] of Object.entries(t)) if (Array.isArray(n)) for (let A of n) e.push(Buffer.from(r), Buffer.from(A));
        else e.push(Buffer.from(r), Buffer.from(n));
        return e;
      }
      async function m1(t, e) {
        t[fe] = e;
        let r = oc.connect(t[ac], { createConnection: () => e, peerMaxConcurrentStreams: t[Zm], settings: { enablePush: false } });
        return r[ft] = 0, r[pn] = t, r[fe] = e, r[Wt] = null, J.addListener(r, "error", w1), J.addListener(r, "frameError", D1), J.addListener(r, "end", R1), J.addListener(r, "goaway", S1), J.addListener(r, "close", b1), r.unref(), t[Wt] = r, e[Wt] = r, J.addListener(e, "error", F1), J.addListener(e, "end", T1), J.addListener(e, "close", N1), e[DE] = false, e.on("close", x1), { version: "h2", defaultPipelining: 1 / 0, write(n) {
          return k1(t, n);
        }, resume() {
          y1(t);
        }, destroy(n, A) {
          e[DE] ? queueMicrotask(A) : e.destroy(n).on("close", A);
        }, get destroyed() {
          return e.destroyed;
        }, busy() {
          return false;
        } };
      }
      function y1(t) {
        let e = t[fe];
        e?.destroyed === false && (t[g1] === 0 || t[Zm] === 0 ? (e.unref(), t[Wt].unref()) : (e.ref(), t[Wt].ref()));
      }
      function w1(t) {
        Qt(t.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[fe][Dt] = t, this[pn][uc](t);
      }
      function D1(t, e, r) {
        if (r === 0) {
          let n = new sc(`HTTP/2: "frameError" received - type ${t}, code ${e}`);
          this[fe][Dt] = n, this[pn][uc](n);
        }
      }
      function R1() {
        let t = new as("other side closed", J.getSocketInfo(this[fe]));
        this.destroy(t), J.destroy(this[fe], t);
      }
      function S1(t) {
        let e = this[Dt] || new as(`HTTP/2: "GOAWAY" frame received with code ${t}`, J.getSocketInfo(this[fe])), r = this[pn];
        if (r[fe] = null, r[SE] = null, this.close(), this[Wt] = null, J.destroy(this[fe], e), r[wt] < r[Wr].length) {
          let n = r[Wr][r[wt]];
          r[Wr][r[wt]++] = null, J.errorRequest(r, n, e), r[RE] = r[wt];
        }
        Qt(r[lc] === 0), r.emit("disconnect", r[ac], [r], e), r[Qr]();
      }
      function b1() {
        let { [pn]: t } = this, { [fe]: e } = t, r = this[fe][Dt] || this[Dt] || new as("closed", J.getSocketInfo(e));
        if (t[fe] = null, t[SE] = null, t.destroyed) {
          Qt(t[l1] === 0);
          let n = t[Wr].splice(t[wt]);
          for (let A = 0; A < n.length; A++) {
            let i = n[A];
            J.errorRequest(t, i, r);
          }
        }
      }
      function N1() {
        let t = this[Dt] || new as("closed", J.getSocketInfo(this)), e = this[Wt][pn];
        e[fe] = null, e[SE] = null, this[Wt] !== null && this[Wt].destroy(t), e[RE] = e[wt], Qt(e[lc] === 0), e.emit("disconnect", e[ac], [e], t), e[Qr]();
      }
      function F1(t) {
        Qt(t.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[Dt] = t, this[pn][uc](t);
      }
      function T1() {
        J.destroy(this, new as("other side closed", J.getSocketInfo(this)));
      }
      function x1() {
        this[DE] = true;
      }
      function U1(t) {
        return t !== "GET" && t !== "HEAD" && t !== "OPTIONS" && t !== "TRACE" && t !== "CONNECT";
      }
      function k1(t, e) {
        let r = e.bodyTimeout ?? t[E1], n = t[Wt], { method: A, path: i, host: s, upgrade: o, expectContinue: a, signal: c, headers: l } = e, { body: u } = e;
        if (o) return J.errorRequest(t, e, new Error("Upgrade not supported for H2")), false;
        let g = {};
        for (let D = 0; D < l.length; D += 2) {
          let v = l[D + 0], K = l[D + 1];
          if (Array.isArray(K)) for (let W = 0; W < K.length; W++) g[v] ? g[v] += `,${K[W]}` : g[v] = K[W];
          else g[v] = K;
        }
        let E = null, { hostname: h, port: f } = t[ac];
        g[d1] = s || `${h}${f ? `:${f}` : ""}`, g[h1] = A;
        let p = (D) => {
          e.aborted || e.completed || (D = D || new c1(), J.errorRequest(t, e, D), E != null && (E.removeAllListeners("data"), E.close(), t[uc](D), t[Qr]()), J.destroy(u, D));
        };
        try {
          e.onConnect(p);
        } catch (D) {
          J.errorRequest(t, e, D);
        }
        if (e.aborted) return false;
        if (A === "CONNECT") return n.ref(), E = n.request(g, { endStream: false, signal: c }), E.pending ? E.once("ready", () => {
          e.onUpgrade(null, null, E), ++n[ft], t[Wr][t[wt]++] = null;
        }) : (e.onUpgrade(null, null, E), ++n[ft], t[Wr][t[wt]++] = null), E.once("close", () => {
          n[ft] -= 1, n[ft] === 0 && n.unref();
        }), E.setTimeout(r), true;
        g[f1] = i, g[Q1] = "https";
        let Q = A === "PUT" || A === "POST" || A === "PATCH";
        u && typeof u.read == "function" && u.read(0);
        let I = J.bodyLength(u);
        if (J.isFormDataLike(u)) {
          Wm ??= FA().extractBody;
          let [D, v] = Wm(u);
          g["content-type"] = v, u = D.stream, I = D.length;
        }
        if (I == null && (I = e.contentLength), (I === 0 || !Q) && (I = null), U1(A) && I > 0 && e.contentLength != null && e.contentLength !== I) {
          if (t[u1]) return J.errorRequest(t, e, new wE()), false;
          process.emitWarning(new wE());
        }
        if (I != null && (Qt(u, "no body must not have content length"), g[C1] = `${I}`), n.ref(), Jm.sendHeaders.hasSubscribers) {
          let D = "";
          for (let v in g) D += `${v}: ${g[v]}\r
`;
          Jm.sendHeaders.publish({ request: e, headers: D, socket: n[fe] });
        }
        let B = A === "GET" || A === "HEAD" || u === null;
        return a ? (g[I1] = "100-continue", E = n.request(g, { endStream: B, signal: c }), E.once("continue", w)) : (E = n.request(g, { endStream: B, signal: c }), w()), ++n[ft], E.setTimeout(r), E.once("response", (D) => {
          let { [p1]: v, ...K } = D;
          if (e.onResponseStarted(), e.aborted) {
            E.removeAllListeners("data");
            return;
          }
          e.onHeaders(Number(v), B1(K), E.resume.bind(E), "") === false && E.pause();
        }), E.on("data", (D) => {
          e.onData(D) === false && E.pause();
        }), E.once("end", (D) => {
          E.removeAllListeners("data"), E.state?.state == null || E.state.state < 6 ? (!e.aborted && !e.completed && e.onComplete({}), t[Wr][t[wt]++] = null, t[Qr]()) : (--n[ft], n[ft] === 0 && n.unref(), p(D ?? new sc("HTTP/2: stream half-closed (remote)")), t[Wr][t[wt]++] = null, t[RE] = t[wt], t[Qr]());
        }), E.once("close", () => {
          E.removeAllListeners("data"), n[ft] -= 1, n[ft] === 0 && n.unref();
        }), E.once("error", function(D) {
          E.removeAllListeners("data"), p(D);
        }), E.once("frameError", (D, v) => {
          E.removeAllListeners("data"), p(new sc(`HTTP/2: "frameError" received - type ${D}, code ${v}`));
        }), E.on("aborted", () => {
          E.removeAllListeners("data");
        }), E.on("timeout", () => {
          let D = new sc(`HTTP/2: "stream timeout after ${r}"`);
          E.removeAllListeners("data"), n[ft] -= 1, n[ft] === 0 && n.unref(), p(D);
        }), E.once("trailers", (D) => {
          e.aborted || e.completed || e.onComplete(D);
        }), true;
        function w() {
          !u || I === 0 ? _m(p, E, null, t, e, t[fe], I, Q) : J.isBuffer(u) ? _m(p, E, u, t, e, t[fe], I, Q) : J.isBlobLike(u) ? typeof u.stream == "function" ? jm(p, E, u.stream(), t, e, t[fe], I, Q) : L1(p, E, u, t, e, t[fe], I, Q) : J.isStream(u) ? M1(p, t[fe], Q, E, u, t, e, I) : J.isIterable(u) ? jm(p, E, u, t, e, t[fe], I, Q) : Qt(false);
        }
      }
      function _m(t, e, r, n, A, i, s, o) {
        try {
          r != null && J.isBuffer(r) && (Qt(s === r.byteLength, "buffer body must have content length"), e.cork(), e.write(r), e.uncork(), e.end(), A.onBodySent(r)), o || (i[cc] = true), A.onRequestSent(), n[Qr]();
        } catch (a) {
          t(a);
        }
      }
      function M1(t, e, r, n, A, i, s, o) {
        Qt(o !== 0 || i[lc] === 0, "stream body cannot be pipelined");
        let a = a1(A, n, (l) => {
          l ? (J.destroy(a, l), t(l)) : (J.removeAllListeners(a), s.onRequestSent(), r || (e[cc] = true), i[Qr]());
        });
        J.addListener(a, "data", c);
        function c(l) {
          s.onBodySent(l);
        }
      }
      async function L1(t, e, r, n, A, i, s, o) {
        Qt(s === r.size, "blob body must have content length");
        try {
          if (s != null && s !== r.size) throw new wE();
          let a = Buffer.from(await r.arrayBuffer());
          e.cork(), e.write(a), e.uncork(), e.end(), A.onBodySent(a), A.onRequestSent(), o || (i[cc] = true), n[Qr]();
        } catch (a) {
          t(a);
        }
      }
      async function jm(t, e, r, n, A, i, s, o) {
        Qt(s !== 0 || n[lc] === 0, "iterator body cannot be pipelined");
        let a = null;
        function c() {
          if (a) {
            let u = a;
            a = null, u();
          }
        }
        let l = () => new Promise((u, g) => {
          Qt(a === null), i[Dt] ? g(i[Dt]) : a = u;
        });
        e.on("close", c).on("drain", c);
        try {
          for await (let u of r) {
            if (i[Dt]) throw i[Dt];
            let g = e.write(u);
            A.onBodySent(u), g || await l();
          }
          e.end(), A.onRequestSent(), o || (i[cc] = true), n[Qr]();
        } catch (u) {
          t(u);
        } finally {
          e.off("close", c).off("drain", c);
        }
      }
      Xm.exports = m1;
    });
    var fs = C((KK, iy) => {
      "use strict";
      var Cr = require("node:assert"), ty = require("node:net"), cs = require("node:http"), Bn = Y(), { channels: kA } = lr(), v1 = QB(), P1 = wA(), { InvalidArgumentError: Qe, InformationalError: Y1, ClientDestroyedError: G1 } = H(), O1 = es(), { kUrl: _t, kServerName: _r, kClient: V1, kBusy: bE, kConnect: H1, kResuming: mn, kRunning: ds, kPending: hs, kSize: Es, kQueue: Rt, kConnected: q1, kConnecting: MA, kNeedDrain: Zr, kKeepAliveDefaultTimeout: $m, kHostHeader: J1, kPendingIdx: St, kRunningIdx: Ir, kError: W1, kPipelining: gc, kKeepAliveTimeoutValue: _1, kMaxHeadersSize: j1, kKeepAliveMaxTimeout: Z1, kKeepAliveTimeoutThreshold: X1, kHeadersTimeout: K1, kBodyTimeout: $1, kStrictContentLength: z1, kConnector: ls, kMaxRequests: NE, kCounter: eY, kClose: tY, kDestroy: rY, kDispatch: nY, kLocalAddress: us, kMaxResponseSize: AY, kOnError: iY, kHTTPContext: Ce, kMaxConcurrentStreams: sY, kResume: gs } = ne(), oY = qm(), aY = Km(), jr = /* @__PURE__ */ Symbol("kClosedResolve"), cY = cs && cs.maxHeaderSize && Number.isInteger(cs.maxHeaderSize) && cs.maxHeaderSize > 0 ? () => cs.maxHeaderSize : () => {
        throw new Qe("http module not available or http.maxHeaderSize invalid");
      }, zm = () => {
      };
      function ry(t) {
        return t[gc] ?? t[Ce]?.defaultPipelining ?? 1;
      }
      var FE = class extends P1 {
        constructor(e, { maxHeaderSize: r, headersTimeout: n, socketTimeout: A, requestTimeout: i, connectTimeout: s, bodyTimeout: o, idleTimeout: a, keepAlive: c, keepAliveTimeout: l, maxKeepAliveTimeout: u, keepAliveMaxTimeout: g, keepAliveTimeoutThreshold: E, socketPath: h, pipelining: f, tls: p, strictContentLength: Q, maxCachedSessions: I, connect: B, maxRequestsPerClient: w, localAddress: D, maxResponseSize: v, autoSelectFamily: K, autoSelectFamilyAttemptTimeout: W, maxConcurrentStreams: ae, allowH2: xe } = {}) {
          if (c !== void 0) throw new Qe("unsupported keepAlive, use pipelining=0 instead");
          if (A !== void 0) throw new Qe("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
          if (i !== void 0) throw new Qe("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
          if (a !== void 0) throw new Qe("unsupported idleTimeout, use keepAliveTimeout instead");
          if (u !== void 0) throw new Qe("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
          if (r != null) {
            if (!Number.isInteger(r) || r < 1) throw new Qe("invalid maxHeaderSize");
          } else r = cY();
          if (h != null && typeof h != "string") throw new Qe("invalid socketPath");
          if (s != null && (!Number.isFinite(s) || s < 0)) throw new Qe("invalid connectTimeout");
          if (l != null && (!Number.isFinite(l) || l <= 0)) throw new Qe("invalid keepAliveTimeout");
          if (g != null && (!Number.isFinite(g) || g <= 0)) throw new Qe("invalid keepAliveMaxTimeout");
          if (E != null && !Number.isFinite(E)) throw new Qe("invalid keepAliveTimeoutThreshold");
          if (n != null && (!Number.isInteger(n) || n < 0)) throw new Qe("headersTimeout must be a positive integer or zero");
          if (o != null && (!Number.isInteger(o) || o < 0)) throw new Qe("bodyTimeout must be a positive integer or zero");
          if (B != null && typeof B != "function" && typeof B != "object") throw new Qe("connect must be a function or an object");
          if (w != null && (!Number.isInteger(w) || w < 0)) throw new Qe("maxRequestsPerClient must be a positive number");
          if (D != null && (typeof D != "string" || ty.isIP(D) === 0)) throw new Qe("localAddress must be valid string IP address");
          if (v != null && (!Number.isInteger(v) || v < -1)) throw new Qe("maxResponseSize must be a positive number");
          if (W != null && (!Number.isInteger(W) || W < -1)) throw new Qe("autoSelectFamilyAttemptTimeout must be a positive number");
          if (xe != null && typeof xe != "boolean") throw new Qe("allowH2 must be a valid boolean value");
          if (ae != null && (typeof ae != "number" || ae < 1)) throw new Qe("maxConcurrentStreams must be a positive integer, greater than 0");
          super(), typeof B != "function" && (B = O1({ ...p, maxCachedSessions: I, allowH2: xe, socketPath: h, timeout: s, ...K ? { autoSelectFamily: K, autoSelectFamilyAttemptTimeout: W } : void 0, ...B })), this[_t] = Bn.parseOrigin(e), this[ls] = B, this[gc] = f ?? 1, this[j1] = r, this[$m] = l ?? 4e3, this[Z1] = g ?? 6e5, this[X1] = E ?? 2e3, this[_1] = this[$m], this[_r] = null, this[us] = D ?? null, this[mn] = 0, this[Zr] = 0, this[J1] = `host: ${this[_t].hostname}${this[_t].port ? `:${this[_t].port}` : ""}\r
`, this[$1] = o ?? 3e5, this[K1] = n ?? 3e5, this[z1] = Q ?? true, this[NE] = w, this[jr] = null, this[AY] = v > -1 ? v : -1, this[sY] = ae ?? 100, this[Ce] = null, this[Rt] = [], this[Ir] = 0, this[St] = 0, this[gs] = (te) => TE(this, te), this[iY] = (te) => ny(this, te);
        }
        get pipelining() {
          return this[gc];
        }
        set pipelining(e) {
          this[gc] = e, this[gs](true);
        }
        get [hs]() {
          return this[Rt].length - this[St];
        }
        get [ds]() {
          return this[St] - this[Ir];
        }
        get [Es]() {
          return this[Rt].length - this[Ir];
        }
        get [q1]() {
          return !!this[Ce] && !this[MA] && !this[Ce].destroyed;
        }
        get [bE]() {
          return !!(this[Ce]?.busy(null) || this[Es] >= (ry(this) || 1) || this[hs] > 0);
        }
        [H1](e) {
          Ay(this), this.once("connect", e);
        }
        [nY](e, r) {
          let n = e.origin || this[_t].origin, A = new v1(n, e, r);
          return this[Rt].push(A), this[mn] || (Bn.bodyLength(A.body) == null && Bn.isIterable(A.body) ? (this[mn] = 1, queueMicrotask(() => TE(this))) : this[gs](true)), this[mn] && this[Zr] !== 2 && this[bE] && (this[Zr] = 2), this[Zr] < 2;
        }
        async [tY]() {
          return new Promise((e) => {
            this[Es] ? this[jr] = e : e(null);
          });
        }
        async [rY](e) {
          return new Promise((r) => {
            let n = this[Rt].splice(this[St]);
            for (let i = 0; i < n.length; i++) {
              let s = n[i];
              Bn.errorRequest(this, s, e);
            }
            let A = () => {
              this[jr] && (this[jr](), this[jr] = null), r(null);
            };
            this[Ce] ? (this[Ce].destroy(e, A), this[Ce] = null) : queueMicrotask(A), this[gs]();
          });
        }
      };
      function ny(t, e) {
        if (t[ds] === 0 && e.code !== "UND_ERR_INFO" && e.code !== "UND_ERR_SOCKET") {
          Cr(t[St] === t[Ir]);
          let r = t[Rt].splice(t[Ir]);
          for (let n = 0; n < r.length; n++) {
            let A = r[n];
            Bn.errorRequest(t, A, e);
          }
          Cr(t[Es] === 0);
        }
      }
      async function Ay(t) {
        Cr(!t[MA]), Cr(!t[Ce]);
        let { host: e, hostname: r, protocol: n, port: A } = t[_t];
        if (r[0] === "[") {
          let i = r.indexOf("]");
          Cr(i !== -1);
          let s = r.substring(1, i);
          Cr(ty.isIPv6(s)), r = s;
        }
        t[MA] = true, kA.beforeConnect.hasSubscribers && kA.beforeConnect.publish({ connectParams: { host: e, hostname: r, protocol: n, port: A, version: t[Ce]?.version, servername: t[_r], localAddress: t[us] }, connector: t[ls] });
        try {
          let i = await new Promise((s, o) => {
            t[ls]({ host: e, hostname: r, protocol: n, port: A, servername: t[_r], localAddress: t[us] }, (a, c) => {
              a ? o(a) : s(c);
            });
          });
          if (t.destroyed) {
            Bn.destroy(i.on("error", zm), new G1());
            return;
          }
          Cr(i);
          try {
            t[Ce] = i.alpnProtocol === "h2" ? await aY(t, i) : await oY(t, i);
          } catch (s) {
            throw i.destroy().on("error", zm), s;
          }
          t[MA] = false, i[eY] = 0, i[NE] = t[NE], i[V1] = t, i[W1] = null, kA.connected.hasSubscribers && kA.connected.publish({ connectParams: { host: e, hostname: r, protocol: n, port: A, version: t[Ce]?.version, servername: t[_r], localAddress: t[us] }, connector: t[ls], socket: i }), t.emit("connect", t[_t], [t]);
        } catch (i) {
          if (t.destroyed) return;
          if (t[MA] = false, kA.connectError.hasSubscribers && kA.connectError.publish({ connectParams: { host: e, hostname: r, protocol: n, port: A, version: t[Ce]?.version, servername: t[_r], localAddress: t[us] }, connector: t[ls], error: i }), i.code === "ERR_TLS_CERT_ALTNAME_INVALID") for (Cr(t[ds] === 0); t[hs] > 0 && t[Rt][t[St]].servername === t[_r]; ) {
            let s = t[Rt][t[St]++];
            Bn.errorRequest(t, s, i);
          }
          else ny(t, i);
          t.emit("connectionError", t[_t], [t], i);
        }
        t[gs]();
      }
      function ey(t) {
        t[Zr] = 0, t.emit("drain", t[_t], [t]);
      }
      function TE(t, e) {
        t[mn] !== 2 && (t[mn] = 2, lY(t, e), t[mn] = 0, t[Ir] > 256 && (t[Rt].splice(0, t[Ir]), t[St] -= t[Ir], t[Ir] = 0));
      }
      function lY(t, e) {
        for (; ; ) {
          if (t.destroyed) {
            Cr(t[hs] === 0);
            return;
          }
          if (t[jr] && !t[Es]) {
            t[jr](), t[jr] = null;
            return;
          }
          if (t[Ce] && t[Ce].resume(), t[bE]) t[Zr] = 2;
          else if (t[Zr] === 2) {
            e ? (t[Zr] = 1, queueMicrotask(() => ey(t))) : ey(t);
            continue;
          }
          if (t[hs] === 0 || t[ds] >= (ry(t) || 1)) return;
          let r = t[Rt][t[St]];
          if (t[_t].protocol === "https:" && t[_r] !== r.servername) {
            if (t[ds] > 0) return;
            t[_r] = r.servername, t[Ce]?.destroy(new Y1("servername changed"), () => {
              t[Ce] = null, TE(t);
            });
          }
          if (t[MA]) return;
          if (!t[Ce]) {
            Ay(t);
            return;
          }
          if (t[Ce].destroyed || t[Ce].busy(r)) return;
          !r.aborted && t[Ce].write(r) ? t[St]++ : t[Rt].splice(t[St], 1);
        }
      }
      iy.exports = FE;
    });
    var xE = C((zK, sy) => {
      "use strict";
      var Ec = class {
        constructor() {
          this.bottom = 0, this.top = 0, this.list = new Array(2048).fill(void 0), this.next = null;
        }
        isEmpty() {
          return this.top === this.bottom;
        }
        isFull() {
          return (this.top + 1 & 2047) === this.bottom;
        }
        push(e) {
          this.list[this.top] = e, this.top = this.top + 1 & 2047;
        }
        shift() {
          let e = this.list[this.bottom];
          return e === void 0 ? null : (this.list[this.bottom] = void 0, this.bottom = this.bottom + 1 & 2047, e);
        }
      };
      sy.exports = class {
        constructor() {
          this.head = this.tail = new Ec();
        }
        isEmpty() {
          return this.head.isEmpty();
        }
        push(e) {
          this.head.isFull() && (this.head = this.head.next = new Ec()), this.head.push(e);
        }
        shift() {
          let e = this.tail, r = e.shift();
          return e.isEmpty() && e.next !== null && (this.tail = e.next, e.next = null), r;
        }
      };
    });
    var ay = C((e$, oy) => {
      "use strict";
      var { kFree: uY, kConnected: gY, kPending: EY, kQueued: dY, kRunning: hY, kSize: fY } = ne(), yn = /* @__PURE__ */ Symbol("pool"), UE = class {
        constructor(e) {
          this[yn] = e;
        }
        get connected() {
          return this[yn][gY];
        }
        get free() {
          return this[yn][uY];
        }
        get pending() {
          return this[yn][EY];
        }
        get queued() {
          return this[yn][dY];
        }
        get running() {
          return this[yn][hY];
        }
        get size() {
          return this[yn][fY];
        }
      };
      oy.exports = UE;
    });
    var YE = C((t$, Cy) => {
      "use strict";
      var QY = wA(), CY = xE(), { kConnected: kE, kSize: cy, kRunning: ly, kPending: uy, kQueued: Qs, kBusy: IY, kFree: pY, kUrl: BY, kClose: mY, kDestroy: yY, kDispatch: wY } = ne(), DY = ay(), Ze = /* @__PURE__ */ Symbol("clients"), He = /* @__PURE__ */ Symbol("needDrain"), Cs = /* @__PURE__ */ Symbol("queue"), ME = /* @__PURE__ */ Symbol("closed resolve"), LE = /* @__PURE__ */ Symbol("onDrain"), gy = /* @__PURE__ */ Symbol("onConnect"), Ey = /* @__PURE__ */ Symbol("onDisconnect"), dy = /* @__PURE__ */ Symbol("onConnectionError"), vE = /* @__PURE__ */ Symbol("get dispatcher"), fy = /* @__PURE__ */ Symbol("add client"), Qy = /* @__PURE__ */ Symbol("remove client"), hy = /* @__PURE__ */ Symbol("stats"), PE = class extends QY {
        constructor() {
          super(), this[Cs] = new CY(), this[Ze] = [], this[Qs] = 0;
          let e = this;
          this[LE] = function(n, A) {
            let i = e[Cs], s = false;
            for (; !s; ) {
              let o = i.shift();
              if (!o) break;
              e[Qs]--, s = !this.dispatch(o.opts, o.handler);
            }
            this[He] = s, !this[He] && e[He] && (e[He] = false, e.emit("drain", n, [e, ...A])), e[ME] && i.isEmpty() && Promise.all(e[Ze].map((o) => o.close())).then(e[ME]);
          }, this[gy] = (r, n) => {
            e.emit("connect", r, [e, ...n]);
          }, this[Ey] = (r, n, A) => {
            e.emit("disconnect", r, [e, ...n], A);
          }, this[dy] = (r, n, A) => {
            e.emit("connectionError", r, [e, ...n], A);
          }, this[hy] = new DY(this);
        }
        get [IY]() {
          return this[He];
        }
        get [kE]() {
          return this[Ze].filter((e) => e[kE]).length;
        }
        get [pY]() {
          return this[Ze].filter((e) => e[kE] && !e[He]).length;
        }
        get [uy]() {
          let e = this[Qs];
          for (let { [uy]: r } of this[Ze]) e += r;
          return e;
        }
        get [ly]() {
          let e = 0;
          for (let { [ly]: r } of this[Ze]) e += r;
          return e;
        }
        get [cy]() {
          let e = this[Qs];
          for (let { [cy]: r } of this[Ze]) e += r;
          return e;
        }
        get stats() {
          return this[hy];
        }
        async [mY]() {
          this[Cs].isEmpty() ? await Promise.all(this[Ze].map((e) => e.close())) : await new Promise((e) => {
            this[ME] = e;
          });
        }
        async [yY](e) {
          for (; ; ) {
            let r = this[Cs].shift();
            if (!r) break;
            r.handler.onError(e);
          }
          await Promise.all(this[Ze].map((r) => r.destroy(e)));
        }
        [wY](e, r) {
          let n = this[vE]();
          return n ? n.dispatch(e, r) || (n[He] = true, this[He] = !this[vE]()) : (this[He] = true, this[Cs].push({ opts: e, handler: r }), this[Qs]++), !this[He];
        }
        [fy](e) {
          return e.on("drain", this[LE]).on("connect", this[gy]).on("disconnect", this[Ey]).on("connectionError", this[dy]), this[Ze].push(e), this[He] && queueMicrotask(() => {
            this[He] && this[LE](e[BY], [this, e]);
          }), this;
        }
        [Qy](e) {
          e.close(() => {
            let r = this[Ze].indexOf(e);
            r !== -1 && this[Ze].splice(r, 1);
          }), this[He] = this[Ze].some((r) => !r[He] && r.closed !== true && r.destroyed !== true);
        }
      };
      Cy.exports = { PoolBase: PE, kClients: Ze, kNeedDrain: He, kAddClient: fy, kRemoveClient: Qy, kGetDispatcher: vE };
    });
    var LA = C((r$, yy) => {
      "use strict";
      var { PoolBase: RY, kClients: Iy, kNeedDrain: SY, kAddClient: bY, kGetDispatcher: NY } = YE(), FY = fs(), { InvalidArgumentError: GE } = H(), py = Y(), { kUrl: By } = ne(), TY = es(), OE = /* @__PURE__ */ Symbol("options"), VE = /* @__PURE__ */ Symbol("connections"), my = /* @__PURE__ */ Symbol("factory");
      function xY(t, e) {
        return new FY(t, e);
      }
      var HE = class extends RY {
        constructor(e, { connections: r, factory: n = xY, connect: A, connectTimeout: i, tls: s, maxCachedSessions: o, socketPath: a, autoSelectFamily: c, autoSelectFamilyAttemptTimeout: l, allowH2: u, ...g } = {}) {
          if (r != null && (!Number.isFinite(r) || r < 0)) throw new GE("invalid connections");
          if (typeof n != "function") throw new GE("factory must be a function.");
          if (A != null && typeof A != "function" && typeof A != "object") throw new GE("connect must be a function or an object");
          super(), typeof A != "function" && (A = TY({ ...s, maxCachedSessions: o, allowH2: u, socketPath: a, timeout: i, ...c ? { autoSelectFamily: c, autoSelectFamilyAttemptTimeout: l } : void 0, ...A })), this[VE] = r || null, this[By] = py.parseOrigin(e), this[OE] = { ...py.deepClone(g), connect: A, allowH2: u }, this[OE].interceptors = g.interceptors ? { ...g.interceptors } : void 0, this[my] = n;
        }
        [NY]() {
          for (let e of this[Iy]) if (!e[SY]) return e;
          if (!this[VE] || this[Iy].length < this[VE]) {
            let e = this[my](this[By], this[OE]);
            return this[bY](e), e;
          }
        }
      };
      yy.exports = HE;
    });
    var by = C((n$, Sy) => {
      "use strict";
      var { BalancedPoolMissingUpstreamError: UY, InvalidArgumentError: kY } = H(), { PoolBase: MY, kClients: Le, kNeedDrain: Is, kAddClient: LY, kRemoveClient: vY, kGetDispatcher: PY } = YE(), YY = LA(), { kUrl: qE } = ne(), { parseOrigin: wy } = Y(), Dy = /* @__PURE__ */ Symbol("factory"), dc = /* @__PURE__ */ Symbol("options"), Ry = /* @__PURE__ */ Symbol("kGreatestCommonDivisor"), wn = /* @__PURE__ */ Symbol("kCurrentWeight"), Dn = /* @__PURE__ */ Symbol("kIndex"), Ct = /* @__PURE__ */ Symbol("kWeight"), hc = /* @__PURE__ */ Symbol("kMaxWeightPerServer"), fc = /* @__PURE__ */ Symbol("kErrorPenalty");
      function GY(t, e) {
        if (t === 0) return e;
        for (; e !== 0; ) {
          let r = e;
          e = t % e, t = r;
        }
        return t;
      }
      function OY(t, e) {
        return new YY(t, e);
      }
      var JE = class extends MY {
        constructor(e = [], { factory: r = OY, ...n } = {}) {
          if (typeof r != "function") throw new kY("factory must be a function.");
          super(), this[dc] = n, this[Dn] = -1, this[wn] = 0, this[hc] = this[dc].maxWeightPerServer || 100, this[fc] = this[dc].errorPenalty || 15, Array.isArray(e) || (e = [e]), this[Dy] = r;
          for (let A of e) this.addUpstream(A);
          this._updateBalancedPoolStats();
        }
        addUpstream(e) {
          let r = wy(e).origin;
          if (this[Le].find((A) => A[qE].origin === r && A.closed !== true && A.destroyed !== true)) return this;
          let n = this[Dy](r, Object.assign({}, this[dc]));
          this[LY](n), n.on("connect", () => {
            n[Ct] = Math.min(this[hc], n[Ct] + this[fc]);
          }), n.on("connectionError", () => {
            n[Ct] = Math.max(1, n[Ct] - this[fc]), this._updateBalancedPoolStats();
          }), n.on("disconnect", (...A) => {
            let i = A[2];
            i && i.code === "UND_ERR_SOCKET" && (n[Ct] = Math.max(1, n[Ct] - this[fc]), this._updateBalancedPoolStats());
          });
          for (let A of this[Le]) A[Ct] = this[hc];
          return this._updateBalancedPoolStats(), this;
        }
        _updateBalancedPoolStats() {
          let e = 0;
          for (let r = 0; r < this[Le].length; r++) e = GY(this[Le][r][Ct], e);
          this[Ry] = e;
        }
        removeUpstream(e) {
          let r = wy(e).origin, n = this[Le].find((A) => A[qE].origin === r && A.closed !== true && A.destroyed !== true);
          return n && this[vY](n), this;
        }
        get upstreams() {
          return this[Le].filter((e) => e.closed !== true && e.destroyed !== true).map((e) => e[qE].origin);
        }
        [PY]() {
          if (this[Le].length === 0) throw new UY();
          if (!this[Le].find((i) => !i[Is] && i.closed !== true && i.destroyed !== true) || this[Le].map((i) => i[Is]).reduce((i, s) => i && s, true)) return;
          let n = 0, A = this[Le].findIndex((i) => !i[Is]);
          for (; n++ < this[Le].length; ) {
            this[Dn] = (this[Dn] + 1) % this[Le].length;
            let i = this[Le][this[Dn]];
            if (i[Ct] > this[Le][A][Ct] && !i[Is] && (A = this[Dn]), this[Dn] === 0 && (this[wn] = this[wn] - this[Ry], this[wn] <= 0 && (this[wn] = this[hc])), i[Ct] >= this[wn] && !i[Is]) return i;
          }
          return this[wn] = this[Le][A][Ct], this[Dn] = A, this[Le][A];
        }
      };
      Sy.exports = JE;
    });
    var vA = C((A$, Ly) => {
      "use strict";
      var { InvalidArgumentError: WE } = H(), { kClients: Xr, kRunning: Ny, kClose: VY, kDestroy: HY, kDispatch: qY } = ne(), JY = wA(), WY = LA(), _Y = fs(), jY = Y(), Fy = /* @__PURE__ */ Symbol("onConnect"), Ty = /* @__PURE__ */ Symbol("onDisconnect"), xy = /* @__PURE__ */ Symbol("onConnectionError"), Uy = /* @__PURE__ */ Symbol("onDrain"), ky = /* @__PURE__ */ Symbol("factory"), My = /* @__PURE__ */ Symbol("options");
      function ZY(t, e) {
        return e && e.connections === 1 ? new _Y(t, e) : new WY(t, e);
      }
      var _E = class extends JY {
        constructor({ factory: e = ZY, connect: r, ...n } = {}) {
          if (typeof e != "function") throw new WE("factory must be a function.");
          if (r != null && typeof r != "function" && typeof r != "object") throw new WE("connect must be a function or an object");
          super(), r && typeof r != "function" && (r = { ...r }), this[My] = { ...jY.deepClone(n), connect: r }, this[ky] = e, this[Xr] = /* @__PURE__ */ new Map(), this[Uy] = (A, i) => {
            this.emit("drain", A, [this, ...i]);
          }, this[Fy] = (A, i) => {
            this.emit("connect", A, [this, ...i]);
          }, this[Ty] = (A, i, s) => {
            this.emit("disconnect", A, [this, ...i], s);
          }, this[xy] = (A, i, s) => {
            this.emit("connectionError", A, [this, ...i], s);
          };
        }
        get [Ny]() {
          let e = 0;
          for (let r of this[Xr].values()) e += r[Ny];
          return e;
        }
        [qY](e, r) {
          let n;
          if (e.origin && (typeof e.origin == "string" || e.origin instanceof URL)) n = String(e.origin);
          else throw new WE("opts.origin must be a non-empty string or URL.");
          let A = this[Xr].get(n);
          return A || (A = this[ky](e.origin, this[My]).on("drain", this[Uy]).on("connect", this[Fy]).on("disconnect", this[Ty]).on("connectionError", this[xy]), this[Xr].set(n, A)), A.dispatch(e, r);
        }
        async [VY]() {
          let e = [];
          for (let r of this[Xr].values()) e.push(r.close());
          this[Xr].clear(), await Promise.all(e);
        }
        async [HY](e) {
          let r = [];
          for (let n of this[Xr].values()) r.push(n.destroy(e));
          this[Xr].clear(), await Promise.all(r);
        }
      };
      Ly.exports = _E;
    });
    var XE = C((i$, Gy) => {
      "use strict";
      var { kProxy: XY, kClose: KY, kDestroy: $Y } = ne(), { URL: ps } = require("node:url"), zY = vA(), e2 = LA(), t2 = wA(), { InvalidArgumentError: Ic, RequestAbortedError: r2, SecureProxyConnectionError: n2 } = H(), vy = es(), Qc = /* @__PURE__ */ Symbol("proxy agent"), Cc = /* @__PURE__ */ Symbol("proxy client"), Bs = /* @__PURE__ */ Symbol("proxy headers"), jE = /* @__PURE__ */ Symbol("request tls settings"), Py = /* @__PURE__ */ Symbol("proxy tls settings"), Yy = /* @__PURE__ */ Symbol("connect endpoint function");
      function A2(t) {
        return t === "https:" ? 443 : 80;
      }
      function i2(t, e) {
        return new e2(t, e);
      }
      var s2 = () => {
      }, ZE = class extends t2 {
        constructor(e) {
          if (!e || typeof e == "object" && !(e instanceof ps) && !e.uri) throw new Ic("Proxy uri is mandatory");
          let { clientFactory: r = i2 } = e;
          if (typeof r != "function") throw new Ic("Proxy opts.clientFactory must be a function.");
          super();
          let n = this.#e(e), { href: A, origin: i, port: s, protocol: o, username: a, password: c, hostname: l } = n;
          if (this[XY] = { uri: A, protocol: o }, this[jE] = e.requestTls, this[Py] = e.proxyTls, this[Bs] = e.headers || {}, e.auth && e.token) throw new Ic("opts.auth cannot be used in combination with opts.token");
          e.auth ? this[Bs]["proxy-authorization"] = `Basic ${e.auth}` : e.token ? this[Bs]["proxy-authorization"] = e.token : a && c && (this[Bs]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(a)}:${decodeURIComponent(c)}`).toString("base64")}`);
          let u = vy({ ...e.proxyTls });
          this[Yy] = vy({ ...e.requestTls }), this[Cc] = r(n, { connect: u }), this[Qc] = new zY({ ...e, connect: async (g, E) => {
            let h = g.host;
            g.port || (h += `:${A2(g.protocol)}`);
            try {
              let { socket: f, statusCode: p } = await this[Cc].connect({ origin: i, port: s, path: h, signal: g.signal, headers: { ...this[Bs], host: g.host }, servername: this[Py]?.servername || l });
              if (p !== 200 && (f.on("error", s2).destroy(), E(new r2(`Proxy response (${p}) !== 200 when HTTP Tunneling`))), g.protocol !== "https:") {
                E(null, f);
                return;
              }
              let Q;
              this[jE] ? Q = this[jE].servername : Q = g.servername, this[Yy]({ ...g, servername: Q, httpSocket: f }, E);
            } catch (f) {
              f.code === "ERR_TLS_CERT_ALTNAME_INVALID" ? E(new n2(f)) : E(f);
            }
          } });
        }
        dispatch(e, r) {
          let n = o2(e.headers);
          if (a2(n), n && !("host" in n) && !("Host" in n)) {
            let { host: A } = new ps(e.origin);
            n.host = A;
          }
          return this[Qc].dispatch({ ...e, headers: n }, r);
        }
        #e(e) {
          return typeof e == "string" ? new ps(e) : e instanceof ps ? e : new ps(e.uri);
        }
        async [KY]() {
          await this[Qc].close(), await this[Cc].close();
        }
        async [$Y]() {
          await this[Qc].destroy(), await this[Cc].destroy();
        }
      };
      function o2(t) {
        if (Array.isArray(t)) {
          let e = {};
          for (let r = 0; r < t.length; r += 2) e[t[r]] = t[r + 1];
          return e;
        }
        return t;
      }
      function a2(t) {
        if (t && Object.keys(t).find((r) => r.toLowerCase() === "proxy-authorization")) throw new Ic("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
      Gy.exports = ZE;
    });
    var Jy = C((s$, qy) => {
      "use strict";
      var c2 = wA(), { kClose: l2, kDestroy: u2, kClosed: Oy, kDestroyed: Vy, kDispatch: g2, kNoProxyAgent: ms, kHttpProxyAgent: Kr, kHttpsProxyAgent: Rn } = ne(), Hy = XE(), E2 = vA(), d2 = { "http:": 80, "https:": 443 }, KE = class extends c2 {
        #e = null;
        #t = null;
        #r = null;
        constructor(e = {}) {
          super(), this.#r = e;
          let { httpProxy: r, httpsProxy: n, noProxy: A, ...i } = e;
          this[ms] = new E2(i);
          let s = r ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
          s ? this[Kr] = new Hy({ ...i, uri: s }) : this[Kr] = this[ms];
          let o = n ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
          o ? this[Rn] = new Hy({ ...i, uri: o }) : this[Rn] = this[Kr], this.#A();
        }
        [g2](e, r) {
          let n = new URL(e.origin);
          return this.#n(n).dispatch(e, r);
        }
        async [l2]() {
          await this[ms].close(), this[Kr][Oy] || await this[Kr].close(), this[Rn][Oy] || await this[Rn].close();
        }
        async [u2](e) {
          await this[ms].destroy(e), this[Kr][Vy] || await this[Kr].destroy(e), this[Rn][Vy] || await this[Rn].destroy(e);
        }
        #n(e) {
          let { protocol: r, host: n, port: A } = e;
          return n = n.replace(/:\d*$/, "").toLowerCase(), A = Number.parseInt(A, 10) || d2[r] || 0, this.#i(n, A) ? r === "https:" ? this[Rn] : this[Kr] : this[ms];
        }
        #i(e, r) {
          if (this.#a && this.#A(), this.#t.length === 0) return true;
          if (this.#e === "*") return false;
          for (let n = 0; n < this.#t.length; n++) {
            let A = this.#t[n];
            if (!(A.port && A.port !== r)) {
              if (/^[.*]/.test(A.hostname)) {
                if (e.endsWith(A.hostname.replace(/^\*/, ""))) return false;
              } else if (e === A.hostname) return false;
            }
          }
          return true;
        }
        #A() {
          let e = this.#r.noProxy ?? this.#s, r = e.split(/[,\s]/), n = [];
          for (let A = 0; A < r.length; A++) {
            let i = r[A];
            if (!i) continue;
            let s = i.match(/^(.+):(\d+)$/);
            n.push({ hostname: (s ? s[1] : i).toLowerCase(), port: s ? Number.parseInt(s[2], 10) : 0 });
          }
          this.#e = e, this.#t = n;
        }
        get #a() {
          return this.#r.noProxy !== void 0 ? false : this.#e !== this.#s;
        }
        get #s() {
          return process.env.no_proxy ?? process.env.NO_PROXY ?? "";
        }
      };
      qy.exports = KE;
    });
    var pc = C((o$, Zy) => {
      "use strict";
      var PA = require("node:assert"), { kRetryHandlerDefaultRetry: Wy } = ne(), { RequestRetryError: ys } = H(), h2 = va(), { isDisturbed: _y, parseRangeHeader: jy, wrapRequestBody: f2 } = Y();
      function Q2(t) {
        let e = Date.now();
        return new Date(t).getTime() - e;
      }
      var $E = class t {
        constructor(e, { dispatch: r, handler: n }) {
          let { retryOptions: A, ...i } = e, { retry: s, maxRetries: o, maxTimeout: a, minTimeout: c, timeoutFactor: l, methods: u, errorCodes: g, retryAfter: E, statusCodes: h } = A ?? {};
          this.dispatch = r, this.handler = h2.wrap(n), this.opts = { ...i, body: f2(e.body) }, this.retryOpts = { retry: s ?? t[Wy], retryAfter: E ?? true, maxTimeout: a ?? 30 * 1e3, minTimeout: c ?? 500, timeoutFactor: l ?? 2, maxRetries: o ?? 5, methods: u ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"], statusCodes: h ?? [500, 502, 503, 504, 429], errorCodes: g ?? ["ECONNRESET", "ECONNREFUSED", "ENOTFOUND", "ENETDOWN", "ENETUNREACH", "EHOSTDOWN", "EHOSTUNREACH", "EPIPE", "UND_ERR_SOCKET"] }, this.retryCount = 0, this.retryCountCheckpoint = 0, this.headersSent = false, this.start = 0, this.end = null, this.etag = null;
        }
        onRequestStart(e, r) {
          this.headersSent || this.handler.onRequestStart?.(e, r);
        }
        onRequestUpgrade(e, r, n, A) {
          this.handler.onRequestUpgrade?.(e, r, n, A);
        }
        static [Wy](e, { state: r, opts: n }, A) {
          let { statusCode: i, code: s, headers: o } = e, { method: a, retryOptions: c } = n, { maxRetries: l, minTimeout: u, maxTimeout: g, timeoutFactor: E, statusCodes: h, errorCodes: f, methods: p } = c, { counter: Q } = r;
          if (s && s !== "UND_ERR_REQ_RETRY" && !f.includes(s)) {
            A(e);
            return;
          }
          if (Array.isArray(p) && !p.includes(a)) {
            A(e);
            return;
          }
          if (i != null && Array.isArray(h) && !h.includes(i)) {
            A(e);
            return;
          }
          if (Q > l) {
            A(e);
            return;
          }
          let I = o?.["retry-after"];
          I && (I = Number(I), I = Number.isNaN(I) ? Q2(I) : I * 1e3);
          let B = I > 0 ? Math.min(I, g) : Math.min(u * E ** (Q - 1), g);
          setTimeout(() => A(null), B);
        }
        onResponseStart(e, r, n, A) {
          if (this.retryCount += 1, r >= 300) if (this.retryOpts.statusCodes.includes(r) === false) {
            this.headersSent = true, this.handler.onResponseStart?.(e, r, n, A);
            return;
          } else throw new ys("Request failed", r, { headers: n, data: { count: this.retryCount } });
          if (this.headersSent) {
            if (r !== 206 && (this.start > 0 || r !== 200)) throw new ys("server does not support the range header and the payload was partially consumed", r, { headers: n, data: { count: this.retryCount } });
            let i = jy(n["content-range"]);
            if (!i) throw new ys("Content-Range mismatch", r, { headers: n, data: { count: this.retryCount } });
            if (this.etag != null && this.etag !== n.etag) throw new ys("ETag mismatch", r, { headers: n, data: { count: this.retryCount } });
            let { start: s, size: o, end: a = o ? o - 1 : null } = i;
            PA(this.start === s, "content-range mismatch"), PA(this.end == null || this.end === a, "content-range mismatch");
            return;
          }
          if (this.end == null) {
            if (r === 206) {
              let i = jy(n["content-range"]);
              if (i == null) {
                this.headersSent = true, this.handler.onResponseStart?.(e, r, n, A);
                return;
              }
              let { start: s, size: o, end: a = o ? o - 1 : null } = i;
              PA(s != null && Number.isFinite(s), "content-range mismatch"), PA(a != null && Number.isFinite(a), "invalid content-length"), this.start = s, this.end = a;
            }
            if (this.end == null) {
              let i = n["content-length"];
              this.end = i != null ? Number(i) - 1 : null;
            }
            PA(Number.isFinite(this.start)), PA(this.end == null || Number.isFinite(this.end), "invalid content-length"), this.resume = true, this.etag = n.etag != null ? n.etag : null, this.etag != null && this.etag[0] === "W" && this.etag[1] === "/" && (this.etag = null), this.headersSent = true, this.handler.onResponseStart?.(e, r, n, A);
          } else throw new ys("Request failed", r, { headers: n, data: { count: this.retryCount } });
        }
        onResponseData(e, r) {
          this.start += r.length, this.handler.onResponseData?.(e, r);
        }
        onResponseEnd(e, r) {
          return this.retryCount = 0, this.handler.onResponseEnd?.(e, r);
        }
        onResponseError(e, r) {
          if (e?.aborted || _y(this.opts.body)) {
            this.handler.onResponseError?.(e, r);
            return;
          }
          this.retryCount - this.retryCountCheckpoint > 0 ? this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint) : this.retryCount += 1, this.retryOpts.retry(r, { state: { counter: this.retryCount }, opts: { retryOptions: this.retryOpts, ...this.opts } }, n.bind(this));
          function n(A) {
            if (A != null || e?.aborted || _y(this.opts.body)) return this.handler.onResponseError?.(e, A);
            if (this.start !== 0) {
              let i = { range: `bytes=${this.start}-${this.end ?? ""}` };
              this.etag != null && (i["if-match"] = this.etag), this.opts = { ...this.opts, headers: { ...this.opts.headers, ...i } };
            }
            try {
              this.retryCountCheckpoint = this.retryCount, this.dispatch(this.opts, this);
            } catch (i) {
              this.handler.onResponseError?.(e, i);
            }
          }
        }
      };
      Zy.exports = $E;
    });
    var Ky = C((a$, Xy) => {
      "use strict";
      var C2 = $i(), I2 = pc(), zE = class extends C2 {
        #e = null;
        #t = null;
        constructor(e, r = {}) {
          super(r), this.#e = e, this.#t = r;
        }
        dispatch(e, r) {
          let n = new I2({ ...e, retryOptions: this.#t }, { dispatch: this.#e.dispatch.bind(this.#e), handler: r });
          return this.#e.dispatch(e, n);
        }
        close() {
          return this.#e.close();
        }
        destroy() {
          return this.#e.destroy();
        }
      };
      Xy.exports = zE;
    });
    var sw = C((c$, iw) => {
      "use strict";
      var tw = require("node:assert"), { Readable: p2 } = require("node:stream"), { RequestAbortedError: rw, NotSupportedError: B2, InvalidArgumentError: m2, AbortError: ed } = H(), nw = Y(), { ReadableStreamFrom: y2 } = Y(), rt = /* @__PURE__ */ Symbol("kConsume"), Bc = /* @__PURE__ */ Symbol("kReading"), Sn = /* @__PURE__ */ Symbol("kBody"), $y = /* @__PURE__ */ Symbol("kAbort"), Aw = /* @__PURE__ */ Symbol("kContentType"), td = /* @__PURE__ */ Symbol("kContentLength"), rd = /* @__PURE__ */ Symbol("kUsed"), mc = /* @__PURE__ */ Symbol("kBytesRead"), w2 = () => {
      }, nd = class extends p2 {
        constructor({ resume: e, abort: r, contentType: n = "", contentLength: A, highWaterMark: i = 64 * 1024 }) {
          super({ autoDestroy: true, read: e, highWaterMark: i }), this._readableState.dataEmitted = false, this[$y] = r, this[rt] = null, this[mc] = 0, this[Sn] = null, this[rd] = false, this[Aw] = n, this[td] = Number.isFinite(A) ? A : null, this[Bc] = false;
        }
        _destroy(e, r) {
          !e && !this._readableState.endEmitted && (e = new rw()), e && this[$y](), this[rd] ? r(e) : setImmediate(() => {
            r(e);
          });
        }
        on(e, r) {
          return (e === "data" || e === "readable") && (this[Bc] = true, this[rd] = true), super.on(e, r);
        }
        addListener(e, r) {
          return this.on(e, r);
        }
        off(e, r) {
          let n = super.off(e, r);
          return (e === "data" || e === "readable") && (this[Bc] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0), n;
        }
        removeListener(e, r) {
          return this.off(e, r);
        }
        push(e) {
          return this[mc] += e ? e.length : 0, this[rt] && e !== null ? (id(this[rt], e), this[Bc] ? super.push(e) : true) : super.push(e);
        }
        text() {
          return ws(this, "text");
        }
        json() {
          return ws(this, "json");
        }
        blob() {
          return ws(this, "blob");
        }
        bytes() {
          return ws(this, "bytes");
        }
        arrayBuffer() {
          return ws(this, "arrayBuffer");
        }
        async formData() {
          throw new B2();
        }
        get bodyUsed() {
          return nw.isDisturbed(this);
        }
        get body() {
          return this[Sn] || (this[Sn] = y2(this), this[rt] && (this[Sn].getReader(), tw(this[Sn].locked))), this[Sn];
        }
        async dump(e) {
          let r = e?.signal;
          if (r != null && (typeof r != "object" || !("aborted" in r))) throw new m2("signal must be an AbortSignal");
          let n = e?.limit && Number.isFinite(e.limit) ? e.limit : 128 * 1024;
          return r?.throwIfAborted(), this._readableState.closeEmitted ? null : await new Promise((A, i) => {
            if ((this[td] && this[td] > n || this[mc] > n) && this.destroy(new ed()), r) {
              let s = () => {
                this.destroy(r.reason ?? new ed());
              };
              r.addEventListener("abort", s), this.on("close", function() {
                r.removeEventListener("abort", s), r.aborted ? i(r.reason ?? new ed()) : A(null);
              });
            } else this.on("close", A);
            this.on("error", w2).on("data", () => {
              this[mc] > n && this.destroy();
            }).resume();
          });
        }
        setEncoding(e) {
          return Buffer.isEncoding(e) && (this._readableState.encoding = e), this;
        }
      };
      function D2(t) {
        return t[Sn]?.locked === true || t[rt] !== null;
      }
      function R2(t) {
        return nw.isDisturbed(t) || D2(t);
      }
      function ws(t, e) {
        return tw(!t[rt]), new Promise((r, n) => {
          if (R2(t)) {
            let A = t._readableState;
            A.destroyed && A.closeEmitted === false ? t.on("error", (i) => {
              n(i);
            }).on("close", () => {
              n(new TypeError("unusable"));
            }) : n(A.errored ?? new TypeError("unusable"));
          } else queueMicrotask(() => {
            t[rt] = { type: e, stream: t, resolve: r, reject: n, length: 0, body: [] }, t.on("error", function(A) {
              sd(this[rt], A);
            }).on("close", function() {
              this[rt].body !== null && sd(this[rt], new rw());
            }), S2(t[rt]);
          });
        });
      }
      function S2(t) {
        if (t.body === null) return;
        let { _readableState: e } = t.stream;
        if (e.bufferIndex) {
          let r = e.bufferIndex, n = e.buffer.length;
          for (let A = r; A < n; A++) id(t, e.buffer[A]);
        } else for (let r of e.buffer) id(t, r);
        for (e.endEmitted ? ew(this[rt], this._readableState.encoding) : t.stream.on("end", function() {
          ew(this[rt], this._readableState.encoding);
        }), t.stream.resume(); t.stream.read() != null; ) ;
      }
      function Ad(t, e, r) {
        if (t.length === 0 || e === 0) return "";
        let n = t.length === 1 ? t[0] : Buffer.concat(t, e), A = n.length, i = A > 2 && n[0] === 239 && n[1] === 187 && n[2] === 191 ? 3 : 0;
        return !r || r === "utf8" || r === "utf-8" ? n.utf8Slice(i, A) : n.subarray(i, A).toString(r);
      }
      function zy(t, e) {
        if (t.length === 0 || e === 0) return new Uint8Array(0);
        if (t.length === 1) return new Uint8Array(t[0]);
        let r = new Uint8Array(Buffer.allocUnsafeSlow(e).buffer), n = 0;
        for (let A = 0; A < t.length; ++A) {
          let i = t[A];
          r.set(i, n), n += i.length;
        }
        return r;
      }
      function ew(t, e) {
        let { type: r, body: n, resolve: A, stream: i, length: s } = t;
        try {
          r === "text" ? A(Ad(n, s, e)) : r === "json" ? A(JSON.parse(Ad(n, s, e))) : r === "arrayBuffer" ? A(zy(n, s).buffer) : r === "blob" ? A(new Blob(n, { type: i[Aw] })) : r === "bytes" && A(zy(n, s)), sd(t);
        } catch (o) {
          i.destroy(o);
        }
      }
      function id(t, e) {
        t.length += e.length, t.body.push(e);
      }
      function sd(t, e) {
        t.body !== null && (e ? t.reject(e) : t.resolve(), t.type = null, t.stream = null, t.resolve = null, t.reject = null, t.length = 0, t.body = null);
      }
      iw.exports = { Readable: nd, chunksDecode: Ad };
    });
    var cw = C((l$, od) => {
      "use strict";
      var b2 = require("node:assert"), { AsyncResource: N2 } = require("node:async_hooks"), { Readable: F2 } = sw(), { InvalidArgumentError: YA, RequestAbortedError: ow } = H(), bt = Y();
      function yc() {
      }
      var wc = class extends N2 {
        constructor(e, r) {
          if (!e || typeof e != "object") throw new YA("invalid opts");
          let { signal: n, method: A, opaque: i, body: s, onInfo: o, responseHeaders: a, highWaterMark: c } = e;
          try {
            if (typeof r != "function") throw new YA("invalid callback");
            if (c && (typeof c != "number" || c < 0)) throw new YA("invalid highWaterMark");
            if (n && typeof n.on != "function" && typeof n.addEventListener != "function") throw new YA("signal must be an EventEmitter or EventTarget");
            if (A === "CONNECT") throw new YA("invalid method");
            if (o && typeof o != "function") throw new YA("invalid onInfo callback");
            super("UNDICI_REQUEST");
          } catch (l) {
            throw bt.isStream(s) && bt.destroy(s.on("error", yc), l), l;
          }
          this.method = A, this.responseHeaders = a || null, this.opaque = i || null, this.callback = r, this.res = null, this.abort = null, this.body = s, this.trailers = {}, this.context = null, this.onInfo = o || null, this.highWaterMark = c, this.reason = null, this.removeAbortListener = null, n?.aborted ? this.reason = n.reason ?? new ow() : n && (this.removeAbortListener = bt.addAbortListener(n, () => {
            this.reason = n.reason ?? new ow(), this.res ? bt.destroy(this.res.on("error", yc), this.reason) : this.abort && this.abort(this.reason);
          }));
        }
        onConnect(e, r) {
          if (this.reason) {
            e(this.reason);
            return;
          }
          b2(this.callback), this.abort = e, this.context = r;
        }
        onHeaders(e, r, n, A) {
          let { callback: i, opaque: s, abort: o, context: a, responseHeaders: c, highWaterMark: l } = this, u = c === "raw" ? bt.parseRawHeaders(r) : bt.parseHeaders(r);
          if (e < 200) {
            this.onInfo && this.onInfo({ statusCode: e, headers: u });
            return;
          }
          let g = c === "raw" ? bt.parseHeaders(r) : u, E = g["content-type"], h = g["content-length"], f = new F2({ resume: n, abort: o, contentType: E, contentLength: this.method !== "HEAD" && h ? Number(h) : null, highWaterMark: l });
          this.removeAbortListener && (f.on("close", this.removeAbortListener), this.removeAbortListener = null), this.callback = null, this.res = f, i !== null && this.runInAsyncScope(i, null, null, { statusCode: e, headers: u, trailers: this.trailers, opaque: s, body: f, context: a });
        }
        onData(e) {
          return this.res.push(e);
        }
        onComplete(e) {
          bt.parseHeaders(e, this.trailers), this.res.push(null);
        }
        onError(e) {
          let { res: r, callback: n, body: A, opaque: i } = this;
          n && (this.callback = null, queueMicrotask(() => {
            this.runInAsyncScope(n, null, e, { opaque: i });
          })), r && (this.res = null, queueMicrotask(() => {
            bt.destroy(r.on("error", yc), e);
          })), A && (this.body = null, bt.isStream(A) && (A.on("error", yc), bt.destroy(A, e))), this.removeAbortListener && (this.removeAbortListener(), this.removeAbortListener = null);
        }
      };
      function aw(t, e) {
        if (e === void 0) return new Promise((r, n) => {
          aw.call(this, t, (A, i) => A ? n(A) : r(i));
        });
        try {
          let r = new wc(t, e);
          this.dispatch(t, r);
        } catch (r) {
          if (typeof e != "function") throw r;
          let n = t?.opaque;
          queueMicrotask(() => e(r, { opaque: n }));
        }
      }
      od.exports = aw;
      od.exports.RequestHandler = wc;
    });
    var Ds = C((u$, gw) => {
      "use strict";
      var { addAbortListener: T2 } = Y(), { RequestAbortedError: x2 } = H(), GA = /* @__PURE__ */ Symbol("kListener"), jt = /* @__PURE__ */ Symbol("kSignal");
      function lw(t) {
        t.abort ? t.abort(t[jt]?.reason) : t.reason = t[jt]?.reason ?? new x2(), uw(t);
      }
      function U2(t, e) {
        if (t.reason = null, t[jt] = null, t[GA] = null, !!e) {
          if (e.aborted) {
            lw(t);
            return;
          }
          t[jt] = e, t[GA] = () => {
            lw(t);
          }, T2(t[jt], t[GA]);
        }
      }
      function uw(t) {
        t[jt] && ("removeEventListener" in t[jt] ? t[jt].removeEventListener("abort", t[GA]) : t[jt].removeListener("abort", t[GA]), t[jt] = null, t[GA] = null);
      }
      gw.exports = { addSignal: U2, removeSignal: uw };
    });
    var fw = C((g$, hw) => {
      "use strict";
      var k2 = require("node:assert"), { finished: M2 } = require("node:stream"), { AsyncResource: L2 } = require("node:async_hooks"), { InvalidArgumentError: OA, InvalidReturnValueError: v2 } = H(), pr = Y(), { addSignal: P2, removeSignal: Ew } = Ds();
      function Y2() {
      }
      var ad = class extends L2 {
        constructor(e, r, n) {
          if (!e || typeof e != "object") throw new OA("invalid opts");
          let { signal: A, method: i, opaque: s, body: o, onInfo: a, responseHeaders: c } = e;
          try {
            if (typeof n != "function") throw new OA("invalid callback");
            if (typeof r != "function") throw new OA("invalid factory");
            if (A && typeof A.on != "function" && typeof A.addEventListener != "function") throw new OA("signal must be an EventEmitter or EventTarget");
            if (i === "CONNECT") throw new OA("invalid method");
            if (a && typeof a != "function") throw new OA("invalid onInfo callback");
            super("UNDICI_STREAM");
          } catch (l) {
            throw pr.isStream(o) && pr.destroy(o.on("error", Y2), l), l;
          }
          this.responseHeaders = c || null, this.opaque = s || null, this.factory = r, this.callback = n, this.res = null, this.abort = null, this.context = null, this.trailers = null, this.body = o, this.onInfo = a || null, pr.isStream(o) && o.on("error", (l) => {
            this.onError(l);
          }), P2(this, A);
        }
        onConnect(e, r) {
          if (this.reason) {
            e(this.reason);
            return;
          }
          k2(this.callback), this.abort = e, this.context = r;
        }
        onHeaders(e, r, n, A) {
          let { factory: i, opaque: s, context: o, responseHeaders: a } = this, c = a === "raw" ? pr.parseRawHeaders(r) : pr.parseHeaders(r);
          if (e < 200) {
            this.onInfo && this.onInfo({ statusCode: e, headers: c });
            return;
          }
          if (this.factory = null, i === null) return;
          let l = this.runInAsyncScope(i, null, { statusCode: e, headers: c, opaque: s, context: o });
          if (!l || typeof l.write != "function" || typeof l.end != "function" || typeof l.on != "function") throw new v2("expected Writable");
          return M2(l, { readable: false }, (g) => {
            let { callback: E, res: h, opaque: f, trailers: p, abort: Q } = this;
            this.res = null, (g || !h.readable) && pr.destroy(h, g), this.callback = null, this.runInAsyncScope(E, null, g || null, { opaque: f, trailers: p }), g && Q();
          }), l.on("drain", n), this.res = l, (l.writableNeedDrain !== void 0 ? l.writableNeedDrain : l._writableState?.needDrain) !== true;
        }
        onData(e) {
          let { res: r } = this;
          return r ? r.write(e) : true;
        }
        onComplete(e) {
          let { res: r } = this;
          Ew(this), r && (this.trailers = pr.parseHeaders(e), r.end());
        }
        onError(e) {
          let { res: r, callback: n, opaque: A, body: i } = this;
          Ew(this), this.factory = null, r ? (this.res = null, pr.destroy(r, e)) : n && (this.callback = null, queueMicrotask(() => {
            this.runInAsyncScope(n, null, e, { opaque: A });
          })), i && (this.body = null, pr.destroy(i, e));
        }
      };
      function dw(t, e, r) {
        if (r === void 0) return new Promise((n, A) => {
          dw.call(this, t, e, (i, s) => i ? A(i) : n(s));
        });
        try {
          let n = new ad(t, e, r);
          this.dispatch(t, n);
        } catch (n) {
          if (typeof r != "function") throw n;
          let A = t?.opaque;
          queueMicrotask(() => r(n, { opaque: A }));
        }
      }
      hw.exports = dw;
    });
    var pw = C((E$, Iw) => {
      "use strict";
      var { Readable: Cw, Duplex: G2, PassThrough: O2 } = require("node:stream"), V2 = require("node:assert"), { AsyncResource: H2 } = require("node:async_hooks"), { InvalidArgumentError: Rs, InvalidReturnValueError: q2, RequestAbortedError: cd } = H(), Zt = Y(), { addSignal: J2, removeSignal: W2 } = Ds();
      function Qw() {
      }
      var VA = /* @__PURE__ */ Symbol("resume"), ld = class extends Cw {
        constructor() {
          super({ autoDestroy: true }), this[VA] = null;
        }
        _read() {
          let { [VA]: e } = this;
          e && (this[VA] = null, e());
        }
        _destroy(e, r) {
          this._read(), r(e);
        }
      }, ud = class extends Cw {
        constructor(e) {
          super({ autoDestroy: true }), this[VA] = e;
        }
        _read() {
          this[VA]();
        }
        _destroy(e, r) {
          !e && !this._readableState.endEmitted && (e = new cd()), r(e);
        }
      }, gd = class extends H2 {
        constructor(e, r) {
          if (!e || typeof e != "object") throw new Rs("invalid opts");
          if (typeof r != "function") throw new Rs("invalid handler");
          let { signal: n, method: A, opaque: i, onInfo: s, responseHeaders: o } = e;
          if (n && typeof n.on != "function" && typeof n.addEventListener != "function") throw new Rs("signal must be an EventEmitter or EventTarget");
          if (A === "CONNECT") throw new Rs("invalid method");
          if (s && typeof s != "function") throw new Rs("invalid onInfo callback");
          super("UNDICI_PIPELINE"), this.opaque = i || null, this.responseHeaders = o || null, this.handler = r, this.abort = null, this.context = null, this.onInfo = s || null, this.req = new ld().on("error", Qw), this.ret = new G2({ readableObjectMode: e.objectMode, autoDestroy: true, read: () => {
            let { body: a } = this;
            a?.resume && a.resume();
          }, write: (a, c, l) => {
            let { req: u } = this;
            u.push(a, c) || u._readableState.destroyed ? l() : u[VA] = l;
          }, destroy: (a, c) => {
            let { body: l, req: u, res: g, ret: E, abort: h } = this;
            !a && !E._readableState.endEmitted && (a = new cd()), h && a && h(), Zt.destroy(l, a), Zt.destroy(u, a), Zt.destroy(g, a), W2(this), c(a);
          } }).on("prefinish", () => {
            let { req: a } = this;
            a.push(null);
          }), this.res = null, J2(this, n);
        }
        onConnect(e, r) {
          let { res: n } = this;
          if (this.reason) {
            e(this.reason);
            return;
          }
          V2(!n, "pipeline cannot be retried"), this.abort = e, this.context = r;
        }
        onHeaders(e, r, n) {
          let { opaque: A, handler: i, context: s } = this;
          if (e < 200) {
            if (this.onInfo) {
              let a = this.responseHeaders === "raw" ? Zt.parseRawHeaders(r) : Zt.parseHeaders(r);
              this.onInfo({ statusCode: e, headers: a });
            }
            return;
          }
          this.res = new ud(n);
          let o;
          try {
            this.handler = null;
            let a = this.responseHeaders === "raw" ? Zt.parseRawHeaders(r) : Zt.parseHeaders(r);
            o = this.runInAsyncScope(i, null, { statusCode: e, headers: a, opaque: A, body: this.res, context: s });
          } catch (a) {
            throw this.res.on("error", Qw), a;
          }
          if (!o || typeof o.on != "function") throw new q2("expected Readable");
          o.on("data", (a) => {
            let { ret: c, body: l } = this;
            !c.push(a) && l.pause && l.pause();
          }).on("error", (a) => {
            let { ret: c } = this;
            Zt.destroy(c, a);
          }).on("end", () => {
            let { ret: a } = this;
            a.push(null);
          }).on("close", () => {
            let { ret: a } = this;
            a._readableState.ended || Zt.destroy(a, new cd());
          }), this.body = o;
        }
        onData(e) {
          let { res: r } = this;
          return r.push(e);
        }
        onComplete(e) {
          let { res: r } = this;
          r.push(null);
        }
        onError(e) {
          let { ret: r } = this;
          this.handler = null, Zt.destroy(r, e);
        }
      };
      function _2(t, e) {
        try {
          let r = new gd(t, e);
          return this.dispatch({ ...t, body: r.req }, r), r.ret;
        } catch (r) {
          return new O2().destroy(r);
        }
      }
      Iw.exports = _2;
    });
    var Rw = C((d$, Dw) => {
      "use strict";
      var { InvalidArgumentError: Ed, SocketError: j2 } = H(), { AsyncResource: Z2 } = require("node:async_hooks"), Bw = require("node:assert"), mw = Y(), { addSignal: X2, removeSignal: yw } = Ds(), dd = class extends Z2 {
        constructor(e, r) {
          if (!e || typeof e != "object") throw new Ed("invalid opts");
          if (typeof r != "function") throw new Ed("invalid callback");
          let { signal: n, opaque: A, responseHeaders: i } = e;
          if (n && typeof n.on != "function" && typeof n.addEventListener != "function") throw new Ed("signal must be an EventEmitter or EventTarget");
          super("UNDICI_UPGRADE"), this.responseHeaders = i || null, this.opaque = A || null, this.callback = r, this.abort = null, this.context = null, X2(this, n);
        }
        onConnect(e, r) {
          if (this.reason) {
            e(this.reason);
            return;
          }
          Bw(this.callback), this.abort = e, this.context = null;
        }
        onHeaders() {
          throw new j2("bad upgrade", null);
        }
        onUpgrade(e, r, n) {
          Bw(e === 101);
          let { callback: A, opaque: i, context: s } = this;
          yw(this), this.callback = null;
          let o = this.responseHeaders === "raw" ? mw.parseRawHeaders(r) : mw.parseHeaders(r);
          this.runInAsyncScope(A, null, null, { headers: o, socket: n, opaque: i, context: s });
        }
        onError(e) {
          let { callback: r, opaque: n } = this;
          yw(this), r && (this.callback = null, queueMicrotask(() => {
            this.runInAsyncScope(r, null, e, { opaque: n });
          }));
        }
      };
      function ww(t, e) {
        if (e === void 0) return new Promise((r, n) => {
          ww.call(this, t, (A, i) => A ? n(A) : r(i));
        });
        try {
          let r = new dd(t, e), n = { ...t, method: t.method || "GET", upgrade: t.protocol || "Websocket" };
          this.dispatch(n, r);
        } catch (r) {
          if (typeof e != "function") throw r;
          let n = t?.opaque;
          queueMicrotask(() => e(r, { opaque: n }));
        }
      }
      Dw.exports = ww;
    });
    var Tw = C((h$, Fw) => {
      "use strict";
      var K2 = require("node:assert"), { AsyncResource: $2 } = require("node:async_hooks"), { InvalidArgumentError: hd, SocketError: z22 } = H(), Sw = Y(), { addSignal: eG, removeSignal: bw } = Ds(), fd = class extends $2 {
        constructor(e, r) {
          if (!e || typeof e != "object") throw new hd("invalid opts");
          if (typeof r != "function") throw new hd("invalid callback");
          let { signal: n, opaque: A, responseHeaders: i } = e;
          if (n && typeof n.on != "function" && typeof n.addEventListener != "function") throw new hd("signal must be an EventEmitter or EventTarget");
          super("UNDICI_CONNECT"), this.opaque = A || null, this.responseHeaders = i || null, this.callback = r, this.abort = null, eG(this, n);
        }
        onConnect(e, r) {
          if (this.reason) {
            e(this.reason);
            return;
          }
          K2(this.callback), this.abort = e, this.context = r;
        }
        onHeaders() {
          throw new z22("bad connect", null);
        }
        onUpgrade(e, r, n) {
          let { callback: A, opaque: i, context: s } = this;
          bw(this), this.callback = null;
          let o = r;
          o != null && (o = this.responseHeaders === "raw" ? Sw.parseRawHeaders(r) : Sw.parseHeaders(r)), this.runInAsyncScope(A, null, null, { statusCode: e, headers: o, socket: n, opaque: i, context: s });
        }
        onError(e) {
          let { callback: r, opaque: n } = this;
          bw(this), r && (this.callback = null, queueMicrotask(() => {
            this.runInAsyncScope(r, null, e, { opaque: n });
          }));
        }
      };
      function Nw(t, e) {
        if (e === void 0) return new Promise((r, n) => {
          Nw.call(this, t, (A, i) => A ? n(A) : r(i));
        });
        try {
          let r = new fd(t, e), n = { ...t, method: "CONNECT" };
          this.dispatch(n, r);
        } catch (r) {
          if (typeof e != "function") throw r;
          let n = t?.opaque;
          queueMicrotask(() => e(r, { opaque: n }));
        }
      }
      Fw.exports = Nw;
    });
    var xw = C((f$, HA) => {
      "use strict";
      HA.exports.request = cw();
      HA.exports.stream = fw();
      HA.exports.pipeline = pw();
      HA.exports.upgrade = Rw();
      HA.exports.connect = Tw();
    });
    var Cd = C((Q$, Uw) => {
      "use strict";
      var { UndiciError: tG } = H(), Qd = class extends tG {
        constructor(e) {
          super(e), this.name = "MockNotMatchedError", this.message = e || "The request does not match any registered mock dispatches", this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
        }
      };
      Uw.exports = { MockNotMatchedError: Qd };
    });
    var qA = C((C$, kw) => {
      "use strict";
      kw.exports = { kAgent: /* @__PURE__ */ Symbol("agent"), kOptions: /* @__PURE__ */ Symbol("options"), kFactory: /* @__PURE__ */ Symbol("factory"), kDispatches: /* @__PURE__ */ Symbol("dispatches"), kDispatchKey: /* @__PURE__ */ Symbol("dispatch key"), kDefaultHeaders: /* @__PURE__ */ Symbol("default headers"), kDefaultTrailers: /* @__PURE__ */ Symbol("default trailers"), kContentLength: /* @__PURE__ */ Symbol("content length"), kMockAgent: /* @__PURE__ */ Symbol("mock agent"), kMockAgentSet: /* @__PURE__ */ Symbol("mock agent set"), kMockAgentGet: /* @__PURE__ */ Symbol("mock agent get"), kMockDispatch: /* @__PURE__ */ Symbol("mock dispatch"), kClose: /* @__PURE__ */ Symbol("close"), kOriginalClose: /* @__PURE__ */ Symbol("original agent close"), kOriginalDispatch: /* @__PURE__ */ Symbol("original dispatch"), kOrigin: /* @__PURE__ */ Symbol("origin"), kIsMockActive: /* @__PURE__ */ Symbol("is mock active"), kNetConnect: /* @__PURE__ */ Symbol("net connect"), kGetNetConnect: /* @__PURE__ */ Symbol("get net connect"), kConnected: /* @__PURE__ */ Symbol("connected"), kIgnoreTrailingSlash: /* @__PURE__ */ Symbol("ignore trailing slash") };
    });
    var Ss = C((I$, Jw) => {
      "use strict";
      var { MockNotMatchedError: bn } = Cd(), { kDispatches: Dc, kMockAgent: rG, kOriginalDispatch: nG, kOrigin: AG, kGetNetConnect: iG } = qA(), { serializePathWithQuery: sG } = Y(), { STATUS_CODES: oG } = require("node:http"), { types: { isPromise: aG } } = require("node:util");
      function Xt(t, e) {
        return typeof t == "string" ? t === e : t instanceof RegExp ? t.test(e) : typeof t == "function" ? t(e) === true : false;
      }
      function Lw(t) {
        return Object.fromEntries(Object.entries(t).map(([e, r]) => [e.toLocaleLowerCase(), r]));
      }
      function vw(t, e) {
        if (Array.isArray(t)) {
          for (let r = 0; r < t.length; r += 2) if (t[r].toLocaleLowerCase() === e.toLocaleLowerCase()) return t[r + 1];
          return;
        } else return typeof t.get == "function" ? t.get(e) : Lw(t)[e.toLocaleLowerCase()];
      }
      function md(t) {
        let e = t.slice(), r = [];
        for (let n = 0; n < e.length; n += 2) r.push([e[n], e[n + 1]]);
        return Object.fromEntries(r);
      }
      function Pw(t, e) {
        if (typeof t.headers == "function") return Array.isArray(e) && (e = md(e)), t.headers(e ? Lw(e) : {});
        if (typeof t.headers > "u") return true;
        if (typeof e != "object" || typeof t.headers != "object") return false;
        for (let [r, n] of Object.entries(t.headers)) {
          let A = vw(e, r);
          if (!Xt(n, A)) return false;
        }
        return true;
      }
      function Id(t) {
        if (typeof t != "string") return t;
        let e = t.split("?");
        if (e.length !== 2) return t;
        let r = new URLSearchParams(e.pop());
        return r.sort(), [...e, r.toString()].join("?");
      }
      function cG(t, { path: e, method: r, body: n, headers: A }) {
        let i = Xt(t.path, e), s = Xt(t.method, r), o = typeof t.body < "u" ? Xt(t.body, n) : true, a = Pw(t, A);
        return i && s && o && a;
      }
      function Yw(t) {
        return Buffer.isBuffer(t) || t instanceof Uint8Array || t instanceof ArrayBuffer ? t : typeof t == "object" ? JSON.stringify(t) : t ? t.toString() : "";
      }
      function Gw(t, e) {
        let r = e.query ? sG(e.path, e.query) : e.path, n = typeof r == "string" ? Id(r) : r, A = Mw(n), i = t.filter(({ consumed: s }) => !s).filter(({ path: s, ignoreTrailingSlash: o }) => o ? Xt(Mw(Id(s)), A) : Xt(Id(s), n));
        if (i.length === 0) throw new bn(`Mock dispatch not matched for path '${n}'`);
        if (i = i.filter(({ method: s }) => Xt(s, e.method)), i.length === 0) throw new bn(`Mock dispatch not matched for method '${e.method}' on path '${n}'`);
        if (i = i.filter(({ body: s }) => typeof s < "u" ? Xt(s, e.body) : true), i.length === 0) throw new bn(`Mock dispatch not matched for body '${e.body}' on path '${n}'`);
        if (i = i.filter((s) => Pw(s, e.headers)), i.length === 0) {
          let s = typeof e.headers == "object" ? JSON.stringify(e.headers) : e.headers;
          throw new bn(`Mock dispatch not matched for headers '${s}' on path '${n}'`);
        }
        return i[0];
      }
      function lG(t, e, r, n) {
        let A = { timesInvoked: 0, times: 1, persist: false, consumed: false, ...n }, i = typeof r == "function" ? { callback: r } : { ...r }, s = { ...A, ...e, pending: true, data: { error: null, ...i } };
        return t.push(s), s;
      }
      function pd(t, e) {
        let r = t.findIndex((n) => n.consumed ? cG(n, e) : false);
        r !== -1 && t.splice(r, 1);
      }
      function Mw(t) {
        for (; t.endsWith("/"); ) t = t.slice(0, -1);
        return t.length === 0 && (t = "/"), t;
      }
      function Ow(t) {
        let { path: e, method: r, body: n, headers: A, query: i } = t;
        return { path: e, method: r, body: n, headers: A, query: i };
      }
      function Bd(t) {
        let e = Object.keys(t), r = [];
        for (let n = 0; n < e.length; ++n) {
          let A = e[n], i = t[A], s = Buffer.from(`${A}`);
          if (Array.isArray(i)) for (let o = 0; o < i.length; ++o) r.push(s, Buffer.from(`${i[o]}`));
          else r.push(s, Buffer.from(`${i}`));
        }
        return r;
      }
      function Vw(t) {
        return oG[t] || "unknown";
      }
      async function uG(t) {
        let e = [];
        for await (let r of t) e.push(r);
        return Buffer.concat(e).toString("utf8");
      }
      function Hw(t, e) {
        let r = Ow(t), n = Gw(this[Dc], r);
        n.timesInvoked++, n.data.callback && (n.data = { ...n.data, ...n.data.callback(t) });
        let { data: { statusCode: A, data: i, headers: s, trailers: o, error: a }, delay: c, persist: l } = n, { timesInvoked: u, times: g } = n;
        if (n.consumed = !l && u >= g, n.pending = u < g, a !== null) return pd(this[Dc], r), e.onError(a), true;
        typeof c == "number" && c > 0 ? setTimeout(() => {
          E(this[Dc]);
        }, c) : E(this[Dc]);
        function E(f, p = i) {
          let Q = Array.isArray(t.headers) ? md(t.headers) : t.headers, I = typeof p == "function" ? p({ ...t, headers: Q }) : p;
          if (aG(I)) {
            I.then((v) => E(f, v));
            return;
          }
          let B = Yw(I), w = Bd(s), D = Bd(o);
          e.onConnect?.((v) => e.onError(v), null), e.onHeaders?.(A, w, h, Vw(A)), e.onData?.(Buffer.from(B)), e.onComplete?.(D), pd(f, r);
        }
        function h() {
        }
        return true;
      }
      function gG() {
        let t = this[rG], e = this[AG], r = this[nG];
        return function(A, i) {
          if (t.isMockActive) try {
            Hw.call(this, A, i);
          } catch (s) {
            if (s instanceof bn) {
              let o = t[iG]();
              if (o === false) throw new bn(`${s.message}: subsequent request to origin ${e} was not allowed (net.connect disabled)`);
              if (qw(o, e)) r.call(this, A, i);
              else throw new bn(`${s.message}: subsequent request to origin ${e} was not allowed (net.connect is not enabled for this origin)`);
            } else throw s;
          }
          else r.call(this, A, i);
        };
      }
      function qw(t, e) {
        let r = new URL(e);
        return t === true ? true : !!(Array.isArray(t) && t.some((n) => Xt(n, r.host)));
      }
      function EG(t) {
        if (t) {
          let { agent: e, ...r } = t;
          return r;
        }
      }
      Jw.exports = { getResponseData: Yw, getMockDispatch: Gw, addMockDispatch: lG, deleteMockDispatch: pd, buildKey: Ow, generateKeyValues: Bd, matchValue: Xt, getResponse: uG, getStatusText: Vw, mockDispatch: Hw, buildMockDispatch: gG, checkNetConnect: qw, buildMockOptions: EG, getHeaderByName: vw, buildHeadersFromArray: md };
    });
    var Nd = C((p$, bd) => {
      "use strict";
      var { getResponseData: dG, buildKey: hG, addMockDispatch: yd } = Ss(), { kDispatches: Rc, kDispatchKey: Sc, kDefaultHeaders: wd, kDefaultTrailers: Dd, kContentLength: Rd, kMockDispatch: bc, kIgnoreTrailingSlash: Nc } = qA(), { InvalidArgumentError: Kt } = H(), { serializePathWithQuery: fG } = Y(), JA = class {
        constructor(e) {
          this[bc] = e;
        }
        delay(e) {
          if (typeof e != "number" || !Number.isInteger(e) || e <= 0) throw new Kt("waitInMs must be a valid integer > 0");
          return this[bc].delay = e, this;
        }
        persist() {
          return this[bc].persist = true, this;
        }
        times(e) {
          if (typeof e != "number" || !Number.isInteger(e) || e <= 0) throw new Kt("repeatTimes must be a valid integer > 0");
          return this[bc].times = e, this;
        }
      }, Sd = class {
        constructor(e, r) {
          if (typeof e != "object") throw new Kt("opts must be an object");
          if (typeof e.path > "u") throw new Kt("opts.path must be defined");
          if (typeof e.method > "u" && (e.method = "GET"), typeof e.path == "string") if (e.query) e.path = fG(e.path, e.query);
          else {
            let n = new URL(e.path, "data://");
            e.path = n.pathname + n.search;
          }
          typeof e.method == "string" && (e.method = e.method.toUpperCase()), this[Sc] = hG(e), this[Rc] = r, this[Nc] = e.ignoreTrailingSlash ?? false, this[wd] = {}, this[Dd] = {}, this[Rd] = false;
        }
        createMockScopeDispatchData({ statusCode: e, data: r, responseOptions: n }) {
          let A = dG(r), i = this[Rd] ? { "content-length": A.length } : {}, s = { ...this[wd], ...i, ...n.headers }, o = { ...this[Dd], ...n.trailers };
          return { statusCode: e, data: r, headers: s, trailers: o };
        }
        validateReplyParameters(e) {
          if (typeof e.statusCode > "u") throw new Kt("statusCode must be defined");
          if (typeof e.responseOptions != "object" || e.responseOptions === null) throw new Kt("responseOptions must be an object");
        }
        reply(e) {
          if (typeof e == "function") {
            let i = (o) => {
              let a = e(o);
              if (typeof a != "object" || a === null) throw new Kt("reply options callback must return an object");
              let c = { data: "", responseOptions: {}, ...a };
              return this.validateReplyParameters(c), { ...this.createMockScopeDispatchData(c) };
            }, s = yd(this[Rc], this[Sc], i, { ignoreTrailingSlash: this[Nc] });
            return new JA(s);
          }
          let r = { statusCode: e, data: arguments[1] === void 0 ? "" : arguments[1], responseOptions: arguments[2] === void 0 ? {} : arguments[2] };
          this.validateReplyParameters(r);
          let n = this.createMockScopeDispatchData(r), A = yd(this[Rc], this[Sc], n, { ignoreTrailingSlash: this[Nc] });
          return new JA(A);
        }
        replyWithError(e) {
          if (typeof e > "u") throw new Kt("error must be defined");
          let r = yd(this[Rc], this[Sc], { error: e }, { ignoreTrailingSlash: this[Nc] });
          return new JA(r);
        }
        defaultReplyHeaders(e) {
          if (typeof e > "u") throw new Kt("headers must be defined");
          return this[wd] = e, this;
        }
        defaultReplyTrailers(e) {
          if (typeof e > "u") throw new Kt("trailers must be defined");
          return this[Dd] = e, this;
        }
        replyContentLength() {
          return this[Rd] = true, this;
        }
      };
      bd.exports.MockInterceptor = Sd;
      bd.exports.MockScope = JA;
    });
    var xd = C((B$, zw) => {
      "use strict";
      var { promisify: QG } = require("node:util"), CG = fs(), { buildMockDispatch: IG } = Ss(), { kDispatches: Ww, kMockAgent: _w, kClose: jw, kOriginalClose: Zw, kOrigin: Xw, kOriginalDispatch: pG, kConnected: Fd, kIgnoreTrailingSlash: Kw } = qA(), { MockInterceptor: BG } = Nd(), $w = ne(), { InvalidArgumentError: mG } = H(), Td = class extends CG {
        constructor(e, r) {
          if (!r || !r.agent || typeof r.agent.dispatch != "function") throw new mG("Argument opts.agent must implement Agent");
          super(e, r), this[_w] = r.agent, this[Xw] = e, this[Kw] = r.ignoreTrailingSlash ?? false, this[Ww] = [], this[Fd] = 1, this[pG] = this.dispatch, this[Zw] = this.close.bind(this), this.dispatch = IG.call(this), this.close = this[jw];
        }
        get [$w.kConnected]() {
          return this[Fd];
        }
        intercept(e) {
          return new BG(e && { ignoreTrailingSlash: this[Kw], ...e }, this[Ww]);
        }
        async [jw]() {
          await QG(this[Zw])(), this[Fd] = 0, this[_w][$w.kClients].delete(this[Xw]);
        }
      };
      zw.exports = Td;
    });
    var Md = C((m$, oD) => {
      "use strict";
      var { promisify: yG } = require("node:util"), wG = LA(), { buildMockDispatch: DG } = Ss(), { kDispatches: eD, kMockAgent: tD, kClose: rD, kOriginalClose: nD, kOrigin: AD, kOriginalDispatch: RG, kConnected: Ud, kIgnoreTrailingSlash: iD } = qA(), { MockInterceptor: SG } = Nd(), sD = ne(), { InvalidArgumentError: bG } = H(), kd = class extends wG {
        constructor(e, r) {
          if (!r || !r.agent || typeof r.agent.dispatch != "function") throw new bG("Argument opts.agent must implement Agent");
          super(e, r), this[tD] = r.agent, this[AD] = e, this[iD] = r.ignoreTrailingSlash ?? false, this[eD] = [], this[Ud] = 1, this[RG] = this.dispatch, this[nD] = this.close.bind(this), this.dispatch = DG.call(this), this.close = this[rD];
        }
        get [sD.kConnected]() {
          return this[Ud];
        }
        intercept(e) {
          return new SG(e && { ignoreTrailingSlash: this[iD], ...e }, this[eD]);
        }
        async [rD]() {
          await yG(this[nD])(), this[Ud] = 0, this[tD][sD.kClients].delete(this[AD]);
        }
      };
      oD.exports = kd;
    });
    var cD = C((w$, aD) => {
      "use strict";
      var { Transform: NG } = require("node:stream"), { Console: FG } = require("node:console"), TG = process.versions.icu ? "\u2705" : "Y ", xG = process.versions.icu ? "\u274C" : "N ";
      aD.exports = class {
        constructor({ disableColors: e } = {}) {
          this.transform = new NG({ transform(r, n, A) {
            A(null, r);
          } }), this.logger = new FG({ stdout: this.transform, inspectOptions: { colors: !e && !process.env.CI } });
        }
        format(e) {
          let r = e.map(({ method: n, path: A, data: { statusCode: i }, persist: s, times: o, timesInvoked: a, origin: c }) => ({ Method: n, Origin: c, Path: A, "Status code": i, Persistent: s ? TG : xG, Invocations: a, Remaining: s ? 1 / 0 : o - a }));
          return this.logger.table(r), this.transform.read().toString();
        }
      };
    });
    var ED = C((D$, gD) => {
      "use strict";
      var { kClients: Nn } = ne(), UG = vA(), { kAgent: Ld, kMockAgentSet: Fc, kMockAgentGet: lD, kDispatches: vd, kIsMockActive: Tc, kNetConnect: Fn, kGetNetConnect: kG, kOptions: xc, kFactory: Uc } = qA(), MG = xd(), LG = Md(), { matchValue: vG, buildMockOptions: PG } = Ss(), { InvalidArgumentError: uD, UndiciError: YG } = H(), GG = $i(), OG = cD(), Pd = class extends GG {
        constructor(e) {
          if (super(e), this[Fn] = true, this[Tc] = true, e?.agent && typeof e.agent.dispatch != "function") throw new uD("Argument opts.agent must implement Agent");
          let r = e?.agent ? e.agent : new UG(e);
          this[Ld] = r, this[Nn] = r[Nn], this[xc] = PG(e);
        }
        get(e) {
          let r = this[lD](e);
          return r || (r = this[Uc](e), this[Fc](e, r)), r;
        }
        dispatch(e, r) {
          return this.get(e.origin), this[Ld].dispatch(e, r);
        }
        async close() {
          await this[Ld].close(), this[Nn].clear();
        }
        deactivate() {
          this[Tc] = false;
        }
        activate() {
          this[Tc] = true;
        }
        enableNetConnect(e) {
          if (typeof e == "string" || typeof e == "function" || e instanceof RegExp) Array.isArray(this[Fn]) ? this[Fn].push(e) : this[Fn] = [e];
          else if (typeof e > "u") this[Fn] = true;
          else throw new uD("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
        disableNetConnect() {
          this[Fn] = false;
        }
        get isMockActive() {
          return this[Tc];
        }
        [Fc](e, r) {
          this[Nn].set(e, r);
        }
        [Uc](e) {
          let r = Object.assign({ agent: this }, this[xc]);
          return this[xc] && this[xc].connections === 1 ? new MG(e, r) : new LG(e, r);
        }
        [lD](e) {
          let r = this[Nn].get(e);
          if (r) return r;
          if (typeof e != "string") {
            let n = this[Uc]("http://localhost:9999");
            return this[Fc](e, n), n;
          }
          for (let [n, A] of Array.from(this[Nn])) if (A && typeof n != "string" && vG(n, e)) {
            let i = this[Uc](e);
            return this[Fc](e, i), i[vd] = A[vd], i;
          }
        }
        [kG]() {
          return this[Fn];
        }
        pendingInterceptors() {
          let e = this[Nn];
          return Array.from(e.entries()).flatMap(([r, n]) => n[vd].map((A) => ({ ...A, origin: r }))).filter(({ pending: r }) => r);
        }
        assertNoPendingInterceptors({ pendingInterceptorsFormatter: e = new OG() } = {}) {
          let r = this.pendingInterceptors();
          if (r.length !== 0) throw new YG(r.length === 1 ? `1 interceptor is pending:

${e.format(r)}`.trim() : `${r.length} interceptors are pending:

${e.format(r)}`.trim());
        }
      };
      gD.exports = Pd;
    });
    var kc = C((R$, QD) => {
      "use strict";
      var dD = /* @__PURE__ */ Symbol.for("undici.globalDispatcher.1"), { InvalidArgumentError: VG } = H(), HG = vA();
      fD() === void 0 && hD(new HG());
      function hD(t) {
        if (!t || typeof t.dispatch != "function") throw new VG("Argument agent must implement Agent");
        Object.defineProperty(globalThis, dD, { value: t, writable: true, enumerable: false, configurable: false });
      }
      function fD() {
        return globalThis[dD];
      }
      QD.exports = { setGlobalDispatcher: hD, getGlobalDispatcher: fD };
    });
    var bs = C((b$, CD) => {
      "use strict";
      var Br = require("node:assert"), qG = va();
      CD.exports = class {
        #e;
        #t = false;
        #r = false;
        #n = false;
        constructor(e) {
          if (typeof e != "object" || e === null) throw new TypeError("handler must be an object");
          this.#e = qG.wrap(e);
        }
        onRequestStart(...e) {
          this.#e.onRequestStart?.(...e);
        }
        onRequestUpgrade(...e) {
          return Br(!this.#t), Br(!this.#r), this.#e.onRequestUpgrade?.(...e);
        }
        onResponseStart(...e) {
          return Br(!this.#t), Br(!this.#r), Br(!this.#n), this.#n = true, this.#e.onResponseStart?.(...e);
        }
        onResponseData(...e) {
          return Br(!this.#t), Br(!this.#r), this.#e.onResponseData?.(...e);
        }
        onResponseEnd(...e) {
          return Br(!this.#t), Br(!this.#r), this.#t = true, this.#e.onResponseEnd?.(...e);
        }
        onResponseError(...e) {
          return this.#r = true, this.#e.onResponseError?.(...e);
        }
        onBodySent() {
        }
      };
    });
    var Od = C((N$, yD) => {
      "use strict";
      var nt = Y(), { kBodyUsed: Ns } = ne(), Gd = require("node:assert"), { InvalidArgumentError: ID } = H(), JG = require("node:events"), WG = [300, 301, 302, 303, 307, 308], pD = /* @__PURE__ */ Symbol("body"), BD = () => {
      }, Mc = class {
        constructor(e) {
          this[pD] = e, this[Ns] = false;
        }
        async *[Symbol.asyncIterator]() {
          Gd(!this[Ns], "disturbed"), this[Ns] = true, yield* this[pD];
        }
      }, Yd = class t {
        static buildDispatch(e, r) {
          if (r != null && (!Number.isInteger(r) || r < 0)) throw new ID("maxRedirections must be a positive number");
          let n = e.dispatch.bind(e);
          return (A, i) => n(A, new t(n, r, A, i));
        }
        constructor(e, r, n, A) {
          if (r != null && (!Number.isInteger(r) || r < 0)) throw new ID("maxRedirections must be a positive number");
          this.dispatch = e, this.location = null, this.opts = { ...n, maxRedirections: 0 }, this.maxRedirections = r, this.handler = A, this.history = [], nt.isStream(this.opts.body) ? (nt.bodyLength(this.opts.body) === 0 && this.opts.body.on("data", function() {
            Gd(false);
          }), typeof this.opts.body.readableDidRead != "boolean" && (this.opts.body[Ns] = false, JG.prototype.on.call(this.opts.body, "data", function() {
            this[Ns] = true;
          }))) : this.opts.body && typeof this.opts.body.pipeTo == "function" ? this.opts.body = new Mc(this.opts.body) : this.opts.body && typeof this.opts.body != "string" && !ArrayBuffer.isView(this.opts.body) && nt.isIterable(this.opts.body) && !nt.isFormDataLike(this.opts.body) && (this.opts.body = new Mc(this.opts.body));
        }
        onRequestStart(e, r) {
          this.handler.onRequestStart?.(e, { ...r, history: this.history });
        }
        onRequestUpgrade(e, r, n, A) {
          this.handler.onRequestUpgrade?.(e, r, n, A);
        }
        onResponseStart(e, r, n, A) {
          if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) throw new Error("max redirects");
          if ((r === 301 || r === 302) && this.opts.method === "POST" && (this.opts.method = "GET", nt.isStream(this.opts.body) && nt.destroy(this.opts.body.on("error", BD)), this.opts.body = null), r === 303 && this.opts.method !== "HEAD" && (this.opts.method = "GET", nt.isStream(this.opts.body) && nt.destroy(this.opts.body.on("error", BD)), this.opts.body = null), this.location = this.history.length >= this.maxRedirections || nt.isDisturbed(this.opts.body) || WG.indexOf(r) === -1 ? null : n.location, this.opts.origin && this.history.push(new URL(this.opts.path, this.opts.origin)), !this.location) {
            this.handler.onResponseStart?.(e, r, n, A);
            return;
          }
          let { origin: i, pathname: s, search: o } = nt.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin))), a = o ? `${s}${o}` : s;
          this.opts.headers = _G(this.opts.headers, r === 303, this.opts.origin !== i), this.opts.path = a, this.opts.origin = i, this.opts.maxRedirections = 0, this.opts.query = null;
        }
        onResponseData(e, r) {
          this.location || this.handler.onResponseData?.(e, r);
        }
        onResponseEnd(e, r) {
          this.location ? this.dispatch(this.opts, this) : this.handler.onResponseEnd(e, r);
        }
        onResponseError(e, r) {
          this.handler.onResponseError?.(e, r);
        }
      };
      function mD(t, e, r) {
        if (t.length === 4) return nt.headerNameToString(t) === "host";
        if (e && nt.headerNameToString(t).startsWith("content-")) return true;
        if (r && (t.length === 13 || t.length === 6 || t.length === 19)) {
          let n = nt.headerNameToString(t);
          return n === "authorization" || n === "cookie" || n === "proxy-authorization";
        }
        return false;
      }
      function _G(t, e, r) {
        let n = [];
        if (Array.isArray(t)) for (let A = 0; A < t.length; A += 2) mD(t[A], e, r) || n.push(t[A], t[A + 1]);
        else if (t && typeof t == "object") {
          let A = typeof t[Symbol.iterator] == "function" ? t : Object.entries(t);
          for (let [i, s] of A) mD(i, e, r) || n.push(i, s);
        } else Gd(t == null, "headers must be an object or an array");
        return n;
      }
      yD.exports = Yd;
    });
    var DD = C((F$, wD) => {
      "use strict";
      var jG = Od();
      function ZG({ maxRedirections: t } = {}) {
        return (e) => function(n, A) {
          let { maxRedirections: i = t, ...s } = n;
          if (i == null || i === 0) return e(n, A);
          let o = { ...s, maxRedirections: 0 }, a = new jG(e, i, o, A);
          return e(o, a);
        };
      }
      wD.exports = ZG;
    });
    var SD = C((T$, RD) => {
      "use strict";
      var XG = bs(), { ResponseError: KG } = H(), Vd = class extends XG {
        #e;
        #t;
        #r;
        #n;
        #i;
        constructor(e, { handler: r }) {
          super(r);
        }
        #A(e) {
          return (this.#t ?? "").indexOf(e) === 0;
        }
        onRequestStart(e, r) {
          return this.#e = 0, this.#t = null, this.#r = null, this.#n = null, this.#i = "", super.onRequestStart(e, r);
        }
        onResponseStart(e, r, n, A) {
          if (this.#e = r, this.#n = n, this.#t = n["content-type"], this.#e < 400) return super.onResponseStart(e, r, n, A);
          (this.#A("application/json") || this.#A("text/plain")) && (this.#r = new TextDecoder("utf-8"));
        }
        onResponseData(e, r) {
          if (this.#e < 400) return super.onResponseData(e, r);
          this.#i += this.#r?.decode(r, { stream: true }) ?? "";
        }
        onResponseEnd(e, r) {
          if (this.#e >= 400) {
            if (this.#i += this.#r?.decode(void 0, { stream: false }) ?? "", this.#A("application/json")) try {
              this.#i = JSON.parse(this.#i);
            } catch {
            }
            let n, A = Error.stackTraceLimit;
            Error.stackTraceLimit = 0;
            try {
              n = new KG("Response Error", this.#e, { body: this.#i, headers: this.#n });
            } finally {
              Error.stackTraceLimit = A;
            }
            super.onResponseError(e, n);
          } else super.onResponseEnd(e, r);
        }
        onResponseError(e, r) {
          super.onResponseError(e, r);
        }
      };
      RD.exports = () => (t) => function(r, n) {
        return t(r, new Vd(r, { handler: n }));
      };
    });
    var ND = C((x$, bD) => {
      "use strict";
      var $G = pc();
      bD.exports = (t) => (e) => function(n, A) {
        return e(n, new $G({ ...n, retryOptions: { ...t, ...n.retryOptions } }, { handler: A, dispatch: e }));
      };
    });
    var TD = C((U$, FD) => {
      "use strict";
      var { InvalidArgumentError: zG, RequestAbortedError: eO } = H(), tO = bs(), Hd = class extends tO {
        #e = 1024 * 1024;
        #t = false;
        #r = 0;
        #n = null;
        aborted = false;
        reason = false;
        constructor({ maxSize: e, signal: r }, n) {
          if (e != null && (!Number.isFinite(e) || e < 1)) throw new zG("maxSize must be a number greater than 0");
          super(n), this.#e = e ?? this.#e;
        }
        #i(e) {
          this.aborted = true, this.reason = e;
        }
        onRequestStart(e, r) {
          return e.abort = this.#i.bind(this), this.#n = e, super.onRequestStart(e, r);
        }
        onResponseStart(e, r, n, A) {
          let i = n["content-length"];
          if (i != null && i > this.#e) throw new eO(`Response size (${i}) larger than maxSize (${this.#e})`);
          return this.aborted === true ? true : super.onResponseStart(e, r, n, A);
        }
        onResponseError(e, r) {
          this.#t || (r = this.#n.reason ?? r, super.onResponseError(e, r));
        }
        onResponseData(e, r) {
          return this.#r = this.#r + r.length, this.#r >= this.#e && (this.#t = true, this.aborted === true ? super.onResponseError(e, this.reason) : super.onResponseEnd(e, {})), true;
        }
        onResponseEnd(e, r) {
          if (!this.#t) {
            if (this.#n.aborted === true) {
              super.onResponseError(e, this.reason);
              return;
            }
            super.onResponseEnd(e, r);
          }
        }
      };
      function rO({ maxSize: t } = { maxSize: 1024 * 1024 }) {
        return (e) => function(n, A) {
          let { dumpMaxSize: i = t } = n, s = new Hd({ maxSize: i, signal: n.signal }, A);
          return e(n, s);
        };
      }
      FD.exports = rO;
    });
    var UD = C((k$, xD) => {
      "use strict";
      var { isIP: nO } = require("node:net"), { lookup: AO } = require("node:dns"), iO = bs(), { InvalidArgumentError: WA, InformationalError: sO } = H(), qd = Math.pow(2, 31) - 1, Jd = class {
        #e = 0;
        #t = 0;
        #r = /* @__PURE__ */ new Map();
        dualStack = true;
        affinity = null;
        lookup = null;
        pick = null;
        constructor(e) {
          this.#e = e.maxTTL, this.#t = e.maxItems, this.dualStack = e.dualStack, this.affinity = e.affinity, this.lookup = e.lookup ?? this.#n, this.pick = e.pick ?? this.#i;
        }
        get full() {
          return this.#r.size === this.#t;
        }
        runLookup(e, r, n) {
          let A = this.#r.get(e.hostname);
          if (A == null && this.full) {
            n(null, e);
            return;
          }
          let i = { affinity: this.affinity, dualStack: this.dualStack, lookup: this.lookup, pick: this.pick, ...r.dns, maxTTL: this.#e, maxItems: this.#t };
          if (A == null) this.lookup(e, i, (s, o) => {
            if (s || o == null || o.length === 0) {
              n(s ?? new sO("No DNS entries found"));
              return;
            }
            this.setRecords(e, o);
            let a = this.#r.get(e.hostname), c = this.pick(e, a, i.affinity), l;
            typeof c.port == "number" ? l = `:${c.port}` : e.port !== "" ? l = `:${e.port}` : l = "", n(null, new URL(`${e.protocol}//${c.family === 6 ? `[${c.address}]` : c.address}${l}`));
          });
          else {
            let s = this.pick(e, A, i.affinity);
            if (s == null) {
              this.#r.delete(e.hostname), this.runLookup(e, r, n);
              return;
            }
            let o;
            typeof s.port == "number" ? o = `:${s.port}` : e.port !== "" ? o = `:${e.port}` : o = "", n(null, new URL(`${e.protocol}//${s.family === 6 ? `[${s.address}]` : s.address}${o}`));
          }
        }
        #n(e, r, n) {
          AO(e.hostname, { all: true, family: this.dualStack === false ? this.affinity : 0, order: "ipv4first" }, (A, i) => {
            if (A) return n(A);
            let s = /* @__PURE__ */ new Map();
            for (let o of i) s.set(`${o.address}:${o.family}`, o);
            n(null, s.values());
          });
        }
        #i(e, r, n) {
          let A = null, { records: i, offset: s } = r, o;
          if (this.dualStack ? (n == null && (s == null || s === qd ? (r.offset = 0, n = 4) : (r.offset++, n = (r.offset & 1) === 1 ? 6 : 4)), i[n] != null && i[n].ips.length > 0 ? o = i[n] : o = i[n === 4 ? 6 : 4]) : o = i[n], o == null || o.ips.length === 0) return A;
          o.offset == null || o.offset === qd ? o.offset = 0 : o.offset++;
          let a = o.offset % o.ips.length;
          return A = o.ips[a] ?? null, A == null ? A : Date.now() - A.timestamp > A.ttl ? (o.ips.splice(a, 1), this.pick(e, r, n)) : A;
        }
        pickFamily(e, r) {
          let n = this.#r.get(e.hostname)?.records;
          if (!n) return null;
          let A = n[r];
          if (!A) return null;
          A.offset == null || A.offset === qd ? A.offset = 0 : A.offset++;
          let i = A.offset % A.ips.length, s = A.ips[i] ?? null;
          return s == null || Date.now() - s.timestamp > s.ttl && A.ips.splice(i, 1), s;
        }
        setRecords(e, r) {
          let n = Date.now(), A = { records: { 4: null, 6: null } };
          for (let i of r) {
            i.timestamp = n, typeof i.ttl == "number" ? i.ttl = Math.min(i.ttl, this.#e) : i.ttl = this.#e;
            let s = A.records[i.family] ?? { ips: [] };
            s.ips.push(i), A.records[i.family] = s;
          }
          this.#r.set(e.hostname, A);
        }
        deleteRecords(e) {
          this.#r.delete(e.hostname);
        }
        getHandler(e, r) {
          return new Wd(this, e, r);
        }
      }, Wd = class extends iO {
        #e = null;
        #t = null;
        #r = null;
        #n = null;
        #i = null;
        #A = null;
        #a = true;
        constructor(e, { origin: r, handler: n, dispatch: A, newOrigin: i }, s) {
          super(n), this.#n = r, this.#A = i, this.#t = { ...s }, this.#e = e, this.#r = A;
        }
        onResponseError(e, r) {
          switch (r.code) {
            case "ETIMEDOUT":
            case "ECONNREFUSED": {
              if (this.#e.dualStack) {
                if (!this.#a) {
                  super.onResponseError(e, r);
                  return;
                }
                this.#a = false;
                let n = this.#A.hostname[0] === "[" ? 4 : 6, A = this.#e.pickFamily(this.#n, n);
                if (A == null) {
                  super.onResponseError(e, r);
                  return;
                }
                let i;
                typeof A.port == "number" ? i = `:${A.port}` : this.#n.port !== "" ? i = `:${this.#n.port}` : i = "";
                let s = { ...this.#t, origin: `${this.#n.protocol}//${A.family === 6 ? `[${A.address}]` : A.address}${i}` };
                this.#r(s, this);
                return;
              }
              super.onResponseError(e, r);
              break;
            }
            case "ENOTFOUND":
              this.#e.deleteRecords(this.#n), super.onResponseError(e, r);
              break;
            default:
              super.onResponseError(e, r);
              break;
          }
        }
      };
      xD.exports = (t) => {
        if (t?.maxTTL != null && (typeof t?.maxTTL != "number" || t?.maxTTL < 0)) throw new WA("Invalid maxTTL. Must be a positive number");
        if (t?.maxItems != null && (typeof t?.maxItems != "number" || t?.maxItems < 1)) throw new WA("Invalid maxItems. Must be a positive number and greater than zero");
        if (t?.affinity != null && t?.affinity !== 4 && t?.affinity !== 6) throw new WA("Invalid affinity. Must be either 4 or 6");
        if (t?.dualStack != null && typeof t?.dualStack != "boolean") throw new WA("Invalid dualStack. Must be a boolean");
        if (t?.lookup != null && typeof t?.lookup != "function") throw new WA("Invalid lookup. Must be a function");
        if (t?.pick != null && typeof t?.pick != "function") throw new WA("Invalid pick. Must be a function");
        let e = t?.dualStack ?? true, r;
        e ? r = t?.affinity ?? null : r = t?.affinity ?? 4;
        let n = { maxTTL: t?.maxTTL ?? 1e4, lookup: t?.lookup ?? null, pick: t?.pick ?? null, dualStack: e, affinity: r, maxItems: t?.maxItems ?? 1 / 0 }, A = new Jd(n);
        return (i) => function(o, a) {
          let c = o.origin.constructor === URL ? o.origin : new URL(o.origin);
          return nO(c.hostname) !== 0 ? i(o, a) : (A.runLookup(c, o, (l, u) => {
            if (l) return a.onResponseError(null, l);
            let g = { ...o, servername: c.hostname, origin: u.origin, headers: { host: c.host, ...o.headers } };
            i(g, A.getHandler({ origin: c, dispatch: i, handler: a, newOrigin: u }, o));
          }), true);
        };
      };
    });
    var Fs = C((M$, MD) => {
      "use strict";
      var { safeHTTPMethods: kD } = Y();
      function oO(t) {
        if (!t.origin) throw new Error("opts.origin is undefined");
        let e;
        if (t.headers == null) e = {};
        else if (typeof t.headers[Symbol.iterator] == "function") {
          e = {};
          for (let r of t.headers) {
            if (!Array.isArray(r)) throw new Error("opts.headers is not a valid header map");
            let [n, A] = r;
            if (typeof n != "string" || typeof A != "string") throw new Error("opts.headers is not a valid header map");
            e[n.toLowerCase()] = A;
          }
        } else if (typeof t.headers == "object") {
          e = {};
          for (let r of Object.keys(t.headers)) e[r.toLowerCase()] = t.headers[r];
        } else throw new Error("opts.headers is not an object");
        return { origin: t.origin.toString(), method: t.method, path: t.path, headers: e };
      }
      function aO(t) {
        if (typeof t != "object") throw new TypeError(`expected key to be object, got ${typeof t}`);
        for (let e of ["origin", "method", "path"]) if (typeof t[e] != "string") throw new TypeError(`expected key.${e} to be string, got ${typeof t[e]}`);
        if (t.headers !== void 0 && typeof t.headers != "object") throw new TypeError(`expected headers to be object, got ${typeof t}`);
      }
      function cO(t) {
        if (typeof t != "object") throw new TypeError(`expected value to be object, got ${typeof t}`);
        for (let e of ["statusCode", "cachedAt", "staleAt", "deleteAt"]) if (typeof t[e] != "number") throw new TypeError(`expected value.${e} to be number, got ${typeof t[e]}`);
        if (typeof t.statusMessage != "string") throw new TypeError(`expected value.statusMessage to be string, got ${typeof t.statusMessage}`);
        if (t.headers != null && typeof t.headers != "object") throw new TypeError(`expected value.rawHeaders to be object, got ${typeof t.headers}`);
        if (t.vary !== void 0 && typeof t.vary != "object") throw new TypeError(`expected value.vary to be object, got ${typeof t.vary}`);
        if (t.etag !== void 0 && typeof t.etag != "string") throw new TypeError(`expected value.etag to be string, got ${typeof t.etag}`);
      }
      function lO(t) {
        let e = {}, r;
        if (Array.isArray(t)) {
          r = [];
          for (let n of t) r.push(...n.split(","));
        } else r = t.split(",");
        for (let n = 0; n < r.length; n++) {
          let A = r[n].toLowerCase(), i = A.indexOf("="), s, o;
          switch (i !== -1 ? (s = A.substring(0, i).trimStart(), o = A.substring(i + 1)) : s = A.trim(), s) {
            case "min-fresh":
            case "max-stale":
            case "max-age":
            case "s-maxage":
            case "stale-while-revalidate":
            case "stale-if-error": {
              if (o === void 0 || o[0] === " ") continue;
              o.length >= 2 && o[0] === '"' && o[o.length - 1] === '"' && (o = o.substring(1, o.length - 1));
              let a = parseInt(o, 10);
              if (a !== a || s === "max-age" && s in e && e[s] >= a) continue;
              e[s] = a;
              break;
            }
            case "private":
            case "no-cache":
              if (o) {
                if (o[0] === '"') {
                  let a = [o.substring(1)], c = o[o.length - 1] === '"';
                  if (!c) for (let l = n + 1; l < r.length; l++) {
                    let u = r[l], g = u.length;
                    if (a.push(u.trim()), g !== 0 && u[g - 1] === '"') {
                      c = true;
                      break;
                    }
                  }
                  if (c) {
                    let l = a[a.length - 1];
                    l[l.length - 1] === '"' && (l = l.substring(0, l.length - 1), a[a.length - 1] = l), s in e ? e[s] = e[s].concat(a) : e[s] = a;
                  }
                } else s in e ? e[s] = e[s].concat(o) : e[s] = [o];
                break;
              }
            case "public":
            case "no-store":
            case "must-revalidate":
            case "proxy-revalidate":
            case "immutable":
            case "no-transform":
            case "must-understand":
            case "only-if-cached":
              if (o) continue;
              e[s] = true;
              break;
            default:
              continue;
          }
        }
        return e;
      }
      function uO(t, e) {
        if (typeof t == "string" && t.includes("*")) return e;
        let r = {}, n = typeof t == "string" ? t.split(",") : t;
        for (let A of n) {
          let i = A.trim().toLowerCase();
          r[i] = e[i] ?? null;
        }
        return r;
      }
      function gO(t) {
        return t.length <= 2 ? false : t[0] === '"' && t[t.length - 1] === '"' ? !(t[1] === '"' || t.startsWith('"W/')) : t.startsWith('W/"') && t[t.length - 1] === '"' ? t.length !== 4 : false;
      }
      function EO(t, e = "CacheStore") {
        if (typeof t != "object" || t === null) throw new TypeError(`expected type of ${e} to be a CacheStore, got ${t === null ? "null" : typeof t}`);
        for (let r of ["get", "createWriteStream", "delete"]) if (typeof t[r] != "function") throw new TypeError(`${e} needs to have a \`${r}()\` function`);
      }
      function dO(t, e = "CacheMethods") {
        if (!Array.isArray(t)) throw new TypeError(`expected type of ${e} needs to be an array, got ${t === null ? "null" : typeof t}`);
        if (t.length === 0) throw new TypeError(`${e} needs to have at least one method`);
        for (let r of t) if (!kD.includes(r)) throw new TypeError(`element of ${e}-array needs to be one of following values: ${kD.join(", ")}, got ${r}`);
      }
      MD.exports = { makeCacheKey: oO, assertCacheKey: aO, assertCacheValue: cO, parseCacheControlHeader: lO, parseVaryHeader: uO, isEtagUsable: gO, assertCacheMethods: dO, assertCacheStore: EO };
    });
    var PD = C((L$, vD) => {
      "use strict";
      var LD = ["mon", "tue", "wed", "thu", "fri", "sat", "sun"], hO = [4, 7, 11, 16, 25], _d = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"], fO = [19, 22], QO = [3, 7, 10, 19], CO = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"];
      function IO(t, e) {
        switch (t = t.toLowerCase(), t[3]) {
          case ",":
            return pO(t);
          case " ":
            return BO(t);
          default:
            return mO(t, e);
        }
      }
      function pO(t) {
        if (t.length !== 29 || !t.endsWith("gmt")) return;
        for (let E of hO) if (t[E] !== " ") return;
        for (let E of fO) if (t[E] !== ":") return;
        let e = t.substring(0, 3);
        if (!LD.includes(e)) return;
        let r = t.substring(5, 7), n = Number.parseInt(r);
        if (isNaN(n) || n < 10 && r[0] !== "0") return;
        let A = t.substring(8, 11), i = _d.indexOf(A);
        if (i === -1) return;
        let s = Number.parseInt(t.substring(12, 16));
        if (isNaN(s)) return;
        let o = t.substring(17, 19), a = Number.parseInt(o);
        if (isNaN(a) || a < 10 && o[0] !== "0") return;
        let c = t.substring(20, 22), l = Number.parseInt(c);
        if (isNaN(l) || l < 10 && c[0] !== "0") return;
        let u = t.substring(23, 25), g = Number.parseInt(u);
        if (!(isNaN(g) || g < 10 && u[0] !== "0")) return new Date(Date.UTC(s, i, n, a, l, g));
      }
      function BO(t) {
        if (t.length !== 24) return;
        for (let E of QO) if (t[E] !== " ") return;
        let e = t.substring(0, 3);
        if (!LD.includes(e)) return;
        let r = t.substring(4, 7), n = _d.indexOf(r);
        if (n === -1) return;
        let A = t.substring(8, 10), i = Number.parseInt(A);
        if (isNaN(i) || i < 10 && A[0] !== " ") return;
        let s = t.substring(11, 13), o = Number.parseInt(s);
        if (isNaN(o) || o < 10 && s[0] !== "0") return;
        let a = t.substring(14, 16), c = Number.parseInt(a);
        if (isNaN(c) || c < 10 && a[0] !== "0") return;
        let l = t.substring(17, 19), u = Number.parseInt(l);
        if (isNaN(u) || u < 10 && l[0] !== "0") return;
        let g = Number.parseInt(t.substring(20, 24));
        if (!isNaN(g)) return new Date(Date.UTC(g, n, i, o, c, u));
      }
      function mO(t, e = /* @__PURE__ */ new Date()) {
        if (!t.endsWith("gmt")) return;
        let r = t.indexOf(",");
        if (r === -1 || t.length - r - 1 !== 23) return;
        let n = t.substring(0, r);
        if (!CO.includes(n) || t[r + 1] !== " " || t[r + 4] !== "-" || t[r + 8] !== "-" || t[r + 11] !== " " || t[r + 14] !== ":" || t[r + 17] !== ":" || t[r + 20] !== " ") return;
        let A = t.substring(r + 2, r + 4), i = Number.parseInt(A);
        if (isNaN(i) || i < 10 && A[0] !== "0") return;
        let s = t.substring(r + 5, r + 8), o = _d.indexOf(s);
        if (o === -1) return;
        let a = Number.parseInt(t.substring(r + 9, r + 11));
        if (isNaN(a)) return;
        let c = e.getUTCFullYear(), l = c % 100, u = Math.floor(c / 100);
        a > l && a - l >= 50 ? a += (u - 1) * 100 : a += u * 100;
        let g = t.substring(r + 12, r + 14), E = Number.parseInt(g);
        if (isNaN(E) || E < 10 && g[0] !== "0") return;
        let h = t.substring(r + 15, r + 17), f = Number.parseInt(h);
        if (isNaN(f) || f < 10 && h[0] !== "0") return;
        let p = t.substring(r + 18, r + 20), Q = Number.parseInt(p);
        if (!(isNaN(Q) || Q < 10 && p[0] !== "0")) return new Date(Date.UTC(a, o, i, E, f, Q));
      }
      vD.exports = { parseHttpDate: IO };
    });
    var OD = C((v$, GD) => {
      "use strict";
      var yO = Y(), { parseCacheControlHeader: wO, parseVaryHeader: DO, isEtagUsable: RO } = Fs(), { parseHttpDate: YD } = PD();
      function SO() {
      }
      var bO = [200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, 501], NO = 2147483647e3, jd = class {
        #e;
        #t;
        #r;
        #n;
        #i;
        #A;
        constructor({ store: e, type: r, cacheByDefault: n }, A, i) {
          this.#n = e, this.#t = r, this.#r = n, this.#e = A, this.#i = i;
        }
        onRequestStart(e, r) {
          this.#A?.destroy(), this.#A = void 0, this.#i.onRequestStart?.(e, r);
        }
        onRequestUpgrade(e, r, n, A) {
          this.#i.onRequestUpgrade?.(e, r, n, A);
        }
        onResponseStart(e, r, n, A) {
          let i = () => this.#i.onResponseStart?.(e, r, n, A);
          if (!yO.safeHTTPMethods.includes(this.#e.method) && r >= 200 && r <= 399) {
            try {
              this.#n.delete(this.#e)?.catch?.(SO);
            } catch {
            }
            return i();
          }
          let s = n["cache-control"], o = n["last-modified"] && bO.includes(r);
          if (!s && !n.expires && !o && !this.#r) return i();
          let a = s ? wO(s) : {};
          if (!FO(this.#t, r, n, a)) return i();
          let c = Date.now(), l = n.age ? TO(n.age) : void 0;
          if (l && l >= NO) return i();
          let u = typeof n.date == "string" ? YD(n.date) : void 0, g = xO(this.#t, c, l, n, u, a) ?? this.#r;
          if (g === void 0 || l && l > g) return i();
          let E = u ? u.getTime() : c, h = g + E;
          if (c >= h) return i();
          let f;
          if (this.#e.headers && n.vary && (f = DO(n.vary, this.#e.headers), !f)) return i();
          let p = UO(E, a, h), Q = kO(n, a), I = { statusCode: r, statusMessage: A, headers: Q, vary: f, cacheControlDirectives: a, cachedAt: l ? c - l : c, staleAt: h, deleteAt: p };
          if (typeof n.etag == "string" && RO(n.etag) && (I.etag = n.etag), this.#A = this.#n.createWriteStream(this.#e, I), !this.#A) return i();
          let B = this;
          return this.#A.on("drain", () => e.resume()).on("error", function() {
            B.#A = void 0, B.#n.delete(B.#e);
          }).on("close", function() {
            B.#A === this && (B.#A = void 0), e.resume();
          }), i();
        }
        onResponseData(e, r) {
          this.#A?.write(r) === false && e.pause(), this.#i.onResponseData?.(e, r);
        }
        onResponseEnd(e, r) {
          this.#A?.end(), this.#i.onResponseEnd?.(e, r);
        }
        onResponseError(e, r) {
          this.#A?.destroy(r), this.#A = void 0, this.#i.onResponseError?.(e, r);
        }
      };
      function FO(t, e, r, n) {
        return !(e !== 200 && e !== 307 || n["no-store"] || t === "shared" && n.private === true || r.vary?.includes("*") || r.authorization && (!n.public || typeof r.authorization != "string" || Array.isArray(n["no-cache"]) && n["no-cache"].includes("authorization") || Array.isArray(n.private) && n.private.includes("authorization")));
      }
      function TO(t) {
        let e = parseInt(Array.isArray(t) ? t[0] : t);
        return isNaN(e) ? void 0 : e * 1e3;
      }
      function xO(t, e, r, n, A, i) {
        if (t === "shared") {
          let o = i["s-maxage"];
          if (o !== void 0) return o > 0 ? o * 1e3 : void 0;
        }
        let s = i["max-age"];
        if (s !== void 0) return s > 0 ? s * 1e3 : void 0;
        if (typeof n.expires == "string") {
          let o = YD(n.expires);
          if (o) return e >= o.getTime() || A && (A >= o || r !== void 0 && r > o - A) ? void 0 : o.getTime() - e;
        }
        if (typeof n["last-modified"] == "string") {
          let o = new Date(n["last-modified"]);
          if (MO(o)) return o.getTime() >= e ? void 0 : (e - o.getTime()) * 0.1;
        }
        if (i.immutable) return 31536e3;
      }
      function UO(t, e, r) {
        let n = -1 / 0, A = -1 / 0, i = -1 / 0;
        return e["stale-while-revalidate"] && (n = r + e["stale-while-revalidate"] * 1e3), e["stale-if-error"] && (A = r + e["stale-if-error"] * 1e3), n === -1 / 0 && A === -1 / 0 && (i = t + 31536e6), Math.max(r, n, A, i);
      }
      function kO(t, e) {
        let r = ["connection", "proxy-authenticate", "proxy-authentication-info", "proxy-authorization", "proxy-connection", "te", "transfer-encoding", "upgrade", "age"];
        t.connection && (Array.isArray(t.connection) ? r.push(...t.connection.map((A) => A.trim())) : r.push(...t.connection.split(",").map((A) => A.trim()))), Array.isArray(e["no-cache"]) && r.push(...e["no-cache"]), Array.isArray(e.private) && r.push(...e.private);
        let n;
        for (let A of r) t[A] && (n ??= { ...t }, delete n[A]);
        return n ?? t;
      }
      function MO(t) {
        return t instanceof Date && Number.isFinite(t.valueOf());
      }
      GD.exports = jd;
    });
    var Xd = C((P$, HD) => {
      "use strict";
      var { Writable: LO } = require("node:stream"), { assertCacheKey: VD, assertCacheValue: vO } = Fs(), Zd = class {
        #e = 1 / 0;
        #t = 1 / 0;
        #r = 1 / 0;
        #n = 0;
        #i = 0;
        #A = /* @__PURE__ */ new Map();
        constructor(e) {
          if (e) {
            if (typeof e != "object") throw new TypeError("MemoryCacheStore options must be an object");
            if (e.maxCount !== void 0) {
              if (typeof e.maxCount != "number" || !Number.isInteger(e.maxCount) || e.maxCount < 0) throw new TypeError("MemoryCacheStore options.maxCount must be a non-negative integer");
              this.#e = e.maxCount;
            }
            if (e.maxSize !== void 0) {
              if (typeof e.maxSize != "number" || !Number.isInteger(e.maxSize) || e.maxSize < 0) throw new TypeError("MemoryCacheStore options.maxSize must be a non-negative integer");
              this.#t = e.maxSize;
            }
            if (e.maxEntrySize !== void 0) {
              if (typeof e.maxEntrySize != "number" || !Number.isInteger(e.maxEntrySize) || e.maxEntrySize < 0) throw new TypeError("MemoryCacheStore options.maxEntrySize must be a non-negative integer");
              this.#r = e.maxEntrySize;
            }
          }
        }
        get(e) {
          VD(e);
          let r = `${e.origin}:${e.path}`, n = Date.now(), A = this.#A.get(r)?.find((i) => i.deleteAt > n && i.method === e.method && (i.vary == null || Object.keys(i.vary).every((s) => i.vary[s] === null ? e.headers[s] === void 0 : i.vary[s] === e.headers[s])));
          return A == null ? void 0 : { statusMessage: A.statusMessage, statusCode: A.statusCode, headers: A.headers, body: A.body, vary: A.vary ? A.vary : void 0, etag: A.etag, cacheControlDirectives: A.cacheControlDirectives, cachedAt: A.cachedAt, staleAt: A.staleAt, deleteAt: A.deleteAt };
        }
        createWriteStream(e, r) {
          VD(e), vO(r);
          let n = `${e.origin}:${e.path}`, A = this, i = { ...e, ...r, body: [], size: 0 };
          return new LO({ write(s, o, a) {
            typeof s == "string" && (s = Buffer.from(s, o)), i.size += s.byteLength, i.size >= A.#r ? this.destroy() : i.body.push(s), a(null);
          }, final(s) {
            let o = A.#A.get(n);
            if (o || (o = [], A.#A.set(n, o)), o.push(i), A.#n += i.size, A.#i += 1, A.#n > A.#t || A.#i > A.#e) for (let [a, c] of A.#A) {
              for (let l of c.splice(0, c.length / 2)) A.#n -= l.size, A.#i -= 1;
              c.length === 0 && A.#A.delete(a);
            }
            s(null);
          } });
        }
        delete(e) {
          if (typeof e != "object") throw new TypeError(`expected key to be object, got ${typeof e}`);
          let r = `${e.origin}:${e.path}`;
          for (let n of this.#A.get(r) ?? []) this.#n -= n.size, this.#i -= 1;
          this.#A.delete(r);
        }
      };
      HD.exports = Zd;
    });
    var JD = C((Y$, qD) => {
      "use strict";
      var PO = require("node:assert"), Kd = class {
        #e = false;
        #t;
        #r;
        #n;
        #i;
        constructor(e, r, n) {
          if (typeof e != "function") throw new TypeError("callback must be a function");
          this.#t = e, this.#r = r, this.#i = n;
        }
        onRequestStart(e, r) {
          this.#e = false, this.#n = r;
        }
        onRequestUpgrade(e, r, n, A) {
          this.#r.onRequestUpgrade?.(e, r, n, A);
        }
        onResponseStart(e, r, n, A) {
          if (PO(this.#t != null), this.#e = r === 304 || this.#i && r >= 500 && r <= 504, this.#t(this.#e, this.#n), this.#t = null, this.#e) return true;
          this.#r.onRequestStart?.(e, this.#n), this.#r.onResponseStart?.(e, r, n, A);
        }
        onResponseData(e, r) {
          if (!this.#e) return this.#r.onResponseData?.(e, r);
        }
        onResponseEnd(e, r) {
          this.#e || this.#r.onResponseEnd?.(e, r);
        }
        onResponseError(e, r) {
          if (!this.#e) if (this.#t && (this.#t(false), this.#t = null), typeof this.#r.onResponseError == "function") this.#r.onResponseError(e, r);
          else throw r;
        }
      };
      qD.exports = Kd;
    });
    var XD = C((G$, ZD) => {
      "use strict";
      var WD = require("node:assert"), { Readable: YO } = require("node:stream"), _A = Y(), Lc = OD(), GO = Xd(), OO = JD(), { assertCacheStore: VO, assertCacheMethods: HO, makeCacheKey: qO, parseCacheControlHeader: JO } = Fs(), { AbortError: WO } = H();
      function _O(t, e) {
        if (e?.["no-cache"]) return true;
        let r = Date.now();
        if (r > t.staleAt) {
          if (e?.["max-stale"]) {
            let n = t.staleAt + e["max-stale"] * 1e3;
            return r > n;
          }
          return true;
        }
        if (e?.["min-fresh"]) {
          let n = t.staleAt - r, A = e["min-fresh"] * 1e3;
          return n <= A;
        }
        return false;
      }
      function jO(t, e, r, n, A, i) {
        if (i?.["only-if-cached"]) {
          let s = false;
          try {
            if (typeof n.onConnect == "function" && (n.onConnect(() => {
              s = true;
            }), s) || typeof n.onHeaders == "function" && (n.onHeaders(504, [], () => {
            }, "Gateway Timeout"), s)) return;
            typeof n.onComplete == "function" && n.onComplete([]);
          } catch (o) {
            typeof n.onError == "function" && n.onError(o);
          }
          return true;
        }
        return t(A, new Lc(e, r, n));
      }
      function _D(t, e, r, n, A, i) {
        let s = _A.isStream(r.body) ? r.body : YO.from(r.body ?? []);
        WD(!s.destroyed, "stream should not be destroyed"), WD(!s.readableDidRead, "stream should not be readableDidRead");
        let o = { resume() {
          s.resume();
        }, pause() {
          s.pause();
        }, get paused() {
          return s.isPaused();
        }, get aborted() {
          return s.destroyed;
        }, get reason() {
          return s.errored;
        }, abort(c) {
          s.destroy(c ?? new WO());
        } };
        if (s.on("error", function(c) {
          if (!this.readableEnded) if (typeof t.onResponseError == "function") t.onResponseError(o, c);
          else throw c;
        }).on("close", function() {
          this.errored || t.onResponseEnd?.(o, {});
        }), t.onRequestStart?.(o, A), s.destroyed) return;
        let a = { ...r.headers, age: String(n) };
        i && (a.warning = '110 - "response is stale"'), t.onResponseStart?.(o, r.statusCode, a, r.statusMessage), e.method === "HEAD" ? s.destroy() : s.on("data", function(c) {
          t.onResponseData?.(o, c);
        });
      }
      function jD(t, e, r, n, A, i, s) {
        if (!s) return jO(t, e, r, n, A, i);
        let o = Date.now();
        if (o > s.deleteAt) return t(A, new Lc(e, r, n));
        let a = Math.round((o - s.cachedAt) / 1e3);
        if (i?.["max-age"] && a >= i["max-age"]) return t(A, n);
        if (_O(s, i)) {
          if (_A.isStream(A.body) && _A.bodyLength(A.body) !== 0) return t(A, new Lc(e, r, n));
          let c = false, l = s.cacheControlDirectives["stale-if-error"] ?? i?.["stale-if-error"];
          l && (c = o < s.staleAt + l * 1e3);
          let u = { ...A.headers, "if-modified-since": new Date(s.cachedAt).toUTCString() };
          return s.etag && (u["if-none-match"] = s.etag), s.vary && (u = { ...u, ...s.vary }), t({ ...A, headers: u }, new OO((g, E) => {
            g ? _D(n, A, s, a, E, true) : _A.isStream(s.body) && s.body.on("error", () => {
            }).destroy();
          }, new Lc(e, r, n), c));
        }
        _A.isStream(A.body) && A.body.on("error", () => {
        }).destroy(), _D(n, A, s, a, null, false);
      }
      ZD.exports = (t = {}) => {
        let { store: e = new GO(), methods: r = ["GET"], cacheByDefault: n = void 0, type: A = "shared" } = t;
        if (typeof t != "object" || t === null) throw new TypeError(`expected type of opts to be an Object, got ${t === null ? "null" : typeof t}`);
        if (VO(e, "opts.store"), HO(r, "opts.methods"), typeof n < "u" && typeof n != "number") throw new TypeError(`exepcted opts.cacheByDefault to be number or undefined, got ${typeof n}`);
        if (typeof A < "u" && A !== "shared" && A !== "private") throw new TypeError(`exepcted opts.type to be shared, private, or undefined, got ${typeof A}`);
        let i = { store: e, methods: r, cacheByDefault: n, type: A }, s = _A.safeHTTPMethods.filter((o) => r.includes(o) === false);
        return (o) => (a, c) => {
          if (!a.origin || s.includes(a.method)) return o(a, c);
          let l = a.headers?.["cache-control"] ? JO(a.headers["cache-control"]) : void 0;
          if (l?.["no-store"]) return o(a, c);
          let u = qO(a), g = e.get(u);
          return g && typeof g.then == "function" ? g.then((E) => {
            jD(o, i, u, c, a, l, E);
          }) : jD(o, i, u, c, a, l, g), true;
        };
      };
    });
    var zD = C((V$, $D) => {
      "use strict";
      var { Writable: ZO } = require("node:stream"), { assertCacheKey: $d, assertCacheValue: XO } = Fs(), zd, qe = 3, KD = 2 * 1e3 * 1e3 * 1e3;
      $D.exports = class {
        #e = KD;
        #t = 1 / 0;
        #r;
        #n;
        #i;
        #A;
        #a;
        #s;
        #o;
        #c;
        constructor(e) {
          if (e) {
            if (typeof e != "object") throw new TypeError("SqliteCacheStore options must be an object");
            if (e.maxEntrySize !== void 0) {
              if (typeof e.maxEntrySize != "number" || !Number.isInteger(e.maxEntrySize) || e.maxEntrySize < 0) throw new TypeError("SqliteCacheStore options.maxEntrySize must be a non-negative integer");
              if (e.maxEntrySize > KD) throw new TypeError("SqliteCacheStore options.maxEntrySize must be less than 2gb");
              this.#e = e.maxEntrySize;
            }
            if (e.maxCount !== void 0) {
              if (typeof e.maxCount != "number" || !Number.isInteger(e.maxCount) || e.maxCount < 0) throw new TypeError("SqliteCacheStore options.maxCount must be a non-negative integer");
              this.#t = e.maxCount;
            }
          }
          zd || (zd = require("node:sqlite").DatabaseSync), this.#r = new zd(e?.location ?? ":memory:"), this.#r.exec(`
      CREATE TABLE IF NOT EXISTS cacheInterceptorV${qe} (
        -- Data specific to us
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        url TEXT NOT NULL,
        method TEXT NOT NULL,

        -- Data returned to the interceptor
        body BUF NULL,
        deleteAt INTEGER NOT NULL,
        statusCode INTEGER NOT NULL,
        statusMessage TEXT NOT NULL,
        headers TEXT NULL,
        cacheControlDirectives TEXT NULL,
        etag TEXT NULL,
        vary TEXT NULL,
        cachedAt INTEGER NOT NULL,
        staleAt INTEGER NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${qe}_url ON cacheInterceptorV${qe}(url);
      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${qe}_method ON cacheInterceptorV${qe}(method);
      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${qe}_deleteAt ON cacheInterceptorV${qe}(deleteAt);
    `), this.#n = this.#r.prepare(`
      SELECT
        id,
        body,
        deleteAt,
        statusCode,
        statusMessage,
        headers,
        etag,
        cacheControlDirectives,
        vary,
        cachedAt,
        staleAt
      FROM cacheInterceptorV${qe}
      WHERE
        url = ?
        AND method = ?
      ORDER BY
        deleteAt ASC
    `), this.#i = this.#r.prepare(`
      UPDATE cacheInterceptorV${qe} SET
        body = ?,
        deleteAt = ?,
        statusCode = ?,
        statusMessage = ?,
        headers = ?,
        etag = ?,
        cacheControlDirectives = ?,
        cachedAt = ?,
        staleAt = ?
      WHERE
        id = ?
    `), this.#A = this.#r.prepare(`
      INSERT INTO cacheInterceptorV${qe} (
        url,
        method,
        body,
        deleteAt,
        statusCode,
        statusMessage,
        headers,
        etag,
        cacheControlDirectives,
        vary,
        cachedAt,
        staleAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `), this.#s = this.#r.prepare(`DELETE FROM cacheInterceptorV${qe} WHERE url = ?`), this.#o = this.#r.prepare(`SELECT COUNT(*) AS total FROM cacheInterceptorV${qe}`), this.#a = this.#r.prepare(`DELETE FROM cacheInterceptorV${qe} WHERE deleteAt <= ?`), this.#c = this.#t === 1 / 0 ? null : this.#r.prepare(`
        DELETE FROM cacheInterceptorV${qe}
        WHERE id IN (
          SELECT
            id
          FROM cacheInterceptorV${qe}
          ORDER BY cachedAt DESC
          LIMIT ?
        )
      `);
        }
        close() {
          this.#r.close();
        }
        get(e) {
          $d(e);
          let r = this.#u(e);
          return r ? { body: r.body ? Buffer.from(r.body.buffer, r.body.byteOffset, r.body.byteLength) : void 0, statusCode: r.statusCode, statusMessage: r.statusMessage, headers: r.headers ? JSON.parse(r.headers) : void 0, etag: r.etag ? r.etag : void 0, vary: r.vary ? JSON.parse(r.vary) : void 0, cacheControlDirectives: r.cacheControlDirectives ? JSON.parse(r.cacheControlDirectives) : void 0, cachedAt: r.cachedAt, staleAt: r.staleAt, deleteAt: r.deleteAt } : void 0;
        }
        set(e, r) {
          $d(e);
          let n = this.#l(e), A = Array.isArray(r.body) ? Buffer.concat(r.body) : r.body, i = A?.byteLength;
          if (i && i > this.#e) return;
          let s = this.#u(e, true);
          s ? this.#i.run(A, r.deleteAt, r.statusCode, r.statusMessage, r.headers ? JSON.stringify(r.headers) : null, r.etag ? r.etag : null, r.cacheControlDirectives ? JSON.stringify(r.cacheControlDirectives) : null, r.cachedAt, r.staleAt, s.id) : (this.#g(), this.#A.run(n, e.method, A, r.deleteAt, r.statusCode, r.statusMessage, r.headers ? JSON.stringify(r.headers) : null, r.etag ? r.etag : null, r.cacheControlDirectives ? JSON.stringify(r.cacheControlDirectives) : null, r.vary ? JSON.stringify(r.vary) : null, r.cachedAt, r.staleAt));
        }
        createWriteStream(e, r) {
          $d(e), XO(r);
          let n = 0, A = [], i = this;
          return new ZO({ decodeStrings: true, write(s, o, a) {
            n += s.byteLength, n < i.#e ? A.push(s) : this.destroy(), a();
          }, final(s) {
            i.set(e, { ...r, body: A }), s();
          } });
        }
        delete(e) {
          if (typeof e != "object") throw new TypeError(`expected key to be object, got ${typeof e}`);
          this.#s.run(this.#l(e));
        }
        #g() {
          if (this.size <= this.#t) return 0;
          {
            let e = this.#a.run(Date.now()).changes;
            if (e) return e;
          }
          {
            let e = this.#c?.run(Math.max(Math.floor(this.#t * 0.1), 1)).changes;
            if (e) return e;
          }
          return 0;
        }
        get size() {
          let { total: e } = this.#o.get();
          return e;
        }
        #l(e) {
          return `${e.origin}/${e.path}`;
        }
        #u(e, r = false) {
          let n = this.#l(e), { headers: A, method: i } = e, s = this.#n.all(n, i);
          if (s.length === 0) return;
          let o = Date.now();
          for (let a of s) {
            if (o >= a.deleteAt && !r) return;
            let c = true;
            if (a.vary) {
              let l = JSON.parse(a.vary);
              for (let u in l) if (!KO(A[u], l[u])) {
                c = false;
                break;
              }
            }
            if (c) return a;
          }
        }
      };
      function KO(t, e) {
        return t == null && e == null ? true : t == null && e != null || t != null && e == null ? false : Array.isArray(t) && Array.isArray(e) ? t.length !== e.length ? false : t.every((r, n) => r === e[n]) : t === e;
      }
    });
    var Tn = C((H$, s0) => {
      "use strict";
      var { kConstruct: $O } = ne(), { kEnumerableProperty: jA } = Y(), { iteratorMixin: zO, isValidHeaderName: Ts, isValidHeaderValue: t0 } = Ve(), { webidl: V } = Te(), eh = require("node:assert"), vc = require("node:util");
      function e0(t) {
        return t === 10 || t === 13 || t === 9 || t === 32;
      }
      function r0(t) {
        let e = 0, r = t.length;
        for (; r > e && e0(t.charCodeAt(r - 1)); ) --r;
        for (; r > e && e0(t.charCodeAt(e)); ) ++e;
        return e === 0 && r === t.length ? t : t.substring(e, r);
      }
      function n0(t, e) {
        if (Array.isArray(e)) for (let r = 0; r < e.length; ++r) {
          let n = e[r];
          if (n.length !== 2) throw V.errors.exception({ header: "Headers constructor", message: `expected name/value pair to be length 2, found ${n.length}.` });
          th(t, n[0], n[1]);
        }
        else if (typeof e == "object" && e !== null) {
          let r = Object.keys(e);
          for (let n = 0; n < r.length; ++n) th(t, r[n], e[r[n]]);
        } else throw V.errors.conversionFailed({ prefix: "Headers constructor", argument: "Argument 1", types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"] });
      }
      function th(t, e, r) {
        if (r = r0(r), Ts(e)) {
          if (!t0(r)) throw V.errors.invalidArgument({ prefix: "Headers.append", value: r, type: "header value" });
        } else throw V.errors.invalidArgument({ prefix: "Headers.append", value: e, type: "header name" });
        if (i0(t) === "immutable") throw new TypeError("immutable");
        return Yc(t).append(e, r, false);
      }
      function eV(t) {
        let e = Yc(t);
        if (!e) return [];
        if (e.sortedMap) return e.sortedMap;
        let r = [], n = e.toSortedArray(), A = e.cookies;
        if (A === null || A.length === 1) return e.sortedMap = n;
        for (let i = 0; i < n.length; ++i) {
          let { 0: s, 1: o } = n[i];
          if (s === "set-cookie") for (let a = 0; a < A.length; ++a) r.push([s, A[a]]);
          else r.push([s, o]);
        }
        return e.sortedMap = r;
      }
      function A0(t, e) {
        return t[0] < e[0] ? -1 : 1;
      }
      var Pc = class t {
        cookies = null;
        sortedMap;
        headersMap;
        constructor(e) {
          e instanceof t ? (this.headersMap = new Map(e.headersMap), this.sortedMap = e.sortedMap, this.cookies = e.cookies === null ? null : [...e.cookies]) : (this.headersMap = new Map(e), this.sortedMap = null);
        }
        contains(e, r) {
          return this.headersMap.has(r ? e : e.toLowerCase());
        }
        clear() {
          this.headersMap.clear(), this.sortedMap = null, this.cookies = null;
        }
        append(e, r, n) {
          this.sortedMap = null;
          let A = n ? e : e.toLowerCase(), i = this.headersMap.get(A);
          if (i) {
            let s = A === "cookie" ? "; " : ", ";
            this.headersMap.set(A, { name: i.name, value: `${i.value}${s}${r}` });
          } else this.headersMap.set(A, { name: e, value: r });
          A === "set-cookie" && (this.cookies ??= []).push(r);
        }
        set(e, r, n) {
          this.sortedMap = null;
          let A = n ? e : e.toLowerCase();
          A === "set-cookie" && (this.cookies = [r]), this.headersMap.set(A, { name: e, value: r });
        }
        delete(e, r) {
          this.sortedMap = null, r || (e = e.toLowerCase()), e === "set-cookie" && (this.cookies = null), this.headersMap.delete(e);
        }
        get(e, r) {
          return this.headersMap.get(r ? e : e.toLowerCase())?.value ?? null;
        }
        *[Symbol.iterator]() {
          for (let { 0: e, 1: { value: r } } of this.headersMap) yield [e, r];
        }
        get entries() {
          let e = {};
          if (this.headersMap.size !== 0) for (let { name: r, value: n } of this.headersMap.values()) e[r] = n;
          return e;
        }
        rawValues() {
          return this.headersMap.values();
        }
        get entriesList() {
          let e = [];
          if (this.headersMap.size !== 0) for (let { 0: r, 1: { name: n, value: A } } of this.headersMap) if (r === "set-cookie") for (let i of this.cookies) e.push([n, i]);
          else e.push([n, A]);
          return e;
        }
        toSortedArray() {
          let e = this.headersMap.size, r = new Array(e);
          if (e <= 32) {
            if (e === 0) return r;
            let n = this.headersMap[Symbol.iterator](), A = n.next().value;
            r[0] = [A[0], A[1].value], eh(A[1].value !== null);
            for (let i = 1, s = 0, o = 0, a = 0, c = 0, l, u; i < e; ++i) {
              for (u = n.next().value, l = r[i] = [u[0], u[1].value], eh(l[1] !== null), a = 0, o = i; a < o; ) c = a + (o - a >> 1), r[c][0] <= l[0] ? a = c + 1 : o = c;
              if (i !== c) {
                for (s = i; s > a; ) r[s] = r[--s];
                r[a] = l;
              }
            }
            if (!n.next().done) throw new TypeError("Unreachable");
            return r;
          } else {
            let n = 0;
            for (let { 0: A, 1: { value: i } } of this.headersMap) r[n++] = [A, i], eh(i !== null);
            return r.sort(A0);
          }
        }
      }, Nt = class t {
        #e;
        #t;
        constructor(e = void 0) {
          V.util.markAsUncloneable(this), e !== $O && (this.#t = new Pc(), this.#e = "none", e !== void 0 && (e = V.converters.HeadersInit(e, "Headers constructor", "init"), n0(this, e)));
        }
        append(e, r) {
          V.brandCheck(this, t), V.argumentLengthCheck(arguments, 2, "Headers.append");
          let n = "Headers.append";
          return e = V.converters.ByteString(e, n, "name"), r = V.converters.ByteString(r, n, "value"), th(this, e, r);
        }
        delete(e) {
          if (V.brandCheck(this, t), V.argumentLengthCheck(arguments, 1, "Headers.delete"), e = V.converters.ByteString(e, "Headers.delete", "name"), !Ts(e)) throw V.errors.invalidArgument({ prefix: "Headers.delete", value: e, type: "header name" });
          if (this.#e === "immutable") throw new TypeError("immutable");
          this.#t.contains(e, false) && this.#t.delete(e, false);
        }
        get(e) {
          V.brandCheck(this, t), V.argumentLengthCheck(arguments, 1, "Headers.get");
          let r = "Headers.get";
          if (e = V.converters.ByteString(e, r, "name"), !Ts(e)) throw V.errors.invalidArgument({ prefix: r, value: e, type: "header name" });
          return this.#t.get(e, false);
        }
        has(e) {
          V.brandCheck(this, t), V.argumentLengthCheck(arguments, 1, "Headers.has");
          let r = "Headers.has";
          if (e = V.converters.ByteString(e, r, "name"), !Ts(e)) throw V.errors.invalidArgument({ prefix: r, value: e, type: "header name" });
          return this.#t.contains(e, false);
        }
        set(e, r) {
          V.brandCheck(this, t), V.argumentLengthCheck(arguments, 2, "Headers.set");
          let n = "Headers.set";
          if (e = V.converters.ByteString(e, n, "name"), r = V.converters.ByteString(r, n, "value"), r = r0(r), Ts(e)) {
            if (!t0(r)) throw V.errors.invalidArgument({ prefix: n, value: r, type: "header value" });
          } else throw V.errors.invalidArgument({ prefix: n, value: e, type: "header name" });
          if (this.#e === "immutable") throw new TypeError("immutable");
          this.#t.set(e, r, false);
        }
        getSetCookie() {
          V.brandCheck(this, t);
          let e = this.#t.cookies;
          return e ? [...e] : [];
        }
        [vc.inspect.custom](e, r) {
          return r.depth ??= e, `Headers ${vc.formatWithOptions(r, this.#t.entries)}`;
        }
        static getHeadersGuard(e) {
          return e.#e;
        }
        static setHeadersGuard(e, r) {
          e.#e = r;
        }
        static getHeadersList(e) {
          return e.#t;
        }
        static setHeadersList(e, r) {
          e.#t = r;
        }
      }, { getHeadersGuard: i0, setHeadersGuard: tV, getHeadersList: Yc, setHeadersList: rV } = Nt;
      Reflect.deleteProperty(Nt, "getHeadersGuard");
      Reflect.deleteProperty(Nt, "setHeadersGuard");
      Reflect.deleteProperty(Nt, "getHeadersList");
      Reflect.deleteProperty(Nt, "setHeadersList");
      zO("Headers", Nt, eV, 0, 1);
      Object.defineProperties(Nt.prototype, { append: jA, delete: jA, get: jA, has: jA, set: jA, getSetCookie: jA, [Symbol.toStringTag]: { value: "Headers", configurable: true }, [vc.inspect.custom]: { enumerable: false } });
      V.converters.HeadersInit = function(t, e, r) {
        if (V.util.Type(t) === V.util.Types.OBJECT) {
          let n = Reflect.get(t, Symbol.iterator);
          if (!vc.types.isProxy(t) && n === Nt.prototype.entries) try {
            return Yc(t).entriesList;
          } catch {
          }
          return typeof n == "function" ? V.converters["sequence<sequence<ByteString>>"](t, e, r, n.bind(t)) : V.converters["record<ByteString, ByteString>"](t, e, r);
        }
        throw V.errors.conversionFailed({ prefix: "Headers constructor", argument: "Argument 1", types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"] });
      };
      s0.exports = { fill: n0, compareHeaderName: A0, Headers: Nt, HeadersList: Pc, getHeadersGuard: i0, setHeadersGuard: tV, setHeadersList: rV, getHeadersList: Yc };
    });
    var Us = C((q$, Q0) => {
      "use strict";
      var { Headers: g0, HeadersList: o0, fill: nV, getHeadersGuard: AV, setHeadersGuard: E0, setHeadersList: d0 } = Tn(), { extractBody: a0, cloneBody: iV, mixinBody: sV, hasFinalizationRegistry: oV, streamRegistry: aV, bodyUnusable: cV } = FA(), h0 = Y(), c0 = require("node:util"), { kEnumerableProperty: At } = h0, { isValidReasonPhrase: lV, isCancelled: uV, isAborted: gV, serializeJavascriptValueToJSONString: EV, isErrorLike: dV, isomorphicEncode: hV, environmentSettingsObject: fV } = Ve(), { redirectStatusSet: QV, nullBodyStatus: CV } = ts(), { webidl: O } = Te(), { URLSerializer: l0 } = tt(), { kConstruct: Oc } = ne(), rh = require("node:assert"), { types: IV } = require("node:util"), pV = new TextEncoder("utf-8"), it = class t {
        #e;
        #t;
        static error() {
          return xs(Vc(), "immutable");
        }
        static json(e, r = void 0) {
          O.argumentLengthCheck(arguments, 1, "Response.json"), r !== null && (r = O.converters.ResponseInit(r));
          let n = pV.encode(EV(e)), A = a0(n), i = xs(ZA({}), "response");
          return u0(i, r, { body: A[0], type: "application/json" }), i;
        }
        static redirect(e, r = 302) {
          O.argumentLengthCheck(arguments, 1, "Response.redirect"), e = O.converters.USVString(e), r = O.converters["unsigned short"](r);
          let n;
          try {
            n = new URL(e, fV.settingsObject.baseUrl);
          } catch (s) {
            throw new TypeError(`Failed to parse URL from ${e}`, { cause: s });
          }
          if (!QV.has(r)) throw new RangeError(`Invalid status code ${r}`);
          let A = xs(ZA({}), "immutable");
          A.#t.status = r;
          let i = hV(l0(n));
          return A.#t.headersList.append("location", i, true), A;
        }
        constructor(e = null, r = void 0) {
          if (O.util.markAsUncloneable(this), e === Oc) return;
          e !== null && (e = O.converters.BodyInit(e)), r = O.converters.ResponseInit(r), this.#t = ZA({}), this.#e = new g0(Oc), E0(this.#e, "response"), d0(this.#e, this.#t.headersList);
          let n = null;
          if (e != null) {
            let [A, i] = a0(e);
            n = { body: A, type: i };
          }
          u0(this, r, n);
        }
        get type() {
          return O.brandCheck(this, t), this.#t.type;
        }
        get url() {
          O.brandCheck(this, t);
          let e = this.#t.urlList, r = e[e.length - 1] ?? null;
          return r === null ? "" : l0(r, true);
        }
        get redirected() {
          return O.brandCheck(this, t), this.#t.urlList.length > 1;
        }
        get status() {
          return O.brandCheck(this, t), this.#t.status;
        }
        get ok() {
          return O.brandCheck(this, t), this.#t.status >= 200 && this.#t.status <= 299;
        }
        get statusText() {
          return O.brandCheck(this, t), this.#t.statusText;
        }
        get headers() {
          return O.brandCheck(this, t), this.#e;
        }
        get body() {
          return O.brandCheck(this, t), this.#t.body ? this.#t.body.stream : null;
        }
        get bodyUsed() {
          return O.brandCheck(this, t), !!this.#t.body && h0.isDisturbed(this.#t.body.stream);
        }
        clone() {
          if (O.brandCheck(this, t), cV(this.#t)) throw O.errors.exception({ header: "Response.clone", message: "Body has already been consumed." });
          let e = nh(this.#t);
          return xs(e, AV(this.#e));
        }
        [c0.inspect.custom](e, r) {
          r.depth === null && (r.depth = 2), r.colors ??= true;
          let n = { status: this.status, statusText: this.statusText, headers: this.headers, body: this.body, bodyUsed: this.bodyUsed, ok: this.ok, redirected: this.redirected, type: this.type, url: this.url };
          return `Response ${c0.formatWithOptions(r, n)}`;
        }
        static getResponseHeaders(e) {
          return e.#e;
        }
        static setResponseHeaders(e, r) {
          e.#e = r;
        }
        static getResponseState(e) {
          return e.#t;
        }
        static setResponseState(e, r) {
          e.#t = r;
        }
      }, { getResponseHeaders: BV, setResponseHeaders: mV, getResponseState: xn, setResponseState: yV } = it;
      Reflect.deleteProperty(it, "getResponseHeaders");
      Reflect.deleteProperty(it, "setResponseHeaders");
      Reflect.deleteProperty(it, "getResponseState");
      Reflect.deleteProperty(it, "setResponseState");
      sV(it, xn);
      Object.defineProperties(it.prototype, { type: At, url: At, status: At, ok: At, redirected: At, statusText: At, headers: At, clone: At, body: At, bodyUsed: At, [Symbol.toStringTag]: { value: "Response", configurable: true } });
      Object.defineProperties(it, { json: At, redirect: At, error: At });
      function nh(t) {
        if (t.internalResponse) return f0(nh(t.internalResponse), t.type);
        let e = ZA({ ...t, body: null });
        return t.body != null && (e.body = iV(e, t.body)), e;
      }
      function ZA(t) {
        return { aborted: false, rangeRequested: false, timingAllowPassed: false, requestIncludesCredentials: false, type: "default", status: 200, timingInfo: null, cacheState: "", statusText: "", ...t, headersList: t?.headersList ? new o0(t?.headersList) : new o0(), urlList: t?.urlList ? [...t.urlList] : [] };
      }
      function Vc(t) {
        let e = dV(t);
        return ZA({ type: "error", status: 0, error: e ? t : new Error(t && String(t)), aborted: t && t.name === "AbortError" });
      }
      function wV(t) {
        return t.type === "error" && t.status === 0;
      }
      function Gc(t, e) {
        return e = { internalResponse: t, ...e }, new Proxy(t, { get(r, n) {
          return n in e ? e[n] : r[n];
        }, set(r, n, A) {
          return rh(!(n in e)), r[n] = A, true;
        } });
      }
      function f0(t, e) {
        if (e === "basic") return Gc(t, { type: "basic", headersList: t.headersList });
        if (e === "cors") return Gc(t, { type: "cors", headersList: t.headersList });
        if (e === "opaque") return Gc(t, { type: "opaque", urlList: Object.freeze([]), status: 0, statusText: "", body: null });
        if (e === "opaqueredirect") return Gc(t, { type: "opaqueredirect", status: 0, statusText: "", headersList: [], body: null });
        rh(false);
      }
      function DV(t, e = null) {
        return rh(uV(t)), gV(t) ? Vc(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: e })) : Vc(Object.assign(new DOMException("Request was cancelled."), { cause: e }));
      }
      function u0(t, e, r) {
        if (e.status !== null && (e.status < 200 || e.status > 599)) throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
        if ("statusText" in e && e.statusText != null && !lV(String(e.statusText))) throw new TypeError("Invalid statusText");
        if ("status" in e && e.status != null && (xn(t).status = e.status), "statusText" in e && e.statusText != null && (xn(t).statusText = e.statusText), "headers" in e && e.headers != null && nV(BV(t), e.headers), r) {
          if (CV.includes(t.status)) throw O.errors.exception({ header: "Response constructor", message: `Invalid response status code ${t.status}` });
          xn(t).body = r.body, r.type != null && !xn(t).headersList.contains("content-type", true) && xn(t).headersList.append("content-type", r.type, true);
        }
      }
      function xs(t, e) {
        let r = new it(Oc);
        yV(r, t);
        let n = new g0(Oc);
        return mV(r, n), d0(n, t.headersList), E0(n, e), oV && t.body?.stream && aV.register(r, new WeakRef(t.body.stream)), r;
      }
      O.converters.XMLHttpRequestBodyInit = function(t, e, r) {
        return typeof t == "string" ? O.converters.USVString(t, e, r) : O.is.Blob(t) || ArrayBuffer.isView(t) || IV.isArrayBuffer(t) || O.is.FormData(t) || O.is.URLSearchParams(t) ? t : O.converters.DOMString(t, e, r);
      };
      O.converters.BodyInit = function(t, e, r) {
        return O.is.ReadableStream(t) || t?.[Symbol.asyncIterator] ? t : O.converters.XMLHttpRequestBodyInit(t, e, r);
      };
      O.converters.ResponseInit = O.dictionaryConverter([{ key: "status", converter: O.converters["unsigned short"], defaultValue: () => 200 }, { key: "statusText", converter: O.converters.ByteString, defaultValue: () => "" }, { key: "headers", converter: O.converters.HeadersInit }]);
      O.is.Response = O.util.MakeTypeAssertion(it);
      Q0.exports = { isNetworkError: wV, makeNetworkError: Vc, makeResponse: ZA, makeAppropriateNetworkError: DV, filterResponse: f0, Response: it, cloneResponse: nh, fromInnerResponse: xs, getResponseState: xn };
    });
    var B0 = C((J$, p0) => {
      "use strict";
      var { kConnected: C0, kSize: I0 } = ne(), Ah = class {
        constructor(e) {
          this.value = e;
        }
        deref() {
          return this.value[C0] === 0 && this.value[I0] === 0 ? void 0 : this.value;
        }
      }, ih = class {
        constructor(e) {
          this.finalizer = e;
        }
        register(e, r) {
          e.on && e.on("disconnect", () => {
            e[C0] === 0 && e[I0] === 0 && this.finalizer(r);
          });
        }
        unregister(e) {
        }
      };
      p0.exports = function() {
        return process.env.NODE_V8_COVERAGE && process.version.startsWith("v18") ? (process._rawDebug("Using compatibility WeakRef and FinalizationRegistry"), { WeakRef: Ah, FinalizationRegistry: ih }) : { WeakRef, FinalizationRegistry };
      };
    });
    var XA = C((W$, M0) => {
      "use strict";
      var { extractBody: RV, mixinBody: SV, cloneBody: bV, bodyUnusable: m0 } = FA(), { Headers: b0, fill: NV, HeadersList: Jc, setHeadersGuard: sh, getHeadersGuard: FV, setHeadersList: N0, getHeadersList: y0 } = Tn(), { FinalizationRegistry: TV } = B0()(), qc = Y(), w0 = require("node:util"), { isValidHTTPToken: xV, sameOrigin: D0, environmentSettingsObject: Hc } = Ve(), { forbiddenMethodsSet: UV, corsSafeListedMethodsSet: kV, referrerPolicy: MV, requestRedirect: LV, requestMode: vV, requestCredentials: PV, requestCache: YV, requestDuplex: GV } = ts(), { kEnumerableProperty: Ie, normalizedMethodRecordsBase: OV, normalizedMethodRecords: VV } = qc, { webidl: F } = Te(), { URLSerializer: HV } = tt(), { kConstruct: Wc } = ne(), qV = require("node:assert"), { getMaxListeners: F0, setMaxListeners: JV, defaultMaxListeners: WV } = require("node:events"), _V = /* @__PURE__ */ Symbol("abortController"), T0 = new TV(({ signal: t, abort: e }) => {
        t.removeEventListener("abort", e);
      }), _c = /* @__PURE__ */ new WeakMap(), oh;
      try {
        oh = F0(new AbortController().signal) > 0;
      } catch {
        oh = false;
      }
      function R0(t) {
        return e;
        function e() {
          let r = t.deref();
          if (r !== void 0) {
            T0.unregister(e), this.removeEventListener("abort", e), r.abort(this.reason);
            let n = _c.get(r.signal);
            if (n !== void 0) {
              if (n.size !== 0) {
                for (let A of n) {
                  let i = A.deref();
                  i !== void 0 && i.abort(this.reason);
                }
                n.clear();
              }
              _c.delete(r.signal);
            }
          }
        }
      }
      var S0 = false, Xe = class t {
        #e;
        #t;
        #r;
        #n;
        constructor(e, r = void 0) {
          if (F.util.markAsUncloneable(this), e === Wc) return;
          let n = "Request constructor";
          F.argumentLengthCheck(arguments, 1, n), e = F.converters.RequestInfo(e, n, "input"), r = F.converters.RequestInit(r, n, "init");
          let A = null, i = null, s = Hc.settingsObject.baseUrl, o = null;
          if (typeof e == "string") {
            this.#t = r.dispatcher;
            let Q;
            try {
              Q = new URL(e, s);
            } catch (I) {
              throw new TypeError("Failed to parse URL from " + e, { cause: I });
            }
            if (Q.username || Q.password) throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + e);
            A = jc({ urlList: [Q] }), i = "cors";
          } else qV(F.is.Request(e)), A = e.#n, o = e.#e, this.#t = r.dispatcher || e.#t;
          let a = Hc.settingsObject.origin, c = "client";
          if (A.window?.constructor?.name === "EnvironmentSettingsObject" && D0(A.window, a) && (c = A.window), r.window != null) throw new TypeError(`'window' option '${c}' must be null`);
          "window" in r && (c = "no-window"), A = jc({ method: A.method, headersList: A.headersList, unsafeRequest: A.unsafeRequest, client: Hc.settingsObject, window: c, priority: A.priority, origin: A.origin, referrer: A.referrer, referrerPolicy: A.referrerPolicy, mode: A.mode, credentials: A.credentials, cache: A.cache, redirect: A.redirect, integrity: A.integrity, keepalive: A.keepalive, reloadNavigation: A.reloadNavigation, historyNavigation: A.historyNavigation, urlList: [...A.urlList] });
          let l = Object.keys(r).length !== 0;
          if (l && (A.mode === "navigate" && (A.mode = "same-origin"), A.reloadNavigation = false, A.historyNavigation = false, A.origin = "client", A.referrer = "client", A.referrerPolicy = "", A.url = A.urlList[A.urlList.length - 1], A.urlList = [A.url]), r.referrer !== void 0) {
            let Q = r.referrer;
            if (Q === "") A.referrer = "no-referrer";
            else {
              let I;
              try {
                I = new URL(Q, s);
              } catch (B) {
                throw new TypeError(`Referrer "${Q}" is not a valid URL.`, { cause: B });
              }
              I.protocol === "about:" && I.hostname === "client" || a && !D0(I, Hc.settingsObject.baseUrl) ? A.referrer = "client" : A.referrer = I;
            }
          }
          r.referrerPolicy !== void 0 && (A.referrerPolicy = r.referrerPolicy);
          let u;
          if (r.mode !== void 0 ? u = r.mode : u = i, u === "navigate") throw F.errors.exception({ header: "Request constructor", message: "invalid request mode navigate." });
          if (u != null && (A.mode = u), r.credentials !== void 0 && (A.credentials = r.credentials), r.cache !== void 0 && (A.cache = r.cache), A.cache === "only-if-cached" && A.mode !== "same-origin") throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
          if (r.redirect !== void 0 && (A.redirect = r.redirect), r.integrity != null && (A.integrity = String(r.integrity)), r.keepalive !== void 0 && (A.keepalive = !!r.keepalive), r.method !== void 0) {
            let Q = r.method, I = VV[Q];
            if (I !== void 0) A.method = I;
            else {
              if (!xV(Q)) throw new TypeError(`'${Q}' is not a valid HTTP method.`);
              let B = Q.toUpperCase();
              if (UV.has(B)) throw new TypeError(`'${Q}' HTTP method is unsupported.`);
              Q = OV[B] ?? Q, A.method = Q;
            }
            !S0 && A.method === "patch" && (process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", { code: "UNDICI-FETCH-patch" }), S0 = true);
          }
          r.signal !== void 0 && (o = r.signal), this.#n = A;
          let g = new AbortController();
          if (this.#e = g.signal, o != null) if (o.aborted) g.abort(o.reason);
          else {
            this[_V] = g;
            let Q = new WeakRef(g), I = R0(Q);
            oh && F0(o) === WV && JV(1500, o), qc.addAbortListener(o, I), T0.register(g, { signal: o, abort: I }, I);
          }
          if (this.#r = new b0(Wc), N0(this.#r, A.headersList), sh(this.#r, "request"), u === "no-cors") {
            if (!kV.has(A.method)) throw new TypeError(`'${A.method} is unsupported in no-cors mode.`);
            sh(this.#r, "request-no-cors");
          }
          if (l) {
            let Q = y0(this.#r), I = r.headers !== void 0 ? r.headers : new Jc(Q);
            if (Q.clear(), I instanceof Jc) {
              for (let { name: B, value: w } of I.rawValues()) Q.append(B, w, false);
              Q.cookies = I.cookies;
            } else NV(this.#r, I);
          }
          let E = F.is.Request(e) ? e.#n.body : null;
          if ((r.body != null || E != null) && (A.method === "GET" || A.method === "HEAD")) throw new TypeError("Request with GET/HEAD method cannot have body.");
          let h = null;
          if (r.body != null) {
            let [Q, I] = RV(r.body, A.keepalive);
            h = Q, I && !y0(this.#r).contains("content-type", true) && this.#r.append("content-type", I, true);
          }
          let f = h ?? E;
          if (f != null && f.source == null) {
            if (h != null && r.duplex == null) throw new TypeError("RequestInit: duplex option is required when sending a body.");
            if (A.mode !== "same-origin" && A.mode !== "cors") throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
            A.useCORSPreflightFlag = true;
          }
          let p = f;
          if (h == null && E != null) {
            if (m0(e.#n)) throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
            let Q = new TransformStream();
            E.stream.pipeThrough(Q), p = { source: E.source, length: E.length, stream: Q.readable };
          }
          this.#n.body = p;
        }
        get method() {
          return F.brandCheck(this, t), this.#n.method;
        }
        get url() {
          return F.brandCheck(this, t), HV(this.#n.url);
        }
        get headers() {
          return F.brandCheck(this, t), this.#r;
        }
        get destination() {
          return F.brandCheck(this, t), this.#n.destination;
        }
        get referrer() {
          return F.brandCheck(this, t), this.#n.referrer === "no-referrer" ? "" : this.#n.referrer === "client" ? "about:client" : this.#n.referrer.toString();
        }
        get referrerPolicy() {
          return F.brandCheck(this, t), this.#n.referrerPolicy;
        }
        get mode() {
          return F.brandCheck(this, t), this.#n.mode;
        }
        get credentials() {
          return F.brandCheck(this, t), this.#n.credentials;
        }
        get cache() {
          return F.brandCheck(this, t), this.#n.cache;
        }
        get redirect() {
          return F.brandCheck(this, t), this.#n.redirect;
        }
        get integrity() {
          return F.brandCheck(this, t), this.#n.integrity;
        }
        get keepalive() {
          return F.brandCheck(this, t), this.#n.keepalive;
        }
        get isReloadNavigation() {
          return F.brandCheck(this, t), this.#n.reloadNavigation;
        }
        get isHistoryNavigation() {
          return F.brandCheck(this, t), this.#n.historyNavigation;
        }
        get signal() {
          return F.brandCheck(this, t), this.#e;
        }
        get body() {
          return F.brandCheck(this, t), this.#n.body ? this.#n.body.stream : null;
        }
        get bodyUsed() {
          return F.brandCheck(this, t), !!this.#n.body && qc.isDisturbed(this.#n.body.stream);
        }
        get duplex() {
          return F.brandCheck(this, t), "half";
        }
        clone() {
          if (F.brandCheck(this, t), m0(this.#n)) throw new TypeError("unusable");
          let e = U0(this.#n), r = new AbortController();
          if (this.signal.aborted) r.abort(this.signal.reason);
          else {
            let n = _c.get(this.signal);
            n === void 0 && (n = /* @__PURE__ */ new Set(), _c.set(this.signal, n));
            let A = new WeakRef(r);
            n.add(A), qc.addAbortListener(r.signal, R0(A));
          }
          return k0(e, this.#t, r.signal, FV(this.#r));
        }
        [w0.inspect.custom](e, r) {
          r.depth === null && (r.depth = 2), r.colors ??= true;
          let n = { method: this.method, url: this.url, headers: this.headers, destination: this.destination, referrer: this.referrer, referrerPolicy: this.referrerPolicy, mode: this.mode, credentials: this.credentials, cache: this.cache, redirect: this.redirect, integrity: this.integrity, keepalive: this.keepalive, isReloadNavigation: this.isReloadNavigation, isHistoryNavigation: this.isHistoryNavigation, signal: this.signal };
          return `Request ${w0.formatWithOptions(r, n)}`;
        }
        static setRequestSignal(e, r) {
          return e.#e = r, e;
        }
        static getRequestDispatcher(e) {
          return e.#t;
        }
        static setRequestDispatcher(e, r) {
          e.#t = r;
        }
        static setRequestHeaders(e, r) {
          e.#r = r;
        }
        static getRequestState(e) {
          return e.#n;
        }
        static setRequestState(e, r) {
          e.#n = r;
        }
      }, { setRequestSignal: jV, getRequestDispatcher: ZV, setRequestDispatcher: XV, setRequestHeaders: KV, getRequestState: x0, setRequestState: $V } = Xe;
      Reflect.deleteProperty(Xe, "setRequestSignal");
      Reflect.deleteProperty(Xe, "getRequestDispatcher");
      Reflect.deleteProperty(Xe, "setRequestDispatcher");
      Reflect.deleteProperty(Xe, "setRequestHeaders");
      Reflect.deleteProperty(Xe, "getRequestState");
      Reflect.deleteProperty(Xe, "setRequestState");
      SV(Xe, x0);
      function jc(t) {
        return { method: t.method ?? "GET", localURLsOnly: t.localURLsOnly ?? false, unsafeRequest: t.unsafeRequest ?? false, body: t.body ?? null, client: t.client ?? null, reservedClient: t.reservedClient ?? null, replacesClientId: t.replacesClientId ?? "", window: t.window ?? "client", keepalive: t.keepalive ?? false, serviceWorkers: t.serviceWorkers ?? "all", initiator: t.initiator ?? "", destination: t.destination ?? "", priority: t.priority ?? null, origin: t.origin ?? "client", policyContainer: t.policyContainer ?? "client", referrer: t.referrer ?? "client", referrerPolicy: t.referrerPolicy ?? "", mode: t.mode ?? "no-cors", useCORSPreflightFlag: t.useCORSPreflightFlag ?? false, credentials: t.credentials ?? "same-origin", useCredentials: t.useCredentials ?? false, cache: t.cache ?? "default", redirect: t.redirect ?? "follow", integrity: t.integrity ?? "", cryptoGraphicsNonceMetadata: t.cryptoGraphicsNonceMetadata ?? "", parserMetadata: t.parserMetadata ?? "", reloadNavigation: t.reloadNavigation ?? false, historyNavigation: t.historyNavigation ?? false, userActivation: t.userActivation ?? false, taintedOrigin: t.taintedOrigin ?? false, redirectCount: t.redirectCount ?? 0, responseTainting: t.responseTainting ?? "basic", preventNoCacheCacheControlHeaderModification: t.preventNoCacheCacheControlHeaderModification ?? false, done: t.done ?? false, timingAllowFailed: t.timingAllowFailed ?? false, urlList: t.urlList, url: t.urlList[0], headersList: t.headersList ? new Jc(t.headersList) : new Jc() };
      }
      function U0(t) {
        let e = jc({ ...t, body: null });
        return t.body != null && (e.body = bV(e, t.body)), e;
      }
      function k0(t, e, r, n) {
        let A = new Xe(Wc);
        $V(A, t), XV(A, e), jV(A, r);
        let i = new b0(Wc);
        return KV(A, i), N0(i, t.headersList), sh(i, n), A;
      }
      Object.defineProperties(Xe.prototype, { method: Ie, url: Ie, headers: Ie, redirect: Ie, clone: Ie, signal: Ie, duplex: Ie, destination: Ie, body: Ie, bodyUsed: Ie, isHistoryNavigation: Ie, isReloadNavigation: Ie, keepalive: Ie, integrity: Ie, cache: Ie, credentials: Ie, attribute: Ie, referrerPolicy: Ie, referrer: Ie, mode: Ie, [Symbol.toStringTag]: { value: "Request", configurable: true } });
      F.is.Request = F.util.MakeTypeAssertion(Xe);
      F.converters.RequestInfo = function(t, e, r) {
        return typeof t == "string" ? F.converters.USVString(t) : F.is.Request(t) ? t : F.converters.USVString(t);
      };
      F.converters.RequestInit = F.dictionaryConverter([{ key: "method", converter: F.converters.ByteString }, { key: "headers", converter: F.converters.HeadersInit }, { key: "body", converter: F.nullableConverter(F.converters.BodyInit) }, { key: "referrer", converter: F.converters.USVString }, { key: "referrerPolicy", converter: F.converters.DOMString, allowedValues: MV }, { key: "mode", converter: F.converters.DOMString, allowedValues: vV }, { key: "credentials", converter: F.converters.DOMString, allowedValues: PV }, { key: "cache", converter: F.converters.DOMString, allowedValues: YV }, { key: "redirect", converter: F.converters.DOMString, allowedValues: LV }, { key: "integrity", converter: F.converters.DOMString }, { key: "keepalive", converter: F.converters.boolean }, { key: "signal", converter: F.nullableConverter((t) => F.converters.AbortSignal(t, "RequestInit", "signal")) }, { key: "window", converter: F.converters.any }, { key: "duplex", converter: F.converters.DOMString, allowedValues: GV }, { key: "dispatcher", converter: F.converters.any }]);
      M0.exports = { Request: Xe, makeRequest: jc, fromInnerRequest: k0, cloneRequest: U0, getRequestDispatcher: ZV, getRequestState: x0 };
    });
    var Ms = C((_$, Z0) => {
      "use strict";
      var { makeNetworkError: $, makeAppropriateNetworkError: Zc, filterResponse: ah, makeResponse: Xc, fromInnerResponse: zV, getResponseState: eH } = Us(), { HeadersList: L0 } = Tn(), { Request: tH, cloneRequest: rH, getRequestDispatcher: nH, getRequestState: AH } = XA(), $r = require("node:zlib"), { bytesMatch: iH, makePolicyContainer: sH, clonePolicyContainer: oH, requestBadPort: aH, TAOCheck: cH, appendRequestOriginHeader: lH, responseLocationURL: uH, requestCurrentURL: $t, setRequestReferrerPolicyOnRedirect: gH, tryUpgradeRequestToAPotentiallyTrustworthyURL: EH, createOpaqueTimingInfo: Eh, appendFetchMetadata: dH, corsCheck: hH, crossOriginResourcePolicyCheck: fH, determineRequestsReferrer: QH, coarsenedSharedCurrentTime: ks, createDeferredPromise: CH, sameOrigin: gh, isCancelled: Un, isAborted: v0, isErrorLike: IH, fullyReadBody: pH, readableStreamClose: BH, isomorphicEncode: Kc, urlIsLocal: mH, urlIsHttpHttpsScheme: dh, urlHasHttpsScheme: yH, clampAndCoarsenConnectionTimingInfo: wH, simpleRangeHeaderValue: DH, buildContentRange: RH, createInflate: SH, extractMimeType: bH } = Ve(), kn = require("node:assert"), { safelyExtractBody: hh, extractBody: P0 } = FA(), { redirectStatusSet: O0, nullBodyStatus: V0, safeMethodsSet: NH, requestBodyHeader: FH, subresourceSet: TH } = ts(), xH = require("node:events"), { Readable: UH, pipeline: kH, finished: MH, isErrored: LH, isReadable: $c } = require("node:stream"), { addAbortListener: vH, bufferToLowerCasedHeaderName: Y0 } = Y(), { dataURLProcessor: PH, serializeAMimeType: YH, minimizeSupportedMimeType: GH } = tt(), { getGlobalDispatcher: OH } = kc(), { webidl: fh } = Te(), { STATUS_CODES: VH } = require("node:http"), HH = ["GET", "HEAD"], qH = typeof __UNDICI_IS_NODE__ < "u" || typeof esbuildDetection < "u" ? "node" : "undici", ch, zc = class extends xH {
        constructor(e) {
          super(), this.dispatcher = e, this.connection = null, this.dump = false, this.state = "ongoing";
        }
        terminate(e) {
          this.state === "ongoing" && (this.state = "terminated", this.connection?.destroy(e), this.emit("terminated", e));
        }
        abort(e) {
          this.state === "ongoing" && (this.state = "aborted", e || (e = new DOMException("The operation was aborted.", "AbortError")), this.serializedAbortReason = e, this.connection?.destroy(e), this.emit("terminated", e));
        }
      };
      function JH(t) {
        H0(t, "fetch");
      }
      function WH(t, e = void 0) {
        fh.argumentLengthCheck(arguments, 1, "globalThis.fetch");
        let r = CH(), n;
        try {
          n = new tH(t, e);
        } catch (l) {
          return r.reject(l), r.promise;
        }
        let A = AH(n);
        if (n.signal.aborted) return lh(r, A, null, n.signal.reason), r.promise;
        A.client.globalObject?.constructor?.name === "ServiceWorkerGlobalScope" && (A.serviceWorkers = "none");
        let s = null, o = false, a = null;
        return vH(n.signal, () => {
          o = true, kn(a != null), a.abort(n.signal.reason);
          let l = s?.deref();
          lh(r, A, l, n.signal.reason);
        }), a = J0({ request: A, processResponseEndOfBody: JH, processResponse: (l) => {
          if (!o) {
            if (l.aborted) {
              lh(r, A, s, a.serializedAbortReason);
              return;
            }
            if (l.type === "error") {
              r.reject(new TypeError("fetch failed", { cause: l.error }));
              return;
            }
            s = new WeakRef(zV(l, "immutable")), r.resolve(s.deref()), r = null;
          }
        }, dispatcher: nH(n) }), r.promise;
      }
      function H0(t, e = "other") {
        if (t.type === "error" && t.aborted || !t.urlList?.length) return;
        let r = t.urlList[0], n = t.timingInfo, A = t.cacheState;
        dh(r) && n !== null && (t.timingAllowPassed || (n = Eh({ startTime: n.startTime }), A = ""), n.endTime = ks(), t.timingInfo = n, q0(n, r.href, e, globalThis, A));
      }
      var q0 = performance.markResourceTiming;
      function lh(t, e, r, n) {
        if (t && t.reject(n), e.body?.stream != null && $c(e.body.stream) && e.body.stream.cancel(n).catch((i) => {
          if (i.code !== "ERR_INVALID_STATE") throw i;
        }), r == null) return;
        let A = eH(r);
        A.body?.stream != null && $c(A.body.stream) && A.body.stream.cancel(n).catch((i) => {
          if (i.code !== "ERR_INVALID_STATE") throw i;
        });
      }
      function J0({ request: t, processRequestBodyChunkLength: e, processRequestEndOfBody: r, processResponse: n, processResponseEndOfBody: A, processResponseConsumeBody: i, useParallelQueue: s = false, dispatcher: o = OH() }) {
        kn(o);
        let a = null, c = false;
        t.client != null && (a = t.client.globalObject, c = t.client.crossOriginIsolatedCapability);
        let l = ks(c), u = Eh({ startTime: l }), g = { controller: new zc(o), request: t, timingInfo: u, processRequestBodyChunkLength: e, processRequestEndOfBody: r, processResponse: n, processResponseConsumeBody: i, processResponseEndOfBody: A, taskDestination: a, crossOriginIsolatedCapability: c };
        return kn(!t.body || t.body.stream), t.window === "client" && (t.window = t.client?.globalObject?.constructor?.name === "Window" ? t.client : "no-window"), t.origin === "client" && (t.origin = t.client.origin), t.policyContainer === "client" && (t.client != null ? t.policyContainer = oH(t.client.policyContainer) : t.policyContainer = sH()), t.headersList.contains("accept", true) || t.headersList.append("accept", "*/*", true), t.headersList.contains("accept-language", true) || t.headersList.append("accept-language", "*", true), t.priority, TH.has(t.destination), W0(g).catch((E) => {
          g.controller.terminate(E);
        }), g.controller;
      }
      async function W0(t, e = false) {
        let r = t.request, n = null;
        if (r.localURLsOnly && !mH($t(r)) && (n = $("local URLs only")), EH(r), aH(r) === "blocked" && (n = $("bad port")), r.referrerPolicy === "" && (r.referrerPolicy = r.policyContainer.referrerPolicy), r.referrer !== "no-referrer" && (r.referrer = QH(r)), n === null) {
          let i = $t(r);
          gh(i, r.url) && r.responseTainting === "basic" || i.protocol === "data:" || r.mode === "navigate" || r.mode === "websocket" ? (r.responseTainting = "basic", n = await G0(t)) : r.mode === "same-origin" ? n = $('request mode cannot be "same-origin"') : r.mode === "no-cors" ? r.redirect !== "follow" ? n = $('redirect mode cannot be "follow" for "no-cors" request') : (r.responseTainting = "opaque", n = await G0(t)) : dh($t(r)) ? (r.responseTainting = "cors", n = await _0(t)) : n = $("URL scheme must be a HTTP(S) scheme");
        }
        if (e) return n;
        n.status !== 0 && !n.internalResponse && (r.responseTainting, r.responseTainting === "basic" ? n = ah(n, "basic") : r.responseTainting === "cors" ? n = ah(n, "cors") : r.responseTainting === "opaque" ? n = ah(n, "opaque") : kn(false));
        let A = n.status === 0 ? n : n.internalResponse;
        if (A.urlList.length === 0 && A.urlList.push(...r.urlList), r.timingAllowFailed || (n.timingAllowPassed = true), n.type === "opaque" && A.status === 206 && A.rangeRequested && !r.headers.contains("range", true) && (n = A = $()), n.status !== 0 && (r.method === "HEAD" || r.method === "CONNECT" || V0.includes(A.status)) && (A.body = null, t.controller.dump = true), r.integrity) {
          let i = (o) => uh(t, $(o));
          if (r.responseTainting === "opaque" || n.body == null) {
            i(n.error);
            return;
          }
          let s = (o) => {
            if (!iH(o, r.integrity)) {
              i("integrity mismatch");
              return;
            }
            n.body = hh(o)[0], uh(t, n);
          };
          await pH(n.body, s, i);
        } else uh(t, n);
      }
      function G0(t) {
        if (Un(t) && t.request.redirectCount === 0) return Promise.resolve(Zc(t));
        let { request: e } = t, { protocol: r } = $t(e);
        switch (r) {
          case "about:":
            return Promise.resolve($("about scheme is not supported"));
          case "blob:": {
            ch || (ch = require("node:buffer").resolveObjectURL);
            let n = $t(e);
            if (n.search.length !== 0) return Promise.resolve($("NetworkError when attempting to fetch resource."));
            let A = ch(n.toString());
            if (e.method !== "GET" || !fh.is.Blob(A)) return Promise.resolve($("invalid method"));
            let i = Xc(), s = A.size, o = Kc(`${s}`), a = A.type;
            if (e.headersList.contains("range", true)) {
              i.rangeRequested = true;
              let c = e.headersList.get("range", true), l = DH(c, true);
              if (l === "failure") return Promise.resolve($("failed to fetch the data URL"));
              let { rangeStartValue: u, rangeEndValue: g } = l;
              if (u === null) u = s - g, g = u + g - 1;
              else {
                if (u >= s) return Promise.resolve($("Range start is greater than the blob's size."));
                (g === null || g >= s) && (g = s - 1);
              }
              let E = A.slice(u, g, a), h = P0(E);
              i.body = h[0];
              let f = Kc(`${E.size}`), p = RH(u, g, s);
              i.status = 206, i.statusText = "Partial Content", i.headersList.set("content-length", f, true), i.headersList.set("content-type", a, true), i.headersList.set("content-range", p, true);
            } else {
              let c = P0(A);
              i.statusText = "OK", i.body = c[0], i.headersList.set("content-length", o, true), i.headersList.set("content-type", a, true);
            }
            return Promise.resolve(i);
          }
          case "data:": {
            let n = $t(e), A = PH(n);
            if (A === "failure") return Promise.resolve($("failed to fetch the data URL"));
            let i = YH(A.mimeType);
            return Promise.resolve(Xc({ statusText: "OK", headersList: [["content-type", { name: "Content-Type", value: i }]], body: hh(A.body)[0] }));
          }
          case "file:":
            return Promise.resolve($("not implemented... yet..."));
          case "http:":
          case "https:":
            return _0(t).catch((n) => $(n));
          default:
            return Promise.resolve($("unknown scheme"));
        }
      }
      function _H(t, e) {
        t.request.done = true, t.processResponseDone != null && queueMicrotask(() => t.processResponseDone(e));
      }
      function uh(t, e) {
        let r = t.timingInfo, n = () => {
          let i = Date.now();
          t.request.destination === "document" && (t.controller.fullTimingInfo = r), t.controller.reportTimingSteps = () => {
            if (t.request.url.protocol !== "https:") return;
            r.endTime = i;
            let o = e.cacheState, a = e.bodyInfo;
            e.timingAllowPassed || (r = Eh(r), o = "");
            let c = 0;
            if (t.request.mode !== "navigator" || !e.hasCrossOriginRedirects) {
              c = e.status;
              let l = bH(e.headersList);
              l !== "failure" && (a.contentType = GH(l));
            }
            t.request.initiatorType != null && q0(r, t.request.url.href, t.request.initiatorType, globalThis, o, a, c);
          };
          let s = () => {
            t.request.done = true, t.processResponseEndOfBody != null && queueMicrotask(() => t.processResponseEndOfBody(e)), t.request.initiatorType != null && t.controller.reportTimingSteps();
          };
          queueMicrotask(() => s());
        };
        t.processResponse != null && queueMicrotask(() => {
          t.processResponse(e), t.processResponse = null;
        });
        let A = e.type === "error" ? e : e.internalResponse ?? e;
        A.body == null ? n() : MH(A.body.stream, () => {
          n();
        });
      }
      async function _0(t) {
        let e = t.request, r = null, n = null, A = t.timingInfo;
        if (e.serviceWorkers, r === null) {
          if (e.redirect === "follow" && (e.serviceWorkers = "none"), n = r = await j0(t), e.responseTainting === "cors" && hH(e, r) === "failure") return $("cors failure");
          cH(e, r) === "failure" && (e.timingAllowFailed = true);
        }
        return (e.responseTainting === "opaque" || r.type === "opaque") && fH(e.origin, e.client, e.destination, n) === "blocked" ? $("blocked") : (O0.has(n.status) && (e.redirect !== "manual" && t.controller.connection.destroy(void 0, false), e.redirect === "error" ? r = $("unexpected redirect") : e.redirect === "manual" ? r = n : e.redirect === "follow" ? r = await jH(t, r) : kn(false)), r.timingInfo = A, r);
      }
      function jH(t, e) {
        let r = t.request, n = e.internalResponse ? e.internalResponse : e, A;
        try {
          if (A = uH(n, $t(r).hash), A == null) return e;
        } catch (s) {
          return Promise.resolve($(s));
        }
        if (!dh(A)) return Promise.resolve($("URL scheme must be a HTTP(S) scheme"));
        if (r.redirectCount === 20) return Promise.resolve($("redirect count exceeded"));
        if (r.redirectCount += 1, r.mode === "cors" && (A.username || A.password) && !gh(r, A)) return Promise.resolve($('cross origin not allowed for request mode "cors"'));
        if (r.responseTainting === "cors" && (A.username || A.password)) return Promise.resolve($('URL cannot contain credentials for request mode "cors"'));
        if (n.status !== 303 && r.body != null && r.body.source == null) return Promise.resolve($());
        if ([301, 302].includes(n.status) && r.method === "POST" || n.status === 303 && !HH.includes(r.method)) {
          r.method = "GET", r.body = null;
          for (let s of FH) r.headersList.delete(s);
        }
        gh($t(r), A) || (r.headersList.delete("authorization", true), r.headersList.delete("proxy-authorization", true), r.headersList.delete("cookie", true), r.headersList.delete("host", true)), r.body != null && (kn(r.body.source != null), r.body = hh(r.body.source)[0]);
        let i = t.timingInfo;
        return i.redirectEndTime = i.postRedirectStartTime = ks(t.crossOriginIsolatedCapability), i.redirectStartTime === 0 && (i.redirectStartTime = i.startTime), r.urlList.push(A), gH(r, n), W0(t, true);
      }
      async function j0(t, e = false, r = false) {
        let n = t.request, A = null, i = null, s = null, o = null, a = false;
        n.window === "no-window" && n.redirect === "error" ? (A = t, i = n) : (i = rH(n), A = { ...t }, A.request = i);
        let c = n.credentials === "include" || n.credentials === "same-origin" && n.responseTainting === "basic", l = i.body ? i.body.length : null, u = null;
        if (i.body == null && ["POST", "PUT"].includes(i.method) && (u = "0"), l != null && (u = Kc(`${l}`)), u != null && i.headersList.append("content-length", u, true), l != null && i.keepalive, fh.is.URL(i.referrer) && i.headersList.append("referer", Kc(i.referrer.href), true), lH(i), dH(i), i.headersList.contains("user-agent", true) || i.headersList.append("user-agent", qH, true), i.cache === "default" && (i.headersList.contains("if-modified-since", true) || i.headersList.contains("if-none-match", true) || i.headersList.contains("if-unmodified-since", true) || i.headersList.contains("if-match", true) || i.headersList.contains("if-range", true)) && (i.cache = "no-store"), i.cache === "no-cache" && !i.preventNoCacheCacheControlHeaderModification && !i.headersList.contains("cache-control", true) && i.headersList.append("cache-control", "max-age=0", true), (i.cache === "no-store" || i.cache === "reload") && (i.headersList.contains("pragma", true) || i.headersList.append("pragma", "no-cache", true), i.headersList.contains("cache-control", true) || i.headersList.append("cache-control", "no-cache", true)), i.headersList.contains("range", true) && i.headersList.append("accept-encoding", "identity", true), i.headersList.contains("accept-encoding", true) || (yH($t(i)) ? i.headersList.append("accept-encoding", "br, gzip, deflate", true) : i.headersList.append("accept-encoding", "gzip, deflate", true)), i.headersList.delete("host", true), o == null && (i.cache = "no-store"), i.cache !== "no-store" && i.cache, s == null) {
          if (i.cache === "only-if-cached") return $("only if cached");
          let g = await ZH(A, c, r);
          !NH.has(i.method) && g.status >= 200 && g.status <= 399, a && g.status, s == null && (s = g);
        }
        if (s.urlList = [...i.urlList], i.headersList.contains("range", true) && (s.rangeRequested = true), s.requestIncludesCredentials = c, s.status === 407) return n.window === "no-window" ? $() : Un(t) ? Zc(t) : $("proxy authentication required");
        if (s.status === 421 && !r && (n.body == null || n.body.source != null)) {
          if (Un(t)) return Zc(t);
          t.controller.connection.destroy(), s = await j0(t, e, true);
        }
        return s;
      }
      async function ZH(t, e = false, r = false) {
        kn(!t.controller.connection || t.controller.connection.destroyed), t.controller.connection = { abort: null, destroyed: false, destroy(h, f = true) {
          this.destroyed || (this.destroyed = true, f && this.abort?.(h ?? new DOMException("The operation was aborted.", "AbortError")));
        } };
        let n = t.request, A = null, i = t.timingInfo;
        n.cache = "no-store";
        let o = r ? "yes" : "no";
        n.mode;
        let a = null;
        if (n.body == null && t.processRequestEndOfBody) queueMicrotask(() => t.processRequestEndOfBody());
        else if (n.body != null) {
          let h = async function* (Q) {
            Un(t) || (yield Q, t.processRequestBodyChunkLength?.(Q.byteLength));
          }, f = () => {
            Un(t) || t.processRequestEndOfBody && t.processRequestEndOfBody();
          }, p = (Q) => {
            Un(t) || (Q.name === "AbortError" ? t.controller.abort() : t.controller.terminate(Q));
          };
          a = (async function* () {
            try {
              for await (let Q of n.body.stream) yield* h(Q);
              f();
            } catch (Q) {
              p(Q);
            }
          })();
        }
        try {
          let { body: h, status: f, statusText: p, headersList: Q, socket: I } = await E({ body: a });
          if (I) A = Xc({ status: f, statusText: p, headersList: Q, socket: I });
          else {
            let B = h[Symbol.asyncIterator]();
            t.controller.next = () => B.next(), A = Xc({ status: f, statusText: p, headersList: Q });
          }
        } catch (h) {
          return h.name === "AbortError" ? (t.controller.connection.destroy(), Zc(t, h)) : $(h);
        }
        let c = () => t.controller.resume(), l = (h) => {
          Un(t) || t.controller.abort(h);
        }, u = new ReadableStream({ async start(h) {
          t.controller.controller = h;
        }, async pull(h) {
          await c(h);
        }, async cancel(h) {
          await l(h);
        }, type: "bytes" });
        A.body = { stream: u, source: null, length: null }, t.controller.resume || t.controller.on("terminated", g), t.controller.resume = async () => {
          for (; ; ) {
            let h, f;
            try {
              let { done: Q, value: I } = await t.controller.next();
              if (v0(t)) break;
              h = Q ? void 0 : I;
            } catch (Q) {
              t.controller.ended && !i.encodedBodySize ? h = void 0 : (h = Q, f = true);
            }
            if (h === void 0) {
              BH(t.controller.controller), _H(t, A);
              return;
            }
            if (i.decodedBodySize += h?.byteLength ?? 0, f) {
              t.controller.terminate(h);
              return;
            }
            let p = new Uint8Array(h);
            if (p.byteLength && t.controller.controller.enqueue(p), LH(u)) {
              t.controller.terminate();
              return;
            }
            if (t.controller.controller.desiredSize <= 0) return;
          }
        };
        function g(h) {
          v0(t) ? (A.aborted = true, $c(u) && t.controller.controller.error(t.controller.serializedAbortReason)) : $c(u) && t.controller.controller.error(new TypeError("terminated", { cause: IH(h) ? h : void 0 })), t.controller.connection.destroy();
        }
        return A;
        function E({ body: h }) {
          let f = $t(n), p = t.controller.dispatcher;
          return new Promise((Q, I) => p.dispatch({ path: f.pathname + f.search, origin: f.origin, method: n.method, body: p.isMockActive ? n.body && (n.body.source || n.body.stream) : h, headers: n.headersList.entries, maxRedirections: 0, upgrade: n.mode === "websocket" ? "websocket" : void 0 }, { body: null, abort: null, onConnect(B) {
            let { connection: w } = t.controller;
            i.finalConnectionTimingInfo = wH(void 0, i.postRedirectStartTime, t.crossOriginIsolatedCapability), w.destroyed ? B(new DOMException("The operation was aborted.", "AbortError")) : (t.controller.on("terminated", B), this.abort = w.abort = B), i.finalNetworkRequestStartTime = ks(t.crossOriginIsolatedCapability);
          }, onResponseStarted() {
            i.finalNetworkResponseStartTime = ks(t.crossOriginIsolatedCapability);
          }, onHeaders(B, w, D, v) {
            if (B < 200) return;
            let K = [], W = "", ae = new L0();
            for (let Se = 0; Se < w.length; Se += 2) ae.append(Y0(w[Se]), w[Se + 1].toString("latin1"), true);
            let xe = ae.get("content-encoding", true);
            xe && (K = xe.toLowerCase().split(",").map((Se) => Se.trim())), W = ae.get("location", true), this.body = new UH({ read: D });
            let te = [], Rr = W && n.redirect === "follow" && O0.has(B);
            if (K.length !== 0 && n.method !== "HEAD" && n.method !== "CONNECT" && !V0.includes(B) && !Rr) for (let Se = K.length - 1; Se >= 0; --Se) {
              let he = K[Se];
              if (he === "x-gzip" || he === "gzip") te.push($r.createGunzip({ flush: $r.constants.Z_SYNC_FLUSH, finishFlush: $r.constants.Z_SYNC_FLUSH }));
              else if (he === "deflate") te.push(SH({ flush: $r.constants.Z_SYNC_FLUSH, finishFlush: $r.constants.Z_SYNC_FLUSH }));
              else if (he === "br") te.push($r.createBrotliDecompress({ flush: $r.constants.BROTLI_OPERATION_FLUSH, finishFlush: $r.constants.BROTLI_OPERATION_FLUSH }));
              else {
                te.length = 0;
                break;
              }
            }
            let rn = this.onError.bind(this);
            return Q({ status: B, statusText: v, headersList: ae, body: te.length ? kH(this.body, ...te, (Se) => {
              Se && this.onError(Se);
            }).on("error", rn) : this.body.on("error", rn) }), true;
          }, onData(B) {
            if (t.controller.dump) return;
            let w = B;
            return i.encodedBodySize += w.byteLength, this.body.push(w);
          }, onComplete() {
            this.abort && t.controller.off("terminated", this.abort), t.controller.ended = true, this.body.push(null);
          }, onError(B) {
            this.abort && t.controller.off("terminated", this.abort), this.body?.destroy(B), t.controller.terminate(B), I(B);
          }, onUpgrade(B, w, D) {
            if (B !== 101) return;
            let v = new L0();
            for (let K = 0; K < w.length; K += 2) v.append(Y0(w[K]), w[K + 1].toString("latin1"), true);
            return Q({ status: B, statusText: VH[B], headersList: v, socket: D }), true;
          } }));
        }
      }
      Z0.exports = { fetch: WH, Fetch: zc, fetching: J0, finalizeAndReportTiming: H0 };
    });
    var $0 = C((j$, K0) => {
      "use strict";
      var XH = require("node:assert"), { URLSerializer: X0 } = tt(), { isValidHeaderName: KH } = Ve();
      function $H(t, e, r = false) {
        let n = X0(t, r), A = X0(e, r);
        return n === A;
      }
      function zH(t) {
        XH(t !== null);
        let e = [];
        for (let r of t.split(",")) r = r.trim(), KH(r) && e.push(r);
        return e;
      }
      K0.exports = { urlEquals: $H, getFieldValues: zH };
    });
    var tR = C((Z$, eR) => {
      "use strict";
      var { kConstruct: eq } = ne(), { urlEquals: tq, getFieldValues: Qh } = $0(), { kEnumerableProperty: Mn, isDisturbed: rq } = Y(), { webidl: R } = Te(), { cloneResponse: nq, fromInnerResponse: Aq, getResponseState: iq } = Us(), { Request: Ls, fromInnerRequest: sq, getRequestState: zt } = XA(), { fetching: oq } = Ms(), { urlIsHttpHttpsScheme: el, createDeferredPromise: KA, readAllBytes: aq } = Ve(), Ch = require("node:assert"), tl = class t {
        #e;
        constructor() {
          arguments[0] !== eq && R.illegalConstructor(), R.util.markAsUncloneable(this), this.#e = arguments[1];
        }
        async match(e, r = {}) {
          R.brandCheck(this, t);
          let n = "Cache.match";
          R.argumentLengthCheck(arguments, 1, n), e = R.converters.RequestInfo(e, n, "request"), r = R.converters.CacheQueryOptions(r, n, "options");
          let A = this.#i(e, r, 1);
          if (A.length !== 0) return A[0];
        }
        async matchAll(e = void 0, r = {}) {
          R.brandCheck(this, t);
          let n = "Cache.matchAll";
          return e !== void 0 && (e = R.converters.RequestInfo(e, n, "request")), r = R.converters.CacheQueryOptions(r, n, "options"), this.#i(e, r);
        }
        async add(e) {
          R.brandCheck(this, t);
          let r = "Cache.add";
          R.argumentLengthCheck(arguments, 1, r), e = R.converters.RequestInfo(e, r, "request");
          let n = [e];
          return await this.addAll(n);
        }
        async addAll(e) {
          R.brandCheck(this, t);
          let r = "Cache.addAll";
          R.argumentLengthCheck(arguments, 1, r);
          let n = [], A = [];
          for (let g of e) {
            if (g === void 0) throw R.errors.conversionFailed({ prefix: r, argument: "Argument 1", types: ["undefined is not allowed"] });
            if (g = R.converters.RequestInfo(g), typeof g == "string") continue;
            let E = zt(g);
            if (!el(E.url) || E.method !== "GET") throw R.errors.exception({ header: r, message: "Expected http/s scheme when method is not GET." });
          }
          let i = [];
          for (let g of e) {
            let E = zt(new Ls(g));
            if (!el(E.url)) throw R.errors.exception({ header: r, message: "Expected http/s scheme." });
            E.initiator = "fetch", E.destination = "subresource", A.push(E);
            let h = KA();
            i.push(oq({ request: E, processResponse(f) {
              if (f.type === "error" || f.status === 206 || f.status < 200 || f.status > 299) h.reject(R.errors.exception({ header: "Cache.addAll", message: "Received an invalid status code or the request failed." }));
              else if (f.headersList.contains("vary")) {
                let p = Qh(f.headersList.get("vary"));
                for (let Q of p) if (Q === "*") {
                  h.reject(R.errors.exception({ header: "Cache.addAll", message: "invalid vary field value" }));
                  for (let I of i) I.abort();
                  return;
                }
              }
            }, processResponseEndOfBody(f) {
              if (f.aborted) {
                h.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              h.resolve(f);
            } })), n.push(h.promise);
          }
          let o = await Promise.all(n), a = [], c = 0;
          for (let g of o) {
            let E = { type: "put", request: A[c], response: g };
            a.push(E), c++;
          }
          let l = KA(), u = null;
          try {
            this.#t(a);
          } catch (g) {
            u = g;
          }
          return queueMicrotask(() => {
            u === null ? l.resolve(void 0) : l.reject(u);
          }), l.promise;
        }
        async put(e, r) {
          R.brandCheck(this, t);
          let n = "Cache.put";
          R.argumentLengthCheck(arguments, 2, n), e = R.converters.RequestInfo(e, n, "request"), r = R.converters.Response(r, n, "response");
          let A = null;
          if (R.is.Request(e) ? A = zt(e) : A = zt(new Ls(e)), !el(A.url) || A.method !== "GET") throw R.errors.exception({ header: n, message: "Expected an http/s scheme when method is not GET" });
          let i = iq(r);
          if (i.status === 206) throw R.errors.exception({ header: n, message: "Got 206 status" });
          if (i.headersList.contains("vary")) {
            let E = Qh(i.headersList.get("vary"));
            for (let h of E) if (h === "*") throw R.errors.exception({ header: n, message: "Got * vary field value" });
          }
          if (i.body && (rq(i.body.stream) || i.body.stream.locked)) throw R.errors.exception({ header: n, message: "Response body is locked or disturbed" });
          let s = nq(i), o = KA();
          if (i.body != null) {
            let h = i.body.stream.getReader();
            aq(h, o.resolve, o.reject);
          } else o.resolve(void 0);
          let a = [], c = { type: "put", request: A, response: s };
          a.push(c);
          let l = await o.promise;
          s.body != null && (s.body.source = l);
          let u = KA(), g = null;
          try {
            this.#t(a);
          } catch (E) {
            g = E;
          }
          return queueMicrotask(() => {
            g === null ? u.resolve() : u.reject(g);
          }), u.promise;
        }
        async delete(e, r = {}) {
          R.brandCheck(this, t);
          let n = "Cache.delete";
          R.argumentLengthCheck(arguments, 1, n), e = R.converters.RequestInfo(e, n, "request"), r = R.converters.CacheQueryOptions(r, n, "options");
          let A = null;
          if (R.is.Request(e)) {
            if (A = zt(e), A.method !== "GET" && !r.ignoreMethod) return false;
          } else Ch(typeof e == "string"), A = zt(new Ls(e));
          let i = [], s = { type: "delete", request: A, options: r };
          i.push(s);
          let o = KA(), a = null, c;
          try {
            c = this.#t(i);
          } catch (l) {
            a = l;
          }
          return queueMicrotask(() => {
            a === null ? o.resolve(!!c?.length) : o.reject(a);
          }), o.promise;
        }
        async keys(e = void 0, r = {}) {
          R.brandCheck(this, t);
          let n = "Cache.keys";
          e !== void 0 && (e = R.converters.RequestInfo(e, n, "request")), r = R.converters.CacheQueryOptions(r, n, "options");
          let A = null;
          if (e !== void 0) if (R.is.Request(e)) {
            if (A = zt(e), A.method !== "GET" && !r.ignoreMethod) return [];
          } else typeof e == "string" && (A = zt(new Ls(e)));
          let i = KA(), s = [];
          if (e === void 0) for (let o of this.#e) s.push(o[0]);
          else {
            let o = this.#r(A, r);
            for (let a of o) s.push(a[0]);
          }
          return queueMicrotask(() => {
            let o = [];
            for (let a of s) {
              let c = sq(a, void 0, new AbortController().signal, "immutable");
              o.push(c);
            }
            i.resolve(Object.freeze(o));
          }), i.promise;
        }
        #t(e) {
          let r = this.#e, n = [...r], A = [], i = [];
          try {
            for (let s of e) {
              if (s.type !== "delete" && s.type !== "put") throw R.errors.exception({ header: "Cache.#batchCacheOperations", message: 'operation type does not match "delete" or "put"' });
              if (s.type === "delete" && s.response != null) throw R.errors.exception({ header: "Cache.#batchCacheOperations", message: "delete operation should not have an associated response" });
              if (this.#r(s.request, s.options, A).length) throw new DOMException("???", "InvalidStateError");
              let o;
              if (s.type === "delete") {
                if (o = this.#r(s.request, s.options), o.length === 0) return [];
                for (let a of o) {
                  let c = r.indexOf(a);
                  Ch(c !== -1), r.splice(c, 1);
                }
              } else if (s.type === "put") {
                if (s.response == null) throw R.errors.exception({ header: "Cache.#batchCacheOperations", message: "put operation should have an associated response" });
                let a = s.request;
                if (!el(a.url)) throw R.errors.exception({ header: "Cache.#batchCacheOperations", message: "expected http or https scheme" });
                if (a.method !== "GET") throw R.errors.exception({ header: "Cache.#batchCacheOperations", message: "not get method" });
                if (s.options != null) throw R.errors.exception({ header: "Cache.#batchCacheOperations", message: "options must not be defined" });
                o = this.#r(s.request);
                for (let c of o) {
                  let l = r.indexOf(c);
                  Ch(l !== -1), r.splice(l, 1);
                }
                r.push([s.request, s.response]), A.push([s.request, s.response]);
              }
              i.push([s.request, s.response]);
            }
            return i;
          } catch (s) {
            throw this.#e.length = 0, this.#e = n, s;
          }
        }
        #r(e, r, n) {
          let A = [], i = n ?? this.#e;
          for (let s of i) {
            let [o, a] = s;
            this.#n(e, o, a, r) && A.push(s);
          }
          return A;
        }
        #n(e, r, n = null, A) {
          let i = new URL(e.url), s = new URL(r.url);
          if (A?.ignoreSearch && (s.search = "", i.search = ""), !tq(i, s, true)) return false;
          if (n == null || A?.ignoreVary || !n.headersList.contains("vary")) return true;
          let o = Qh(n.headersList.get("vary"));
          for (let a of o) {
            if (a === "*") return false;
            let c = r.headersList.get(a), l = e.headersList.get(a);
            if (c !== l) return false;
          }
          return true;
        }
        #i(e, r, n = 1 / 0) {
          let A = null;
          if (e !== void 0) if (R.is.Request(e)) {
            if (A = zt(e), A.method !== "GET" && !r.ignoreMethod) return [];
          } else typeof e == "string" && (A = zt(new Ls(e)));
          let i = [];
          if (e === void 0) for (let o of this.#e) i.push(o[1]);
          else {
            let o = this.#r(A, r);
            for (let a of o) i.push(a[1]);
          }
          let s = [];
          for (let o of i) {
            let a = Aq(o, "immutable");
            if (s.push(a.clone()), s.length >= n) break;
          }
          return Object.freeze(s);
        }
      };
      Object.defineProperties(tl.prototype, { [Symbol.toStringTag]: { value: "Cache", configurable: true }, match: Mn, matchAll: Mn, add: Mn, addAll: Mn, put: Mn, delete: Mn, keys: Mn });
      var z0 = [{ key: "ignoreSearch", converter: R.converters.boolean, defaultValue: () => false }, { key: "ignoreMethod", converter: R.converters.boolean, defaultValue: () => false }, { key: "ignoreVary", converter: R.converters.boolean, defaultValue: () => false }];
      R.converters.CacheQueryOptions = R.dictionaryConverter(z0);
      R.converters.MultiCacheQueryOptions = R.dictionaryConverter([...z0, { key: "cacheName", converter: R.converters.DOMString }]);
      R.converters.Response = R.interfaceConverter(R.is.Response, "Response");
      R.converters["sequence<RequestInfo>"] = R.sequenceConverter(R.converters.RequestInfo);
      eR.exports = { Cache: tl };
    });
    var nR = C((X$, rR) => {
      "use strict";
      var { Cache: rl } = tR(), { webidl: ve } = Te(), { kEnumerableProperty: vs } = Y(), { kConstruct: Ps } = ne(), nl = class t {
        #e = /* @__PURE__ */ new Map();
        constructor() {
          arguments[0] !== Ps && ve.illegalConstructor(), ve.util.markAsUncloneable(this);
        }
        async match(e, r = {}) {
          if (ve.brandCheck(this, t), ve.argumentLengthCheck(arguments, 1, "CacheStorage.match"), e = ve.converters.RequestInfo(e), r = ve.converters.MultiCacheQueryOptions(r), r.cacheName != null) {
            if (this.#e.has(r.cacheName)) {
              let n = this.#e.get(r.cacheName);
              return await new rl(Ps, n).match(e, r);
            }
          } else for (let n of this.#e.values()) {
            let i = await new rl(Ps, n).match(e, r);
            if (i !== void 0) return i;
          }
        }
        async has(e) {
          ve.brandCheck(this, t);
          let r = "CacheStorage.has";
          return ve.argumentLengthCheck(arguments, 1, r), e = ve.converters.DOMString(e, r, "cacheName"), this.#e.has(e);
        }
        async open(e) {
          ve.brandCheck(this, t);
          let r = "CacheStorage.open";
          if (ve.argumentLengthCheck(arguments, 1, r), e = ve.converters.DOMString(e, r, "cacheName"), this.#e.has(e)) {
            let A = this.#e.get(e);
            return new rl(Ps, A);
          }
          let n = [];
          return this.#e.set(e, n), new rl(Ps, n);
        }
        async delete(e) {
          ve.brandCheck(this, t);
          let r = "CacheStorage.delete";
          return ve.argumentLengthCheck(arguments, 1, r), e = ve.converters.DOMString(e, r, "cacheName"), this.#e.delete(e);
        }
        async keys() {
          return ve.brandCheck(this, t), [...this.#e.keys()];
        }
      };
      Object.defineProperties(nl.prototype, { [Symbol.toStringTag]: { value: "CacheStorage", configurable: true }, match: vs, has: vs, open: vs, delete: vs, keys: vs });
      rR.exports = { CacheStorage: nl };
    });
    var iR = C((K$, AR) => {
      "use strict";
      AR.exports = { maxAttributeValueSize: 1024, maxNameValuePairSize: 4096 };
    });
    var Ih = C(($$, lR) => {
      "use strict";
      function cq(t) {
        for (let e = 0; e < t.length; ++e) {
          let r = t.charCodeAt(e);
          if (r >= 0 && r <= 8 || r >= 10 && r <= 31 || r === 127) return true;
        }
        return false;
      }
      function sR(t) {
        for (let e = 0; e < t.length; ++e) {
          let r = t.charCodeAt(e);
          if (r < 33 || r > 126 || r === 34 || r === 40 || r === 41 || r === 60 || r === 62 || r === 64 || r === 44 || r === 59 || r === 58 || r === 92 || r === 47 || r === 91 || r === 93 || r === 63 || r === 61 || r === 123 || r === 125) throw new Error("Invalid cookie name");
        }
      }
      function oR(t) {
        let e = t.length, r = 0;
        if (t[0] === '"') {
          if (e === 1 || t[e - 1] !== '"') throw new Error("Invalid cookie value");
          --e, ++r;
        }
        for (; r < e; ) {
          let n = t.charCodeAt(r++);
          if (n < 33 || n > 126 || n === 34 || n === 44 || n === 59 || n === 92) throw new Error("Invalid cookie value");
        }
      }
      function aR(t) {
        for (let e = 0; e < t.length; ++e) {
          let r = t.charCodeAt(e);
          if (r < 32 || r === 127 || r === 59) throw new Error("Invalid cookie path");
        }
      }
      function lq(t) {
        if (t.startsWith("-") || t.endsWith(".") || t.endsWith("-")) throw new Error("Invalid cookie domain");
      }
      var uq = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], gq = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], Al = Array(61).fill(0).map((t, e) => e.toString().padStart(2, "0"));
      function cR(t) {
        return typeof t == "number" && (t = new Date(t)), `${uq[t.getUTCDay()]}, ${Al[t.getUTCDate()]} ${gq[t.getUTCMonth()]} ${t.getUTCFullYear()} ${Al[t.getUTCHours()]}:${Al[t.getUTCMinutes()]}:${Al[t.getUTCSeconds()]} GMT`;
      }
      function Eq(t) {
        if (t < 0) throw new Error("Invalid cookie max-age");
      }
      function dq(t) {
        if (t.name.length === 0) return null;
        sR(t.name), oR(t.value);
        let e = [`${t.name}=${t.value}`];
        t.name.startsWith("__Secure-") && (t.secure = true), t.name.startsWith("__Host-") && (t.secure = true, t.domain = null, t.path = "/"), t.secure && e.push("Secure"), t.httpOnly && e.push("HttpOnly"), typeof t.maxAge == "number" && (Eq(t.maxAge), e.push(`Max-Age=${t.maxAge}`)), t.domain && (lq(t.domain), e.push(`Domain=${t.domain}`)), t.path && (aR(t.path), e.push(`Path=${t.path}`)), t.expires && t.expires.toString() !== "Invalid Date" && e.push(`Expires=${cR(t.expires)}`), t.sameSite && e.push(`SameSite=${t.sameSite}`);
        for (let r of t.unparsed) {
          if (!r.includes("=")) throw new Error("Invalid unparsed");
          let [n, ...A] = r.split("=");
          e.push(`${n.trim()}=${A.join("=")}`);
        }
        return e.join("; ");
      }
      lR.exports = { isCTLExcludingHtab: cq, validateCookieName: sR, validateCookiePath: aR, validateCookieValue: oR, toIMFDate: cR, stringify: dq };
    });
    var gR = C((z$, uR) => {
      "use strict";
      var { maxNameValuePairSize: hq, maxAttributeValueSize: fq } = iR(), { isCTLExcludingHtab: Qq } = Ih(), { collectASequenceOfCodePointsFast: il } = tt(), Cq = require("node:assert"), { unescape: Iq } = require("node:querystring");
      function pq(t) {
        if (Qq(t)) return null;
        let e = "", r = "", n = "", A = "";
        if (t.includes(";")) {
          let i = { position: 0 };
          e = il(";", t, i), r = t.slice(i.position);
        } else e = t;
        if (!e.includes("=")) A = e;
        else {
          let i = { position: 0 };
          n = il("=", e, i), A = e.slice(i.position + 1);
        }
        return n = n.trim(), A = A.trim(), n.length + A.length > hq ? null : { name: n, value: Iq(A), ...$A(r) };
      }
      function $A(t, e = {}) {
        if (t.length === 0) return e;
        Cq(t[0] === ";"), t = t.slice(1);
        let r = "";
        t.includes(";") ? (r = il(";", t, { position: 0 }), t = t.slice(r.length)) : (r = t, t = "");
        let n = "", A = "";
        if (r.includes("=")) {
          let s = { position: 0 };
          n = il("=", r, s), A = r.slice(s.position + 1);
        } else n = r;
        if (n = n.trim(), A = A.trim(), A.length > fq) return $A(t, e);
        let i = n.toLowerCase();
        if (i === "expires") {
          let s = new Date(A);
          e.expires = s;
        } else if (i === "max-age") {
          let s = A.charCodeAt(0);
          if ((s < 48 || s > 57) && A[0] !== "-" || !/^\d+$/.test(A)) return $A(t, e);
          let o = Number(A);
          e.maxAge = o;
        } else if (i === "domain") {
          let s = A;
          s[0] === "." && (s = s.slice(1)), s = s.toLowerCase(), e.domain = s;
        } else if (i === "path") {
          let s = "";
          A.length === 0 || A[0] !== "/" ? s = "/" : s = A, e.path = s;
        } else if (i === "secure") e.secure = true;
        else if (i === "httponly") e.httpOnly = true;
        else if (i === "samesite") {
          let s = "Default", o = A.toLowerCase();
          o.includes("none") && (s = "None"), o.includes("strict") && (s = "Strict"), o.includes("lax") && (s = "Lax"), e.sameSite = s;
        } else e.unparsed ??= [], e.unparsed.push(`${n}=${A}`);
        return $A(t, e);
      }
      uR.exports = { parseSetCookie: pq, parseUnparsedAttributes: $A };
    });
    var fR = C((ez, hR) => {
      "use strict";
      var { parseSetCookie: ER } = gR(), { stringify: Bq } = Ih(), { webidl: q } = Te(), { Headers: mq } = Tn(), sl = q.brandCheckMultiple([mq, globalThis.Headers].filter(Boolean));
      function yq(t) {
        q.argumentLengthCheck(arguments, 1, "getCookies"), sl(t);
        let e = t.get("cookie"), r = {};
        if (!e) return r;
        for (let n of e.split(";")) {
          let [A, ...i] = n.split("=");
          r[A.trim()] = i.join("=");
        }
        return r;
      }
      function wq(t, e, r) {
        sl(t);
        let n = "deleteCookie";
        q.argumentLengthCheck(arguments, 2, n), e = q.converters.DOMString(e, n, "name"), r = q.converters.DeleteCookieAttributes(r), dR(t, { name: e, value: "", expires: /* @__PURE__ */ new Date(0), ...r });
      }
      function Dq(t) {
        q.argumentLengthCheck(arguments, 1, "getSetCookies"), sl(t);
        let e = t.getSetCookie();
        return e ? e.map((r) => ER(r)) : [];
      }
      function Rq(t) {
        return t = q.converters.DOMString(t), ER(t);
      }
      function dR(t, e) {
        q.argumentLengthCheck(arguments, 2, "setCookie"), sl(t), e = q.converters.Cookie(e);
        let r = Bq(e);
        r && t.append("set-cookie", r, true);
      }
      q.converters.DeleteCookieAttributes = q.dictionaryConverter([{ converter: q.nullableConverter(q.converters.DOMString), key: "path", defaultValue: () => null }, { converter: q.nullableConverter(q.converters.DOMString), key: "domain", defaultValue: () => null }]);
      q.converters.Cookie = q.dictionaryConverter([{ converter: q.converters.DOMString, key: "name" }, { converter: q.converters.DOMString, key: "value" }, { converter: q.nullableConverter((t) => typeof t == "number" ? q.converters["unsigned long long"](t) : new Date(t)), key: "expires", defaultValue: () => null }, { converter: q.nullableConverter(q.converters["long long"]), key: "maxAge", defaultValue: () => null }, { converter: q.nullableConverter(q.converters.DOMString), key: "domain", defaultValue: () => null }, { converter: q.nullableConverter(q.converters.DOMString), key: "path", defaultValue: () => null }, { converter: q.nullableConverter(q.converters.boolean), key: "secure", defaultValue: () => null }, { converter: q.nullableConverter(q.converters.boolean), key: "httpOnly", defaultValue: () => null }, { converter: q.converters.USVString, key: "sameSite", allowedValues: ["Strict", "Lax", "None"] }, { converter: q.sequenceConverter(q.converters.DOMString), key: "unparsed", defaultValue: () => new Array(0) }]);
      hR.exports = { getCookies: yq, deleteCookie: wq, getSetCookies: Dq, setCookie: dR, parseCookie: Rq };
    });
    var cl = C((tz, CR) => {
      "use strict";
      var { webidl: S } = Te(), { kEnumerableProperty: Ke } = Y(), { kConstruct: QR } = ne(), zA = class t extends Event {
        #e;
        constructor(e, r = {}) {
          if (e === QR) {
            super(arguments[1], arguments[2]), S.util.markAsUncloneable(this);
            return;
          }
          let n = "MessageEvent constructor";
          S.argumentLengthCheck(arguments, 1, n), e = S.converters.DOMString(e, n, "type"), r = S.converters.MessageEventInit(r, n, "eventInitDict"), super(e, r), this.#e = r, S.util.markAsUncloneable(this);
        }
        get data() {
          return S.brandCheck(this, t), this.#e.data;
        }
        get origin() {
          return S.brandCheck(this, t), this.#e.origin;
        }
        get lastEventId() {
          return S.brandCheck(this, t), this.#e.lastEventId;
        }
        get source() {
          return S.brandCheck(this, t), this.#e.source;
        }
        get ports() {
          return S.brandCheck(this, t), Object.isFrozen(this.#e.ports) || Object.freeze(this.#e.ports), this.#e.ports;
        }
        initMessageEvent(e, r = false, n = false, A = null, i = "", s = "", o = null, a = []) {
          return S.brandCheck(this, t), S.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent"), new t(e, { bubbles: r, cancelable: n, data: A, origin: i, lastEventId: s, source: o, ports: a });
        }
        static createFastMessageEvent(e, r) {
          let n = new t(QR, e, r);
          return n.#e = r, n.#e.data ??= null, n.#e.origin ??= "", n.#e.lastEventId ??= "", n.#e.source ??= null, n.#e.ports ??= [], n;
        }
      }, { createFastMessageEvent: Sq } = zA;
      delete zA.createFastMessageEvent;
      var ol = class t extends Event {
        #e;
        constructor(e, r = {}) {
          let n = "CloseEvent constructor";
          S.argumentLengthCheck(arguments, 1, n), e = S.converters.DOMString(e, n, "type"), r = S.converters.CloseEventInit(r), super(e, r), this.#e = r, S.util.markAsUncloneable(this);
        }
        get wasClean() {
          return S.brandCheck(this, t), this.#e.wasClean;
        }
        get code() {
          return S.brandCheck(this, t), this.#e.code;
        }
        get reason() {
          return S.brandCheck(this, t), this.#e.reason;
        }
      }, al = class t extends Event {
        #e;
        constructor(e, r) {
          let n = "ErrorEvent constructor";
          S.argumentLengthCheck(arguments, 1, n), super(e, r), S.util.markAsUncloneable(this), e = S.converters.DOMString(e, n, "type"), r = S.converters.ErrorEventInit(r ?? {}), this.#e = r;
        }
        get message() {
          return S.brandCheck(this, t), this.#e.message;
        }
        get filename() {
          return S.brandCheck(this, t), this.#e.filename;
        }
        get lineno() {
          return S.brandCheck(this, t), this.#e.lineno;
        }
        get colno() {
          return S.brandCheck(this, t), this.#e.colno;
        }
        get error() {
          return S.brandCheck(this, t), this.#e.error;
        }
      };
      Object.defineProperties(zA.prototype, { [Symbol.toStringTag]: { value: "MessageEvent", configurable: true }, data: Ke, origin: Ke, lastEventId: Ke, source: Ke, ports: Ke, initMessageEvent: Ke });
      Object.defineProperties(ol.prototype, { [Symbol.toStringTag]: { value: "CloseEvent", configurable: true }, reason: Ke, code: Ke, wasClean: Ke });
      Object.defineProperties(al.prototype, { [Symbol.toStringTag]: { value: "ErrorEvent", configurable: true }, message: Ke, filename: Ke, lineno: Ke, colno: Ke, error: Ke });
      S.converters.MessagePort = S.interfaceConverter(S.is.MessagePort, "MessagePort");
      S.converters["sequence<MessagePort>"] = S.sequenceConverter(S.converters.MessagePort);
      var ph = [{ key: "bubbles", converter: S.converters.boolean, defaultValue: () => false }, { key: "cancelable", converter: S.converters.boolean, defaultValue: () => false }, { key: "composed", converter: S.converters.boolean, defaultValue: () => false }];
      S.converters.MessageEventInit = S.dictionaryConverter([...ph, { key: "data", converter: S.converters.any, defaultValue: () => null }, { key: "origin", converter: S.converters.USVString, defaultValue: () => "" }, { key: "lastEventId", converter: S.converters.DOMString, defaultValue: () => "" }, { key: "source", converter: S.nullableConverter(S.converters.MessagePort), defaultValue: () => null }, { key: "ports", converter: S.converters["sequence<MessagePort>"], defaultValue: () => new Array(0) }]);
      S.converters.CloseEventInit = S.dictionaryConverter([...ph, { key: "wasClean", converter: S.converters.boolean, defaultValue: () => false }, { key: "code", converter: S.converters["unsigned short"], defaultValue: () => 0 }, { key: "reason", converter: S.converters.USVString, defaultValue: () => "" }]);
      S.converters.ErrorEventInit = S.dictionaryConverter([...ph, { key: "message", converter: S.converters.DOMString, defaultValue: () => "" }, { key: "filename", converter: S.converters.USVString, defaultValue: () => "" }, { key: "lineno", converter: S.converters["unsigned long"], defaultValue: () => 0 }, { key: "colno", converter: S.converters["unsigned long"], defaultValue: () => 0 }, { key: "error", converter: S.converters.any }]);
      CR.exports = { MessageEvent: zA, CloseEvent: ol, ErrorEvent: al, createFastMessageEvent: Sq };
    });
    var zr = C((rz, IR) => {
      "use strict";
      var bq = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", Nq = { enumerable: true, writable: false, configurable: false }, Fq = { CONNECTING: 0, OPEN: 1, CLOSING: 2, CLOSED: 3 }, Tq = { SENT: 1, RECEIVED: 2 }, xq = { CONTINUATION: 0, TEXT: 1, BINARY: 2, CLOSE: 8, PING: 9, PONG: 10 }, Uq = 65535, kq = { INFO: 0, PAYLOADLENGTH_16: 2, PAYLOADLENGTH_64: 3, READ_DATA: 4 }, Mq = Buffer.allocUnsafe(0), Lq = { text: 1, typedArray: 2, arrayBuffer: 3, blob: 4 };
      IR.exports = { uid: bq, sentCloseFrameState: Tq, staticPropertyDescriptors: Nq, states: Fq, opcodes: xq, maxUnsigned16Bit: Uq, parserStates: kq, emptyBuffer: Mq, sendHints: Lq };
    });
    var Ln = C((nz, wR) => {
      "use strict";
      var { states: ll, opcodes: ei } = zr(), { isUtf8: vq } = require("node:buffer"), { collectASequenceOfCodePointsFast: Pq, removeHTTPWhitespace: pR } = tt();
      function Yq(t) {
        return t === ll.CONNECTING;
      }
      function Gq(t) {
        return t === ll.OPEN;
      }
      function Oq(t) {
        return t === ll.CLOSING;
      }
      function Vq(t) {
        return t === ll.CLOSED;
      }
      function Hq(t, e, r = (A, i) => new Event(A, i), n = {}) {
        let A = r(t, n);
        e.dispatchEvent(A);
      }
      function qq(t, e, r) {
        t.onMessage(e, r);
      }
      function Jq(t) {
        return t.byteLength === t.buffer.byteLength ? t.buffer : new Uint8Array(t).buffer;
      }
      function Wq(t) {
        if (t.length === 0) return false;
        for (let e = 0; e < t.length; ++e) {
          let r = t.charCodeAt(e);
          if (r < 33 || r > 126 || r === 34 || r === 40 || r === 41 || r === 44 || r === 47 || r === 58 || r === 59 || r === 60 || r === 61 || r === 62 || r === 63 || r === 64 || r === 91 || r === 92 || r === 93 || r === 123 || r === 125) return false;
        }
        return true;
      }
      function _q(t) {
        return t >= 1e3 && t < 1015 ? t !== 1004 && t !== 1005 && t !== 1006 : t >= 3e3 && t <= 4999;
      }
      function BR(t) {
        return t === ei.CLOSE || t === ei.PING || t === ei.PONG;
      }
      function mR(t) {
        return t === ei.CONTINUATION;
      }
      function yR(t) {
        return t === ei.TEXT || t === ei.BINARY;
      }
      function jq(t) {
        return yR(t) || mR(t) || BR(t);
      }
      function Zq(t) {
        let e = { position: 0 }, r = /* @__PURE__ */ new Map();
        for (; e.position < t.length; ) {
          let n = Pq(";", t, e), [A, i = ""] = n.split("=");
          r.set(pR(A, true, false), pR(i, false, true)), e.position++;
        }
        return r;
      }
      function Xq(t) {
        for (let e = 0; e < t.length; e++) {
          let r = t.charCodeAt(e);
          if (r < 48 || r > 57) return false;
        }
        return true;
      }
      function Kq(t, e) {
        let r;
        try {
          r = new URL(t, e);
        } catch (n) {
          throw new DOMException(n, "SyntaxError");
        }
        if (r.protocol === "http:" ? r.protocol = "ws:" : r.protocol === "https:" && (r.protocol = "wss:"), r.protocol !== "ws:" && r.protocol !== "wss:") throw new DOMException("expected a ws: or wss: url", "SyntaxError");
        if (r.hash.length || r.href.endsWith("#")) throw new DOMException("hash", "SyntaxError");
        return r;
      }
      function $q(t, e) {
        if (t !== null && t !== 1e3 && (t < 3e3 || t > 4999)) throw new DOMException("invalid code", "InvalidAccessError");
        if (e !== null) {
          let r = Buffer.byteLength(e);
          if (r > 123) throw new DOMException(`Reason must be less than 123 bytes; received ${r}`, "SyntaxError");
        }
      }
      var zq = (() => {
        if (typeof process.versions.icu == "string") {
          let t = new TextDecoder("utf-8", { fatal: true });
          return t.decode.bind(t);
        }
        return function(t) {
          if (vq(t)) return t.toString("utf-8");
          throw new TypeError("Invalid utf-8 received.");
        };
      })();
      wR.exports = { isConnecting: Yq, isEstablished: Gq, isClosing: Oq, isClosed: Vq, fireEvent: Hq, isValidSubprotocol: Wq, isValidStatusCode: _q, websocketMessageReceived: qq, utf8Decode: zq, isControlFrame: BR, isContinuationFrame: mR, isTextBinaryFrame: yR, isValidOpcode: jq, parseExtensions: Zq, isValidClientWindowBits: Xq, toArrayBuffer: Jq, getURLRecord: Kq, validateCloseCodeAndReason: $q };
    });
    var Gs = C((Az, SR) => {
      "use strict";
      var { maxUnsigned16Bit: DR, opcodes: eJ } = zr(), ul = 8 * 1024, Bh, Ys = null, ti = ul;
      try {
        Bh = require("node:crypto");
      } catch {
        Bh = { randomFillSync: function(e, r, n) {
          for (let A = 0; A < e.length; ++A) e[A] = Math.random() * 255 | 0;
          return e;
        } };
      }
      function RR() {
        return ti === ul && (ti = 0, Bh.randomFillSync(Ys ??= Buffer.allocUnsafeSlow(ul), 0, ul)), [Ys[ti++], Ys[ti++], Ys[ti++], Ys[ti++]];
      }
      var mh = class {
        constructor(e) {
          this.frameData = e;
        }
        createFrame(e) {
          let r = this.frameData, n = RR(), A = r?.byteLength ?? 0, i = A, s = 6;
          A > DR ? (s += 8, i = 127) : A > 125 && (s += 2, i = 126);
          let o = Buffer.allocUnsafe(A + s);
          o[0] = o[1] = 0, o[0] |= 128, o[0] = (o[0] & 240) + e;
          o[s - 4] = n[0], o[s - 3] = n[1], o[s - 2] = n[2], o[s - 1] = n[3], o[1] = i, i === 126 ? o.writeUInt16BE(A, 2) : i === 127 && (o[2] = o[3] = 0, o.writeUIntBE(A, 4, 6)), o[1] |= 128;
          for (let a = 0; a < A; ++a) o[s + a] = r[a] ^ n[a & 3];
          return o;
        }
        static createFastTextFrame(e) {
          let r = RR(), n = e.length;
          for (let o = 0; o < n; ++o) e[o] ^= r[o & 3];
          let A = n, i = 6;
          n > DR ? (i += 8, A = 127) : n > 125 && (i += 2, A = 126);
          let s = Buffer.allocUnsafeSlow(i);
          return s[0] = 128 | eJ.TEXT, s[1] = A | 128, s[i - 4] = r[0], s[i - 3] = r[1], s[i - 2] = r[2], s[i - 1] = r[3], A === 126 ? s.writeUInt16BE(n, 2) : A === 127 && (s[2] = s[3] = 0, s.writeUIntBE(n, 4, 6)), [s, e];
        }
      };
      SR.exports = { WebsocketFrameSend: mh };
    });
    var El = C((iz, xR) => {
      "use strict";
      var { uid: tJ, states: gl, sentCloseFrameState: yh, emptyBuffer: bR, opcodes: rJ } = zr(), { parseExtensions: nJ, isClosed: AJ, isClosing: iJ, isEstablished: FR, validateCloseCodeAndReason: sJ } = Ln(), { channels: NR } = lr(), { makeRequest: oJ } = XA(), { fetching: aJ } = Ms(), { Headers: cJ, getHeadersList: lJ } = Tn(), { getDecodeSplit: uJ } = Ve(), { WebsocketFrameSend: gJ } = Gs(), EJ = require("node:assert"), wh;
      try {
        wh = require("node:crypto");
      } catch {
      }
      function dJ(t, e, r, n, A) {
        let i = t;
        i.protocol = t.protocol === "ws:" ? "http:" : "https:";
        let s = oJ({ urlList: [i], client: r, serviceWorkers: "none", referrer: "no-referrer", mode: "websocket", credentials: "include", cache: "no-store", redirect: "error" });
        if (A.headers) {
          let l = lJ(new cJ(A.headers));
          s.headersList = l;
        }
        let o = wh.randomBytes(16).toString("base64");
        s.headersList.append("sec-websocket-key", o, true), s.headersList.append("sec-websocket-version", "13", true);
        for (let l of e) s.headersList.append("sec-websocket-protocol", l, true);
        return s.headersList.append("sec-websocket-extensions", "permessage-deflate; client_max_window_bits", true), aJ({ request: s, useParallelQueue: true, dispatcher: A.dispatcher, processResponse(l) {
          if (l.type === "error" && (n.readyState = gl.CLOSED), l.type === "error" || l.status !== 101) {
            mr(n, 1002, "Received network error or non-101 status code.");
            return;
          }
          if (e.length !== 0 && !l.headersList.get("Sec-WebSocket-Protocol")) {
            mr(n, 1002, "Server did not respond with sent protocols.");
            return;
          }
          if (l.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            mr(n, 1002, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (l.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            mr(n, 1002, 'Server did not set Connection header to "upgrade".');
            return;
          }
          let u = l.headersList.get("Sec-WebSocket-Accept"), g = wh.createHash("sha1").update(o + tJ).digest("base64");
          if (u !== g) {
            mr(n, 1002, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          let E = l.headersList.get("Sec-WebSocket-Extensions"), h;
          if (E !== null && (h = nJ(E), !h.has("permessage-deflate"))) {
            mr(n, 1002, "Sec-WebSocket-Extensions header does not match.");
            return;
          }
          let f = l.headersList.get("Sec-WebSocket-Protocol");
          if (f !== null && !uJ("sec-websocket-protocol", s.headersList).includes(f)) {
            mr(n, 1002, "Protocol was not set in the opening handshake.");
            return;
          }
          l.socket.on("data", n.onSocketData), l.socket.on("close", n.onSocketClose), l.socket.on("error", n.onSocketError), NR.open.hasSubscribers && NR.open.publish({ address: l.socket.address(), protocol: f, extensions: E }), n.wasEverConnected = true, n.onConnectionEstablished(l, h);
        } });
      }
      function TR(t, e, r, n = false) {
        if (e ??= null, r ??= "", n && sJ(e, r), !(AJ(t.readyState) || iJ(t.readyState))) if (!FR(t.readyState)) mr(t), t.readyState = gl.CLOSING;
        else if (!t.closeState.has(yh.SENT) && !t.closeState.has(yh.RECEIVED)) {
          let A = new gJ();
          r.length !== 0 && e === null && (e = 1e3), EJ(e === null || Number.isInteger(e)), e === null && r.length === 0 ? A.frameData = bR : e !== null && r === null ? (A.frameData = Buffer.allocUnsafe(2), A.frameData.writeUInt16BE(e, 0)) : e !== null && r !== null ? (A.frameData = Buffer.allocUnsafe(2 + Buffer.byteLength(r)), A.frameData.writeUInt16BE(e, 0), A.frameData.write(r, 2, "utf-8")) : A.frameData = bR, t.socket.write(A.createFrame(rJ.CLOSE)), t.closeState.add(yh.SENT), t.readyState = gl.CLOSING;
        } else t.readyState = gl.CLOSING;
      }
      function mr(t, e, r) {
        FR(t.readyState) && TR(t, e, r, false), t.controller.abort(), t.socket?.destroyed === false && t.socket.destroy(), t.onFail(e, r);
      }
      xR.exports = { establishWebSocketConnection: dJ, failWebsocketConnection: mr, closeWebSocketConnection: TR };
    });
    var kR = C((sz, UR) => {
      "use strict";
      var { createInflateRaw: hJ, Z_DEFAULT_WINDOWBITS: fJ } = require("node:zlib"), { isValidClientWindowBits: QJ } = Ln(), CJ = Buffer.from([0, 0, 255, 255]), dl = /* @__PURE__ */ Symbol("kBuffer"), hl = /* @__PURE__ */ Symbol("kLength"), Dh = class {
        #e;
        #t = {};
        constructor(e) {
          this.#t.serverNoContextTakeover = e.has("server_no_context_takeover"), this.#t.serverMaxWindowBits = e.get("server_max_window_bits");
        }
        decompress(e, r, n) {
          if (!this.#e) {
            let A = fJ;
            if (this.#t.serverMaxWindowBits) {
              if (!QJ(this.#t.serverMaxWindowBits)) {
                n(new Error("Invalid server_max_window_bits"));
                return;
              }
              A = Number.parseInt(this.#t.serverMaxWindowBits);
            }
            this.#e = hJ({ windowBits: A }), this.#e[dl] = [], this.#e[hl] = 0, this.#e.on("data", (i) => {
              this.#e[dl].push(i), this.#e[hl] += i.length;
            }), this.#e.on("error", (i) => {
              this.#e = null, n(i);
            });
          }
          this.#e.write(e), r && this.#e.write(CJ), this.#e.flush(() => {
            let A = Buffer.concat(this.#e[dl], this.#e[hl]);
            this.#e[dl].length = 0, this.#e[hl] = 0, n(null, A);
          });
        }
      };
      UR.exports = { PerMessageDeflate: Dh };
    });
    var bh = C((oz, YR) => {
      "use strict";
      var { Writable: IJ } = require("node:stream"), pJ = require("node:assert"), { parserStates: $e, opcodes: ri, states: BJ, emptyBuffer: MR, sentCloseFrameState: Os } = zr(), { channels: fl } = lr(), { isValidStatusCode: mJ, isValidOpcode: yJ, websocketMessageReceived: LR, utf8Decode: wJ, isControlFrame: vR, isTextBinaryFrame: Rh, isContinuationFrame: DJ } = Ln(), { failWebsocketConnection: st } = El(), { WebsocketFrameSend: PR } = Gs(), { PerMessageDeflate: RJ } = kR(), Sh = class extends IJ {
        #e = [];
        #t = 0;
        #r = 0;
        #n = false;
        #i = $e.INFO;
        #A = {};
        #a = [];
        #s;
        #o;
        constructor(e, r) {
          super(), this.#o = e, this.#s = r ?? /* @__PURE__ */ new Map(), this.#s.has("permessage-deflate") && this.#s.set("permessage-deflate", new RJ(r));
        }
        _write(e, r, n) {
          this.#e.push(e), this.#r += e.length, this.#n = true, this.run(n);
        }
        run(e) {
          for (; this.#n; ) if (this.#i === $e.INFO) {
            if (this.#r < 2) return e();
            let r = this.consume(2), n = (r[0] & 128) !== 0, A = r[0] & 15, i = (r[1] & 128) === 128, s = !n && A !== ri.CONTINUATION, o = r[1] & 127, a = r[0] & 64, c = r[0] & 32, l = r[0] & 16;
            if (!yJ(A)) return st(this.#o, 1002, "Invalid opcode received"), e();
            if (i) return st(this.#o, 1002, "Frame cannot be masked"), e();
            if (a !== 0 && !this.#s.has("permessage-deflate")) {
              st(this.#o, 1002, "Expected RSV1 to be clear.");
              return;
            }
            if (c !== 0 || l !== 0) {
              st(this.#o, 1002, "RSV1, RSV2, RSV3 must be clear");
              return;
            }
            if (s && !Rh(A)) {
              st(this.#o, 1002, "Invalid frame type was fragmented.");
              return;
            }
            if (Rh(A) && this.#a.length > 0) {
              st(this.#o, 1002, "Expected continuation frame");
              return;
            }
            if (this.#A.fragmented && s) {
              st(this.#o, 1002, "Fragmented frame exceeded 125 bytes.");
              return;
            }
            if ((o > 125 || s) && vR(A)) {
              st(this.#o, 1002, "Control frame either too large or fragmented");
              return;
            }
            if (DJ(A) && this.#a.length === 0 && !this.#A.compressed) {
              st(this.#o, 1002, "Unexpected continuation frame");
              return;
            }
            o <= 125 ? (this.#A.payloadLength = o, this.#i = $e.READ_DATA) : o === 126 ? this.#i = $e.PAYLOADLENGTH_16 : o === 127 && (this.#i = $e.PAYLOADLENGTH_64), Rh(A) && (this.#A.binaryType = A, this.#A.compressed = a !== 0), this.#A.opcode = A, this.#A.masked = i, this.#A.fin = n, this.#A.fragmented = s;
          } else if (this.#i === $e.PAYLOADLENGTH_16) {
            if (this.#r < 2) return e();
            let r = this.consume(2);
            this.#A.payloadLength = r.readUInt16BE(0), this.#i = $e.READ_DATA;
          } else if (this.#i === $e.PAYLOADLENGTH_64) {
            if (this.#r < 8) return e();
            let r = this.consume(8), n = r.readUInt32BE(0);
            if (n > 2 ** 31 - 1) {
              st(this.#o, 1009, "Received payload length > 2^31 bytes.");
              return;
            }
            let A = r.readUInt32BE(4);
            this.#A.payloadLength = (n << 8) + A, this.#i = $e.READ_DATA;
          } else if (this.#i === $e.READ_DATA) {
            if (this.#r < this.#A.payloadLength) return e();
            let r = this.consume(this.#A.payloadLength);
            if (vR(this.#A.opcode)) this.#n = this.parseControlFrame(r), this.#i = $e.INFO;
            else if (!this.#A.compressed) this.writeFragments(r), !this.#A.fragmented && this.#A.fin && LR(this.#o, this.#A.binaryType, this.consumeFragments()), this.#i = $e.INFO;
            else {
              this.#s.get("permessage-deflate").decompress(r, this.#A.fin, (n, A) => {
                if (n) {
                  st(this.#o, 1007, n.message);
                  return;
                }
                if (this.writeFragments(A), !this.#A.fin) {
                  this.#i = $e.INFO, this.#n = true, this.run(e);
                  return;
                }
                LR(this.#o, this.#A.binaryType, this.consumeFragments()), this.#n = true, this.#i = $e.INFO, this.run(e);
              }), this.#n = false;
              break;
            }
          }
        }
        consume(e) {
          if (e > this.#r) throw new Error("Called consume() before buffers satiated.");
          if (e === 0) return MR;
          this.#r -= e;
          let r = this.#e[0];
          if (r.length > e) return this.#e[0] = r.subarray(e, r.length), r.subarray(0, e);
          if (r.length === e) return this.#e.shift();
          {
            let n = 0, A = Buffer.allocUnsafeSlow(e);
            for (; n !== e; ) {
              let i = this.#e[0], s = i.length;
              if (s + n === e) {
                A.set(this.#e.shift(), n);
                break;
              } else if (s + n > e) {
                A.set(i.subarray(0, e - n), n), this.#e[0] = i.subarray(e - n);
                break;
              } else A.set(this.#e.shift(), n), n += s;
            }
            return A;
          }
        }
        writeFragments(e) {
          this.#t += e.length, this.#a.push(e);
        }
        consumeFragments() {
          let e = this.#a;
          if (e.length === 1) return this.#t = 0, e.shift();
          let r = 0, n = Buffer.allocUnsafeSlow(this.#t);
          for (let A = 0; A < e.length; ++A) {
            let i = e[A];
            n.set(i, r), r += i.length;
          }
          return this.#a = [], this.#t = 0, n;
        }
        parseCloseBody(e) {
          pJ(e.length !== 1);
          let r;
          if (e.length >= 2 && (r = e.readUInt16BE(0)), r !== void 0 && !mJ(r)) return { code: 1002, reason: "Invalid status code", error: true };
          let n = e.subarray(2);
          n[0] === 239 && n[1] === 187 && n[2] === 191 && (n = n.subarray(3));
          try {
            n = wJ(n);
          } catch {
            return { code: 1007, reason: "Invalid UTF-8", error: true };
          }
          return { code: r, reason: n, error: false };
        }
        parseControlFrame(e) {
          let { opcode: r, payloadLength: n } = this.#A;
          if (r === ri.CLOSE) {
            if (n === 1) return st(this.#o, 1002, "Received close frame with a 1-byte body."), false;
            if (this.#A.closeInfo = this.parseCloseBody(e), this.#A.closeInfo.error) {
              let { code: A, reason: i } = this.#A.closeInfo;
              return st(this.#o, A, i), false;
            }
            if (!this.#o.closeState.has(Os.SENT) && !this.#o.closeState.has(Os.RECEIVED)) {
              let A = MR;
              this.#A.closeInfo.code && (A = Buffer.allocUnsafe(2), A.writeUInt16BE(this.#A.closeInfo.code, 0));
              let i = new PR(A);
              this.#o.socket.write(i.createFrame(ri.CLOSE)), this.#o.closeState.add(Os.SENT);
            }
            return this.#o.readyState = BJ.CLOSING, this.#o.closeState.add(Os.RECEIVED), false;
          } else if (r === ri.PING) {
            if (!this.#o.closeState.has(Os.RECEIVED)) {
              let A = new PR(e);
              this.#o.socket.write(A.createFrame(ri.PONG)), fl.ping.hasSubscribers && fl.ping.publish({ payload: e });
            }
          } else r === ri.PONG && fl.pong.hasSubscribers && fl.pong.publish({ payload: e });
          return true;
        }
        get closingInfo() {
          return this.#A.closeInfo;
        }
      };
      YR.exports = { ByteParser: Sh };
    });
    var HR = C((az, VR) => {
      "use strict";
      var { WebsocketFrameSend: OR } = Gs(), { opcodes: GR, sendHints: vn } = zr(), SJ = xE(), Fh = class {
        #e = new SJ();
        #t = false;
        #r;
        constructor(e) {
          this.#r = e;
        }
        add(e, r, n) {
          if (n !== vn.blob) {
            if (this.#t) {
              let i = { promise: null, callback: r, frame: Nh(e, n) };
              this.#e.push(i);
            } else if (n === vn.text) {
              let { 0: i, 1: s } = OR.createFastTextFrame(e);
              this.#r.cork(), this.#r.write(i), this.#r.write(s, r), this.#r.uncork();
            } else this.#r.write(Nh(e, n), r);
            return;
          }
          let A = { promise: e.arrayBuffer().then((i) => {
            A.promise = null, A.frame = Nh(i, n);
          }), callback: r, frame: null };
          this.#e.push(A), this.#t || this.#n();
        }
        async #n() {
          this.#t = true;
          let e = this.#e;
          for (; !e.isEmpty(); ) {
            let r = e.shift();
            r.promise !== null && await r.promise, this.#r.write(r.frame, r.callback), r.callback = r.frame = null;
          }
          this.#t = false;
        }
      };
      function Nh(t, e) {
        return new OR(bJ(t, e)).createFrame(e === vn.text ? GR.TEXT : GR.BINARY);
      }
      function bJ(t, e) {
        switch (e) {
          case vn.text:
          case vn.typedArray:
            return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
          case vn.arrayBuffer:
          case vn.blob:
            return new Uint8Array(t);
        }
      }
      VR.exports = { SendQueue: Fh };
    });
    var XR = C((cz, ZR) => {
      "use strict";
      var { webidl: x } = Te(), { URLSerializer: NJ } = tt(), { environmentSettingsObject: qR } = Ve(), { staticPropertyDescriptors: en, states: er, sentCloseFrameState: Th, sendHints: Ql, opcodes: JR } = zr(), { isConnecting: FJ, isEstablished: TJ, isClosing: xJ, isValidSubprotocol: UJ, fireEvent: Vs, utf8Decode: kJ, toArrayBuffer: MJ, getURLRecord: LJ } = Ln(), { establishWebSocketConnection: vJ, closeWebSocketConnection: PJ, failWebsocketConnection: WR } = El(), { ByteParser: YJ } = bh(), { kEnumerableProperty: It } = Y(), { getGlobalDispatcher: GJ } = kc(), { types: jR } = require("node:util"), { ErrorEvent: OJ, CloseEvent: _R, createFastMessageEvent: VJ } = cl(), { SendQueue: HJ } = HR(), { channels: Cl } = lr(), ot = class t extends EventTarget {
        #e = { open: null, error: null, close: null, message: null };
        #t = 0;
        #r = "";
        #n = "";
        #i;
        #A = { onConnectionEstablished: (e, r) => this.#c(e, r), onFail: (e, r) => this.#g(e, r), onMessage: (e, r) => this.#l(e, r), onParserError: (e) => WR(this.#A, null, e.message), onParserDrain: () => this.#u(), onSocketData: (e) => {
          this.#o.write(e) || this.#A.socket.pause();
        }, onSocketError: (e) => {
          this.#A.readyState = er.CLOSING, Cl.socketError.hasSubscribers && Cl.socketError.publish(e), this.#A.socket.destroy();
        }, onSocketClose: () => this.#E(), readyState: er.CONNECTING, socket: null, closeState: /* @__PURE__ */ new Set(), controller: null, wasEverConnected: false };
        #a;
        #s;
        #o;
        constructor(e, r = []) {
          super(), x.util.markAsUncloneable(this);
          let n = "WebSocket constructor";
          x.argumentLengthCheck(arguments, 1, n);
          let A = x.converters["DOMString or sequence<DOMString> or WebSocketInit"](r, n, "options");
          e = x.converters.USVString(e), r = A.protocols;
          let i = qR.settingsObject.baseUrl, s = LJ(e, i);
          if (typeof r == "string" && (r = [r]), r.length !== new Set(r.map((a) => a.toLowerCase())).size) throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
          if (r.length > 0 && !r.every((a) => UJ(a))) throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
          this.#a = new URL(s.href);
          let o = qR.settingsObject;
          this.#A.controller = vJ(s, r, o, this.#A, A), this.#A.readyState = t.CONNECTING, this.#s = "blob";
        }
        close(e = void 0, r = void 0) {
          x.brandCheck(this, t), e !== void 0 && (e = x.converters["unsigned short"](e, "WebSocket.close", "code", { clamp: true })), r !== void 0 && (r = x.converters.USVString(r)), e ??= null, r ??= "", PJ(this.#A, e, r, true);
        }
        send(e) {
          x.brandCheck(this, t);
          let r = "WebSocket.send";
          if (x.argumentLengthCheck(arguments, 1, r), e = x.converters.WebSocketSendData(e, r, "data"), FJ(this.#A.readyState)) throw new DOMException("Sent before connected.", "InvalidStateError");
          if (!(!TJ(this.#A.readyState) || xJ(this.#A.readyState))) if (typeof e == "string") {
            let n = Buffer.from(e);
            this.#t += n.byteLength, this.#i.add(n, () => {
              this.#t -= n.byteLength;
            }, Ql.text);
          } else jR.isArrayBuffer(e) ? (this.#t += e.byteLength, this.#i.add(e, () => {
            this.#t -= e.byteLength;
          }, Ql.arrayBuffer)) : ArrayBuffer.isView(e) ? (this.#t += e.byteLength, this.#i.add(e, () => {
            this.#t -= e.byteLength;
          }, Ql.typedArray)) : x.is.Blob(e) && (this.#t += e.size, this.#i.add(e, () => {
            this.#t -= e.size;
          }, Ql.blob));
        }
        get readyState() {
          return x.brandCheck(this, t), this.#A.readyState;
        }
        get bufferedAmount() {
          return x.brandCheck(this, t), this.#t;
        }
        get url() {
          return x.brandCheck(this, t), NJ(this.#a);
        }
        get extensions() {
          return x.brandCheck(this, t), this.#n;
        }
        get protocol() {
          return x.brandCheck(this, t), this.#r;
        }
        get onopen() {
          return x.brandCheck(this, t), this.#e.open;
        }
        set onopen(e) {
          x.brandCheck(this, t), this.#e.open && this.removeEventListener("open", this.#e.open), typeof e == "function" ? (this.#e.open = e, this.addEventListener("open", e)) : this.#e.open = null;
        }
        get onerror() {
          return x.brandCheck(this, t), this.#e.error;
        }
        set onerror(e) {
          x.brandCheck(this, t), this.#e.error && this.removeEventListener("error", this.#e.error), typeof e == "function" ? (this.#e.error = e, this.addEventListener("error", e)) : this.#e.error = null;
        }
        get onclose() {
          return x.brandCheck(this, t), this.#e.close;
        }
        set onclose(e) {
          x.brandCheck(this, t), this.#e.close && this.removeEventListener("close", this.#e.close), typeof e == "function" ? (this.#e.close = e, this.addEventListener("close", e)) : this.#e.close = null;
        }
        get onmessage() {
          return x.brandCheck(this, t), this.#e.message;
        }
        set onmessage(e) {
          x.brandCheck(this, t), this.#e.message && this.removeEventListener("message", this.#e.message), typeof e == "function" ? (this.#e.message = e, this.addEventListener("message", e)) : this.#e.message = null;
        }
        get binaryType() {
          return x.brandCheck(this, t), this.#s;
        }
        set binaryType(e) {
          x.brandCheck(this, t), e !== "blob" && e !== "arraybuffer" ? this.#s = "blob" : this.#s = e;
        }
        #c(e, r) {
          this.#A.socket = e.socket;
          let n = new YJ(this.#A, r);
          n.on("drain", () => this.#A.onParserDrain()), n.on("error", (s) => this.#A.onParserError(s)), this.#o = n, this.#i = new HJ(e.socket), this.#A.readyState = er.OPEN;
          let A = e.headersList.get("sec-websocket-extensions");
          A !== null && (this.#n = A);
          let i = e.headersList.get("sec-websocket-protocol");
          i !== null && (this.#r = i), Vs("open", this);
        }
        #g(e, r) {
          r && Vs("error", this, (n, A) => new OJ(n, A), { error: new Error(r), message: r }), this.#A.wasEverConnected || (this.#A.readyState = er.CLOSED, Vs("close", this, (n, A) => new _R(n, A), { wasClean: false, code: e, reason: r }));
        }
        #l(e, r) {
          if (this.#A.readyState !== er.OPEN) return;
          let n;
          if (e === JR.TEXT) try {
            n = kJ(r);
          } catch {
            WR(this.#A, 1007, "Received invalid UTF-8 in text frame.");
            return;
          }
          else e === JR.BINARY && (this.#s === "blob" ? n = new Blob([r]) : n = MJ(r));
          Vs("message", this, VJ, { origin: this.#a.origin, data: n });
        }
        #u() {
          this.#A.socket.resume();
        }
        #E() {
          let e = this.#A.closeState.has(Th.SENT) && this.#A.closeState.has(Th.RECEIVED), r = 1005, n = "", A = this.#o.closingInfo;
          A && !A.error ? (r = A.code ?? 1005, n = A.reason) : this.#A.closeState.has(Th.RECEIVED) || (r = 1006), this.#A.readyState = er.CLOSED, Vs("close", this, (i, s) => new _R(i, s), { wasClean: e, code: r, reason: n }), Cl.close.hasSubscribers && Cl.close.publish({ websocket: this, code: r, reason: n });
        }
      };
      ot.CONNECTING = ot.prototype.CONNECTING = er.CONNECTING;
      ot.OPEN = ot.prototype.OPEN = er.OPEN;
      ot.CLOSING = ot.prototype.CLOSING = er.CLOSING;
      ot.CLOSED = ot.prototype.CLOSED = er.CLOSED;
      Object.defineProperties(ot.prototype, { CONNECTING: en, OPEN: en, CLOSING: en, CLOSED: en, url: It, readyState: It, bufferedAmount: It, onopen: It, onerror: It, onclose: It, close: It, onmessage: It, binaryType: It, send: It, extensions: It, protocol: It, [Symbol.toStringTag]: { value: "WebSocket", writable: false, enumerable: false, configurable: true } });
      Object.defineProperties(ot, { CONNECTING: en, OPEN: en, CLOSING: en, CLOSED: en });
      x.converters["sequence<DOMString>"] = x.sequenceConverter(x.converters.DOMString);
      x.converters["DOMString or sequence<DOMString>"] = function(t, e, r) {
        return x.util.Type(t) === x.util.Types.OBJECT && Symbol.iterator in t ? x.converters["sequence<DOMString>"](t) : x.converters.DOMString(t, e, r);
      };
      x.converters.WebSocketInit = x.dictionaryConverter([{ key: "protocols", converter: x.converters["DOMString or sequence<DOMString>"], defaultValue: () => new Array(0) }, { key: "dispatcher", converter: x.converters.any, defaultValue: () => GJ() }, { key: "headers", converter: x.nullableConverter(x.converters.HeadersInit) }]);
      x.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(t) {
        return x.util.Type(t) === x.util.Types.OBJECT && !(Symbol.iterator in t) ? x.converters.WebSocketInit(t) : { protocols: x.converters["DOMString or sequence<DOMString>"](t) };
      };
      x.converters.WebSocketSendData = function(t) {
        return x.util.Type(t) === x.util.Types.OBJECT && (x.is.Blob(t) || ArrayBuffer.isView(t) || jR.isArrayBuffer(t)) ? t : x.converters.USVString(t);
      };
      ZR.exports = { WebSocket: ot };
    });
    var xh = C((lz, zR) => {
      "use strict";
      var { webidl: Il } = Te(), { validateCloseCodeAndReason: qJ } = Ln(), { kConstruct: KR } = ne(), { kEnumerableProperty: $R } = Y(), Pn = class t extends DOMException {
        #e;
        #t;
        constructor(e = "", r = void 0) {
          if (e = Il.converters.DOMString(e, "WebSocketError", "message"), super(e, "WebSocketError"), r === KR) return;
          r !== null && (r = Il.converters.WebSocketCloseInfo(r));
          let n = r.closeCode ?? null, A = r.reason ?? "";
          qJ(n, A), A.length !== 0 && n === null && (n = 1e3), this.#e = n, this.#t = A;
        }
        get closeCode() {
          return this.#e;
        }
        get reason() {
          return this.#t;
        }
        static createUnvalidatedWebSocketError(e, r, n) {
          let A = new t(e, KR);
          return A.#e = r, A.#t = n, A;
        }
      }, { createUnvalidatedWebSocketError: JJ } = Pn;
      delete Pn.createUnvalidatedWebSocketError;
      Object.defineProperties(Pn.prototype, { closeCode: $R, reason: $R, [Symbol.toStringTag]: { value: "WebSocketError", writable: false, enumerable: false, configurable: true } });
      Il.is.WebSocketError = Il.util.MakeTypeAssertion(Pn);
      zR.exports = { WebSocketError: Pn, createUnvalidatedWebSocketError: JJ };
    });
    var AS = C((uz, nS) => {
      "use strict";
      var { createDeferredPromise: Uh, environmentSettingsObject: eS } = Ve(), { states: ni, opcodes: pl, sentCloseFrameState: Ai } = zr(), { webidl: Pe } = Te(), { getURLRecord: WJ, isValidSubprotocol: _J, isEstablished: jJ, utf8Decode: ZJ } = Ln(), { establishWebSocketConnection: XJ, failWebsocketConnection: kh, closeWebSocketConnection: Mh } = El(), { types: KJ } = require("node:util"), { channels: tS } = lr(), { WebsocketFrameSend: $J } = Gs(), { ByteParser: zJ } = bh(), { WebSocketError: eW, createUnvalidatedWebSocketError: tW } = xh(), { utf8DecodeBytes: rW } = Ve(), { kEnumerableProperty: Bl } = Y(), rS = false, ml = class {
        #e;
        #t;
        #r;
        #n;
        #i;
        #A;
        #a = false;
        #s = { onConnectionEstablished: (e, r) => this.#g(e, r), onFail: (e, r) => {
        }, onMessage: (e, r) => this.#l(e, r), onParserError: (e) => kh(this.#s, null, e.message), onParserDrain: () => this.#s.socket.resume(), onSocketData: (e) => {
          this.#o.write(e) || this.#s.socket.pause();
        }, onSocketError: (e) => {
          this.#s.readyState = ni.CLOSING, tS.socketError.hasSubscribers && tS.socketError.publish(e), this.#s.socket.destroy();
        }, onSocketClose: () => this.#u(), readyState: ni.CONNECTING, socket: null, closeState: /* @__PURE__ */ new Set(), controller: null, wasEverConnected: false };
        #o;
        constructor(e, r = void 0) {
          rS || (process.emitWarning("WebSocketStream is experimental! Expect it to change at any time.", { code: "UNDICI-WSS" }), rS = true), Pe.argumentLengthCheck(arguments, 1, "WebSocket"), e = Pe.converters.USVString(e), r !== null && (r = Pe.converters.WebSocketStreamOptions(r));
          let n = eS.settingsObject.baseUrl, A = WJ(e, n), i = r.protocols;
          if (i.length !== new Set(i.map((o) => o.toLowerCase())).size) throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
          if (i.length > 0 && !i.every((o) => _J(o))) throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
          if (this.#e = A.toString(), this.#t = Uh(), this.#r = Uh(), r.signal != null) {
            let o = r.signal;
            if (o.aborted) {
              this.#t.reject(o.reason), this.#r.reject(o.reason);
              return;
            }
            o.addEventListener("abort", () => {
              jJ(this.#s.readyState) || (kh(this.#s), this.#s.readyState = ni.CLOSING, this.#t.reject(o.reason), this.#r.reject(o.reason), this.#a = true);
            }, { once: true });
          }
          let s = eS.settingsObject;
          this.#s.controller = XJ(A, i, s, this.#s, r);
        }
        get url() {
          return this.#e.toString();
        }
        get opened() {
          return this.#t.promise;
        }
        get closed() {
          return this.#r.promise;
        }
        close(e = void 0) {
          e !== null && (e = Pe.converters.WebSocketCloseInfo(e));
          let r = e.closeCode ?? null, n = e.reason;
          Mh(this.#s, r, n, true);
        }
        #c(e) {
          let r = Uh(), n = null, A = null;
          if (ArrayBuffer.isView(e) || KJ.isArrayBuffer(e)) n = new Uint8Array(ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e), A = pl.BINARY;
          else {
            let i;
            try {
              i = Pe.converters.DOMString(e);
            } catch (s) {
              r.reject(s);
              return;
            }
            n = new TextEncoder().encode(i), A = pl.TEXT;
          }
          if (!this.#s.closeState.has(Ai.SENT) && !this.#s.closeState.has(Ai.RECEIVED)) {
            let i = new $J(n);
            this.#s.socket.write(i.createFrame(A), () => {
              r.resolve(void 0);
            });
          }
          return r;
        }
        #g(e, r) {
          this.#s.socket = e.socket;
          let n = new zJ(this.#s, r);
          n.on("drain", () => this.#s.onParserDrain()), n.on("error", (a) => this.#s.onParserError(a)), this.#o = n, this.#s.readyState = ni.OPEN;
          let A = r ?? "", i = e.headersList.get("sec-websocket-protocol") ?? "", s = new ReadableStream({ start: (a) => {
            this.#i = a;
          }, pull(a) {
            let c;
            for (; a.desiredSize > 0 && (c = e.socket.read()) !== null; ) a.enqueue(c);
          }, cancel: (a) => this.#d(a) }), o = new WritableStream({ write: (a) => this.#c(a), close: () => Mh(this.#s, null, null), abort: (a) => this.#E(a) });
          this.#n = s, this.#A = o, this.#t.resolve({ extensions: A, protocol: i, readable: s, writable: o });
        }
        #l(e, r) {
          if (this.#s.readyState !== ni.OPEN) return;
          let n;
          if (e === pl.TEXT) try {
            n = ZJ(r);
          } catch {
            kh(this.#s, "Received invalid UTF-8 in text frame.");
            return;
          }
          else e === pl.BINARY && (n = new Uint8Array(r.buffer, r.byteOffset, r.byteLength));
          this.#i.enqueue(n);
        }
        #u() {
          let e = this.#s.closeState.has(Ai.SENT) && this.#s.closeState.has(Ai.RECEIVED);
          if (this.#s.readyState = ni.CLOSED, this.#a) return;
          this.#s.wasEverConnected || this.#t.reject(new eW("Socket never opened"));
          let r = this.#o.closingInfo, n = r?.code ?? 1005;
          !this.#s.closeState.has(Ai.SENT) && !this.#s.closeState.has(Ai.RECEIVED) && (n = 1006);
          let A = r?.reason == null ? "" : rW(Buffer.from(r.reason));
          if (e) this.#n.cancel().catch(() => {
          }), this.#A.locked || this.#A.abort(new DOMException("A closed WebSocketStream cannot be written to", "InvalidStateError")), this.#r.resolve({ closeCode: n, reason: A });
          else {
            let i = tW("unclean close", n, A);
            this.#i.error(i), this.#A.abort(i), this.#r.reject(i);
          }
        }
        #E(e) {
          let r = null, n = "";
          Pe.is.WebSocketError(e) && (r = e.closeCode, n = e.reason), Mh(this.#s, r, n);
        }
        #d(e) {
          this.#E(e);
        }
      };
      Object.defineProperties(ml.prototype, { url: Bl, opened: Bl, closed: Bl, close: Bl, [Symbol.toStringTag]: { value: "WebSocketStream", writable: false, enumerable: false, configurable: true } });
      Pe.converters.WebSocketStreamOptions = Pe.dictionaryConverter([{ key: "protocols", converter: Pe.sequenceConverter(Pe.converters.USVString), defaultValue: () => [] }, { key: "signal", converter: Pe.nullableConverter(Pe.converters.AbortSignal), defaultValue: () => null }]);
      Pe.converters.WebSocketCloseInfo = Pe.dictionaryConverter([{ key: "closeCode", converter: (t) => Pe.converters["unsigned short"](t, { enforceRange: true }) }, { key: "reason", converter: Pe.converters.USVString, defaultValue: () => "" }]);
      nS.exports = { WebSocketStream: ml };
    });
    var Lh = C((gz, iS) => {
      "use strict";
      function nW(t) {
        return t.indexOf("\0") === -1;
      }
      function AW(t) {
        if (t.length === 0) return false;
        for (let e = 0; e < t.length; e++) if (t.charCodeAt(e) < 48 || t.charCodeAt(e) > 57) return false;
        return true;
      }
      function iW(t) {
        return new Promise((e) => {
          setTimeout(e, t).unref();
        });
      }
      iS.exports = { isValidLastEventId: nW, isASCIINumber: AW, delay: iW };
    });
    var cS = C((Ez, aS) => {
      "use strict";
      var { Transform: sW } = require("node:stream"), { isASCIINumber: sS, isValidLastEventId: oS } = Lh(), yr = [239, 187, 191], vh = 10, yl = 13, oW = 58, aW = 32, Ph = class extends sW {
        state;
        checkBOM = true;
        crlfCheck = false;
        eventEndCheck = false;
        buffer = null;
        pos = 0;
        event = { data: void 0, event: void 0, id: void 0, retry: void 0 };
        constructor(e = {}) {
          e.readableObjectMode = true, super(e), this.state = e.eventSourceSettings || {}, e.push && (this.push = e.push);
        }
        _transform(e, r, n) {
          if (e.length === 0) {
            n();
            return;
          }
          if (this.buffer ? this.buffer = Buffer.concat([this.buffer, e]) : this.buffer = e, this.checkBOM) switch (this.buffer.length) {
            case 1:
              if (this.buffer[0] === yr[0]) {
                n();
                return;
              }
              this.checkBOM = false, n();
              return;
            case 2:
              if (this.buffer[0] === yr[0] && this.buffer[1] === yr[1]) {
                n();
                return;
              }
              this.checkBOM = false;
              break;
            case 3:
              if (this.buffer[0] === yr[0] && this.buffer[1] === yr[1] && this.buffer[2] === yr[2]) {
                this.buffer = Buffer.alloc(0), this.checkBOM = false, n();
                return;
              }
              this.checkBOM = false;
              break;
            default:
              this.buffer[0] === yr[0] && this.buffer[1] === yr[1] && this.buffer[2] === yr[2] && (this.buffer = this.buffer.subarray(3)), this.checkBOM = false;
              break;
          }
          for (; this.pos < this.buffer.length; ) {
            if (this.eventEndCheck) {
              if (this.crlfCheck) {
                if (this.buffer[this.pos] === vh) {
                  this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.crlfCheck = false;
                  continue;
                }
                this.crlfCheck = false;
              }
              if (this.buffer[this.pos] === vh || this.buffer[this.pos] === yl) {
                this.buffer[this.pos] === yl && (this.crlfCheck = true), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, (this.event.data !== void 0 || this.event.event || this.event.id || this.event.retry) && this.processEvent(this.event), this.clearEvent();
                continue;
              }
              this.eventEndCheck = false;
              continue;
            }
            if (this.buffer[this.pos] === vh || this.buffer[this.pos] === yl) {
              this.buffer[this.pos] === yl && (this.crlfCheck = true), this.parseLine(this.buffer.subarray(0, this.pos), this.event), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.eventEndCheck = true;
              continue;
            }
            this.pos++;
          }
          n();
        }
        parseLine(e, r) {
          if (e.length === 0) return;
          let n = e.indexOf(oW);
          if (n === 0) return;
          let A = "", i = "";
          if (n !== -1) {
            A = e.subarray(0, n).toString("utf8");
            let s = n + 1;
            e[s] === aW && ++s, i = e.subarray(s).toString("utf8");
          } else A = e.toString("utf8"), i = "";
          switch (A) {
            case "data":
              r[A] === void 0 ? r[A] = i : r[A] += `
${i}`;
              break;
            case "retry":
              sS(i) && (r[A] = i);
              break;
            case "id":
              oS(i) && (r[A] = i);
              break;
            case "event":
              i.length > 0 && (r[A] = i);
              break;
          }
        }
        processEvent(e) {
          e.retry && sS(e.retry) && (this.state.reconnectionTime = parseInt(e.retry, 10)), e.id && oS(e.id) && (this.state.lastEventId = e.id), e.data !== void 0 && this.push({ type: e.event || "message", options: { data: e.data, lastEventId: this.state.lastEventId, origin: this.state.origin } });
        }
        clearEvent() {
          this.event = { data: void 0, event: void 0, id: void 0, retry: void 0 };
        }
      };
      aS.exports = { EventSourceStream: Ph };
    });
    var QS = C((dz, fS) => {
      "use strict";
      var { pipeline: cW } = require("node:stream"), { fetching: lW } = Ms(), { makeRequest: uW } = XA(), { webidl: wr } = Te(), { EventSourceStream: gW } = cS(), { parseMIMEType: EW } = tt(), { createFastMessageEvent: dW } = cl(), { isNetworkError: lS } = Us(), { delay: hW } = Lh(), { kEnumerableProperty: Yn } = Y(), { environmentSettingsObject: uS } = Ve(), gS = false, ES = 3e3, Hs = 0, dS = 1, qs = 2, fW = "anonymous", QW = "use-credentials", ii = class t extends EventTarget {
        #e = { open: null, error: null, message: null };
        #t;
        #r = false;
        #n = Hs;
        #i = null;
        #A = null;
        #a;
        #s;
        constructor(e, r = {}) {
          super(), wr.util.markAsUncloneable(this);
          let n = "EventSource constructor";
          wr.argumentLengthCheck(arguments, 1, n), gS || (gS = true, process.emitWarning("EventSource is experimental, expect them to change at any time.", { code: "UNDICI-ES" })), e = wr.converters.USVString(e), r = wr.converters.EventSourceInitDict(r, n, "eventSourceInitDict"), this.#a = r.dispatcher, this.#s = { lastEventId: "", reconnectionTime: ES };
          let A = uS, i;
          try {
            i = new URL(e, A.settingsObject.baseUrl), this.#s.origin = i.origin;
          } catch (a) {
            throw new DOMException(a, "SyntaxError");
          }
          this.#t = i.href;
          let s = fW;
          r.withCredentials === true && (s = QW, this.#r = true);
          let o = { redirect: "follow", keepalive: true, mode: "cors", credentials: s === "anonymous" ? "same-origin" : "omit", referrer: "no-referrer" };
          o.client = uS.settingsObject, o.headersList = [["accept", { name: "accept", value: "text/event-stream" }]], o.cache = "no-store", o.initiator = "other", o.urlList = [new URL(this.#t)], this.#i = uW(o), this.#o();
        }
        get readyState() {
          return this.#n;
        }
        get url() {
          return this.#t;
        }
        get withCredentials() {
          return this.#r;
        }
        #o() {
          if (this.#n === qs) return;
          this.#n = Hs;
          let e = { request: this.#i, dispatcher: this.#a }, r = (n) => {
            lS(n) && (this.dispatchEvent(new Event("error")), this.close()), this.#c();
          };
          e.processResponseEndOfBody = r, e.processResponse = (n) => {
            if (lS(n)) if (n.aborted) {
              this.close(), this.dispatchEvent(new Event("error"));
              return;
            } else {
              this.#c();
              return;
            }
            let A = n.headersList.get("content-type", true), i = A !== null ? EW(A) : "failure", s = i !== "failure" && i.essence === "text/event-stream";
            if (n.status !== 200 || s === false) {
              this.close(), this.dispatchEvent(new Event("error"));
              return;
            }
            this.#n = dS, this.dispatchEvent(new Event("open")), this.#s.origin = n.urlList[n.urlList.length - 1].origin;
            let o = new gW({ eventSourceSettings: this.#s, push: (a) => {
              this.dispatchEvent(dW(a.type, a.options));
            } });
            cW(n.body.stream, o, (a) => {
              a?.aborted === false && (this.close(), this.dispatchEvent(new Event("error")));
            });
          }, this.#A = lW(e);
        }
        async #c() {
          this.#n !== qs && (this.#n = Hs, this.dispatchEvent(new Event("error")), await hW(this.#s.reconnectionTime), this.#n === Hs && (this.#s.lastEventId.length && this.#i.headersList.set("last-event-id", this.#s.lastEventId, true), this.#o()));
        }
        close() {
          wr.brandCheck(this, t), this.#n !== qs && (this.#n = qs, this.#A.abort(), this.#i = null);
        }
        get onopen() {
          return this.#e.open;
        }
        set onopen(e) {
          this.#e.open && this.removeEventListener("open", this.#e.open), typeof e == "function" ? (this.#e.open = e, this.addEventListener("open", e)) : this.#e.open = null;
        }
        get onmessage() {
          return this.#e.message;
        }
        set onmessage(e) {
          this.#e.message && this.removeEventListener("message", this.#e.message), typeof e == "function" ? (this.#e.message = e, this.addEventListener("message", e)) : this.#e.message = null;
        }
        get onerror() {
          return this.#e.error;
        }
        set onerror(e) {
          this.#e.error && this.removeEventListener("error", this.#e.error), typeof e == "function" ? (this.#e.error = e, this.addEventListener("error", e)) : this.#e.error = null;
        }
      }, hS = { CONNECTING: { __proto__: null, configurable: false, enumerable: true, value: Hs, writable: false }, OPEN: { __proto__: null, configurable: false, enumerable: true, value: dS, writable: false }, CLOSED: { __proto__: null, configurable: false, enumerable: true, value: qs, writable: false } };
      Object.defineProperties(ii, hS);
      Object.defineProperties(ii.prototype, hS);
      Object.defineProperties(ii.prototype, { close: Yn, onerror: Yn, onmessage: Yn, onopen: Yn, readyState: Yn, url: Yn, withCredentials: Yn });
      wr.converters.EventSourceInitDict = wr.dictionaryConverter([{ key: "withCredentials", converter: wr.converters.boolean, defaultValue: () => false }, { key: "dispatcher", converter: wr.converters.any }]);
      fS.exports = { EventSource: ii, defaultReconnectionTime: ES };
    });
    var BS = C((hz, T) => {
      "use strict";
      var CW = fs(), CS = $i(), IW = LA(), pW = by(), BW = vA(), mW = XE(), yW = Jy(), wW = Ky(), IS = H(), Dl = Y(), { InvalidArgumentError: wl } = IS, si = xw(), DW = es(), RW = xd(), SW = ED(), bW = Md(), NW = Cd(), FW = pc(), { getGlobalDispatcher: pS, setGlobalDispatcher: TW } = kc(), xW = bs(), UW = Od();
      Object.assign(CS.prototype, si);
      T.exports.Dispatcher = CS;
      T.exports.Client = CW;
      T.exports.Pool = IW;
      T.exports.BalancedPool = pW;
      T.exports.Agent = BW;
      T.exports.ProxyAgent = mW;
      T.exports.EnvHttpProxyAgent = yW;
      T.exports.RetryAgent = wW;
      T.exports.RetryHandler = FW;
      T.exports.DecoratorHandler = xW;
      T.exports.RedirectHandler = UW;
      T.exports.interceptors = { redirect: DD(), responseError: SD(), retry: ND(), dump: TD(), dns: UD(), cache: XD() };
      T.exports.cacheStores = { MemoryCacheStore: Xd() };
      var kW = zD();
      T.exports.cacheStores.SqliteCacheStore = kW;
      T.exports.buildConnector = DW;
      T.exports.errors = IS;
      T.exports.util = { parseHeaders: Dl.parseHeaders, headerNameToString: Dl.headerNameToString };
      function Js(t) {
        return (e, r, n) => {
          if (typeof r == "function" && (n = r, r = null), !e || typeof e != "string" && typeof e != "object" && !(e instanceof URL)) throw new wl("invalid url");
          if (r != null && typeof r != "object") throw new wl("invalid opts");
          if (r && r.path != null) {
            if (typeof r.path != "string") throw new wl("invalid opts.path");
            let s = r.path;
            r.path.startsWith("/") || (s = `/${s}`), e = new URL(Dl.parseOrigin(e).origin + s);
          } else r || (r = typeof e == "object" ? e : {}), e = Dl.parseURL(e);
          let { agent: A, dispatcher: i = pS() } = r;
          if (A) throw new wl("unsupported opts.agent. Did you mean opts.client?");
          return t.call(i, { ...r, origin: e.origin, path: e.search ? `${e.pathname}${e.search}` : e.pathname, method: r.method || (r.body ? "PUT" : "GET") }, n);
        };
      }
      T.exports.setGlobalDispatcher = TW;
      T.exports.getGlobalDispatcher = pS;
      var MW = Ms().fetch;
      T.exports.fetch = async function(e, r = void 0) {
        try {
          return await MW(e, r);
        } catch (n) {
          throw n && typeof n == "object" && Error.captureStackTrace(n), n;
        }
      };
      T.exports.Headers = Tn().Headers;
      T.exports.Response = Us().Response;
      T.exports.Request = XA().Request;
      T.exports.FormData = Za().FormData;
      var { setGlobalOrigin: LW, getGlobalOrigin: vW } = Xg();
      T.exports.setGlobalOrigin = LW;
      T.exports.getGlobalOrigin = vW;
      var { CacheStorage: PW } = nR(), { kConstruct: YW } = ne();
      T.exports.caches = new PW(YW);
      var { deleteCookie: GW, getCookies: OW, getSetCookies: VW, setCookie: HW, parseCookie: qW } = fR();
      T.exports.deleteCookie = GW;
      T.exports.getCookies = OW;
      T.exports.getSetCookies = VW;
      T.exports.setCookie = HW;
      T.exports.parseCookie = qW;
      var { parseMIMEType: JW, serializeAMimeType: WW } = tt();
      T.exports.parseMIMEType = JW;
      T.exports.serializeAMimeType = WW;
      var { CloseEvent: _W, ErrorEvent: jW, MessageEvent: ZW } = cl();
      T.exports.WebSocket = XR().WebSocket;
      T.exports.CloseEvent = _W;
      T.exports.ErrorEvent = jW;
      T.exports.MessageEvent = ZW;
      T.exports.WebSocketStream = AS().WebSocketStream;
      T.exports.WebSocketError = xh().WebSocketError;
      T.exports.request = Js(si.request);
      T.exports.stream = Js(si.stream);
      T.exports.pipeline = Js(si.pipeline);
      T.exports.connect = Js(si.connect);
      T.exports.upgrade = Js(si.upgrade);
      T.exports.MockClient = RW;
      T.exports.MockPool = bW;
      T.exports.MockAgent = SW;
      T.exports.mockErrors = NW;
      var { EventSource: XW } = QS();
      T.exports.EventSource = XW;
    });
    var x_ = {};
    Jn(x_, { DMMF: () => Ui, Debug: () => ce, Decimal: () => ar, Extensions: () => Ml, MetricsClient: () => fA, PrismaClientInitializationError: () => Z, PrismaClientKnownRequestError: () => Ne, PrismaClientRustPanicError: () => ut, PrismaClientUnknownRequestError: () => Be, PrismaClientValidationError: () => Ue, Public: () => Ll, Sql: () => _e, createParam: () => DI, defineDmmfProperty: () => TI, deserializeJsonResponse: () => ai, deserializeRawResult: () => xl, dmmfToRuntimeDataModel: () => vC, empty: () => kI, getPrismaClient: () => Ib, getRuntime: () => up, join: () => UI, makeStrictEnum: () => pb, makeTypedQueryFactory: () => xI, objectEnumValues: () => ca, raw: () => Wu, serializeJsonQuery: () => fa, skip: () => ha, sqltag: () => _u, warnEnvConflicts: () => Bb, warnOnce: () => Fi });
    module2.exports = Sb(x_);
    var Ml = {};
    Jn(Ml, { defineExtension: () => ef, getExtensionContext: () => tf });
    function ef(t) {
      return typeof t == "function" ? t : (e) => e.$extends(t);
    }
    function tf(t) {
      return t;
    }
    var Ll = {};
    Jn(Ll, { validator: () => rf });
    function rf(...t) {
      return (e) => e;
    }
    var lo = {};
    Jn(lo, { $: () => af, bgBlack: () => vb, bgBlue: () => Ob, bgCyan: () => Hb, bgGreen: () => Yb, bgMagenta: () => Vb, bgRed: () => Pb, bgWhite: () => qb, bgYellow: () => Gb, black: () => Ub, blue: () => An, bold: () => be, cyan: () => nr, dim: () => nn, gray: () => hi, green: () => Sr, grey: () => Lb, hidden: () => Tb, inverse: () => Fb, italic: () => Nb, magenta: () => kb, red: () => at, reset: () => bb, strikethrough: () => xb, underline: () => Je, white: () => Mb, yellow: () => rr });
    var vl;
    var nf;
    var Af;
    var sf;
    var of = true;
    typeof process < "u" && ({ FORCE_COLOR: vl, NODE_DISABLE_COLORS: nf, NO_COLOR: Af, TERM: sf } = process.env || {}, of = process.stdout && process.stdout.isTTY);
    var af = { enabled: !nf && Af == null && sf !== "dumb" && (vl != null && vl !== "0" || of) };
    function Ae(t, e) {
      let r = new RegExp(`\\x1b\\[${e}m`, "g"), n = `\x1B[${t}m`, A = `\x1B[${e}m`;
      return function(i) {
        return !af.enabled || i == null ? i : n + (~("" + i).indexOf(A) ? i.replace(r, A + n) : i) + A;
      };
    }
    var bb = Ae(0, 0);
    var be = Ae(1, 22);
    var nn = Ae(2, 22);
    var Nb = Ae(3, 23);
    var Je = Ae(4, 24);
    var Fb = Ae(7, 27);
    var Tb = Ae(8, 28);
    var xb = Ae(9, 29);
    var Ub = Ae(30, 39);
    var at = Ae(31, 39);
    var Sr = Ae(32, 39);
    var rr = Ae(33, 39);
    var An = Ae(34, 39);
    var kb = Ae(35, 39);
    var nr = Ae(36, 39);
    var Mb = Ae(37, 39);
    var hi = Ae(90, 39);
    var Lb = Ae(90, 39);
    var vb = Ae(40, 49);
    var Pb = Ae(41, 49);
    var Yb = Ae(42, 49);
    var Gb = Ae(43, 49);
    var Ob = Ae(44, 49);
    var Vb = Ae(45, 49);
    var Hb = Ae(46, 49);
    var qb = Ae(47, 49);
    var Jb = 100;
    var cf = ["green", "yellow", "blue", "magenta", "cyan", "red"];
    var fi = [];
    var lf = Date.now();
    var Wb = 0;
    var Pl = typeof process < "u" ? process.env : {};
    globalThis.DEBUG ??= Pl.DEBUG ?? "";
    globalThis.DEBUG_COLORS ??= Pl.DEBUG_COLORS ? Pl.DEBUG_COLORS === "true" : true;
    var Qi = { enable(t) {
      typeof t == "string" && (globalThis.DEBUG = t);
    }, disable() {
      let t = globalThis.DEBUG;
      return globalThis.DEBUG = "", t;
    }, enabled(t) {
      let e = globalThis.DEBUG.split(",").map((A) => A.replace(/[.+?^${}()|[\]\\]/g, "\\$&")), r = e.some((A) => A === "" || A[0] === "-" ? false : t.match(RegExp(A.split("*").join(".*") + "$"))), n = e.some((A) => A === "" || A[0] !== "-" ? false : t.match(RegExp(A.slice(1).split("*").join(".*") + "$")));
      return r && !n;
    }, log: (...t) => {
      let [e, r, ...n] = t;
      (console.warn ?? console.log)(`${e} ${r}`, ...n);
    }, formatters: {} };
    function _b(t) {
      let e = { color: cf[Wb++ % cf.length], enabled: Qi.enabled(t), namespace: t, log: Qi.log, extend: () => {
      } }, r = (...n) => {
        let { enabled: A, namespace: i, color: s, log: o } = e;
        if (n.length !== 0 && fi.push([i, ...n]), fi.length > Jb && fi.shift(), Qi.enabled(i) || A) {
          let a = n.map((l) => typeof l == "string" ? l : jb(l)), c = `+${Date.now() - lf}ms`;
          lf = Date.now(), globalThis.DEBUG_COLORS ? o(lo[s](be(i)), ...a, lo[s](c)) : o(i, ...a, c);
        }
      };
      return new Proxy(r, { get: (n, A) => e[A], set: (n, A, i) => e[A] = i });
    }
    var ce = new Proxy(_b, { get: (t, e) => Qi[e], set: (t, e, r) => Qi[e] = r });
    function jb(t, e = 2) {
      let r = /* @__PURE__ */ new Set();
      return JSON.stringify(t, (n, A) => {
        if (typeof A == "object" && A !== null) {
          if (r.has(A)) return "[Circular *]";
          r.add(A);
        } else if (typeof A == "bigint") return A.toString();
        return A;
      }, e);
    }
    function uf(t = 7500) {
      let e = fi.map(([r, ...n]) => `${r} ${n.map((A) => typeof A == "string" ? A : JSON.stringify(A)).join(" ")}`).join(`
`);
      return e.length < t ? e : e.slice(-t);
    }
    function gf() {
      fi.length = 0;
    }
    var Wn = ce;
    var Yl = ["darwin", "darwin-arm64", "debian-openssl-1.0.x", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "linux-arm-openssl-1.1.x", "linux-arm-openssl-1.0.x", "linux-arm-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x", "linux-nixos", "linux-static-x64", "linux-static-arm64", "windows", "freebsd11", "freebsd12", "freebsd13", "freebsd14", "freebsd15", "openbsd", "netbsd", "arm"];
    var uo = "libquery_engine";
    function go(t, e) {
      let r = e === "url";
      return t.includes("windows") ? r ? "query_engine.dll.node" : `query_engine-${t}.dll.node` : t.includes("darwin") ? r ? `${uo}.dylib.node` : `${uo}-${t}.dylib.node` : r ? `${uo}.so.node` : `${uo}-${t}.so.node`;
    }
    var ff = G(require("node:child_process"));
    var ql = G(require("node:fs/promises"));
    var Io = G(require("node:os"));
    var Ar = /* @__PURE__ */ Symbol.for("@ts-pattern/matcher");
    var Zb = /* @__PURE__ */ Symbol.for("@ts-pattern/isVariadic");
    var ho = "@ts-pattern/anonymous-select-key";
    var Gl = (t) => !!(t && typeof t == "object");
    var Eo = (t) => t && !!t[Ar];
    var xt = (t, e, r) => {
      if (Eo(t)) {
        let n = t[Ar](), { matched: A, selections: i } = n.match(e);
        return A && i && Object.keys(i).forEach((s) => r(s, i[s])), A;
      }
      if (Gl(t)) {
        if (!Gl(e)) return false;
        if (Array.isArray(t)) {
          if (!Array.isArray(e)) return false;
          let n = [], A = [], i = [];
          for (let s of t.keys()) {
            let o = t[s];
            Eo(o) && o[Zb] ? i.push(o) : i.length ? A.push(o) : n.push(o);
          }
          if (i.length) {
            if (i.length > 1) throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");
            if (e.length < n.length + A.length) return false;
            let s = e.slice(0, n.length), o = A.length === 0 ? [] : e.slice(-A.length), a = e.slice(n.length, A.length === 0 ? 1 / 0 : -A.length);
            return n.every((c, l) => xt(c, s[l], r)) && A.every((c, l) => xt(c, o[l], r)) && (i.length === 0 || xt(i[0], a, r));
          }
          return t.length === e.length && t.every((s, o) => xt(s, e[o], r));
        }
        return Reflect.ownKeys(t).every((n) => {
          let A = t[n];
          return (n in e || Eo(i = A) && i[Ar]().matcherType === "optional") && xt(A, e[n], r);
          var i;
        });
      }
      return Object.is(e, t);
    };
    var xr = (t) => {
      var e, r, n;
      return Gl(t) ? Eo(t) ? (e = (r = (n = t[Ar]()).getSelectionKeys) == null ? void 0 : r.call(n)) != null ? e : [] : Array.isArray(t) ? Ci(t, xr) : Ci(Object.values(t), xr) : [];
    };
    var Ci = (t, e) => t.reduce((r, n) => r.concat(e(n)), []);
    function ct(t) {
      return Object.assign(t, { optional: () => Xb(t), and: (e) => le(t, e), or: (e) => Kb(t, e), select: (e) => e === void 0 ? Ef(t) : Ef(e, t) });
    }
    function Xb(t) {
      return ct({ [Ar]: () => ({ match: (e) => {
        let r = {}, n = (A, i) => {
          r[A] = i;
        };
        return e === void 0 ? (xr(t).forEach((A) => n(A, void 0)), { matched: true, selections: r }) : { matched: xt(t, e, n), selections: r };
      }, getSelectionKeys: () => xr(t), matcherType: "optional" }) });
    }
    function le(...t) {
      return ct({ [Ar]: () => ({ match: (e) => {
        let r = {}, n = (A, i) => {
          r[A] = i;
        };
        return { matched: t.every((A) => xt(A, e, n)), selections: r };
      }, getSelectionKeys: () => Ci(t, xr), matcherType: "and" }) });
    }
    function Kb(...t) {
      return ct({ [Ar]: () => ({ match: (e) => {
        let r = {}, n = (A, i) => {
          r[A] = i;
        };
        return Ci(t, xr).forEach((A) => n(A, void 0)), { matched: t.some((A) => xt(A, e, n)), selections: r };
      }, getSelectionKeys: () => Ci(t, xr), matcherType: "or" }) });
    }
    function j(t) {
      return { [Ar]: () => ({ match: (e) => ({ matched: !!t(e) }) }) };
    }
    function Ef(...t) {
      let e = typeof t[0] == "string" ? t[0] : void 0, r = t.length === 2 ? t[1] : typeof t[0] == "string" ? void 0 : t[0];
      return ct({ [Ar]: () => ({ match: (n) => {
        let A = { [e ?? ho]: n };
        return { matched: r === void 0 || xt(r, n, (i, s) => {
          A[i] = s;
        }), selections: A };
      }, getSelectionKeys: () => [e ?? ho].concat(r === void 0 ? [] : xr(r)) }) });
    }
    function Ft(t) {
      return typeof t == "number";
    }
    function br(t) {
      return typeof t == "string";
    }
    function Nr(t) {
      return typeof t == "bigint";
    }
    var q_ = ct(j(function(t) {
      return true;
    }));
    var Fr = (t) => Object.assign(ct(t), { startsWith: (e) => {
      return Fr(le(t, (r = e, j((n) => br(n) && n.startsWith(r)))));
      var r;
    }, endsWith: (e) => {
      return Fr(le(t, (r = e, j((n) => br(n) && n.endsWith(r)))));
      var r;
    }, minLength: (e) => Fr(le(t, ((r) => j((n) => br(n) && n.length >= r))(e))), length: (e) => Fr(le(t, ((r) => j((n) => br(n) && n.length === r))(e))), maxLength: (e) => Fr(le(t, ((r) => j((n) => br(n) && n.length <= r))(e))), includes: (e) => {
      return Fr(le(t, (r = e, j((n) => br(n) && n.includes(r)))));
      var r;
    }, regex: (e) => {
      return Fr(le(t, (r = e, j((n) => br(n) && !!n.match(r)))));
      var r;
    } });
    var J_ = Fr(j(br));
    var Tt = (t) => Object.assign(ct(t), { between: (e, r) => Tt(le(t, ((n, A) => j((i) => Ft(i) && n <= i && A >= i))(e, r))), lt: (e) => Tt(le(t, ((r) => j((n) => Ft(n) && n < r))(e))), gt: (e) => Tt(le(t, ((r) => j((n) => Ft(n) && n > r))(e))), lte: (e) => Tt(le(t, ((r) => j((n) => Ft(n) && n <= r))(e))), gte: (e) => Tt(le(t, ((r) => j((n) => Ft(n) && n >= r))(e))), int: () => Tt(le(t, j((e) => Ft(e) && Number.isInteger(e)))), finite: () => Tt(le(t, j((e) => Ft(e) && Number.isFinite(e)))), positive: () => Tt(le(t, j((e) => Ft(e) && e > 0))), negative: () => Tt(le(t, j((e) => Ft(e) && e < 0))) });
    var W_ = Tt(j(Ft));
    var Tr = (t) => Object.assign(ct(t), { between: (e, r) => Tr(le(t, ((n, A) => j((i) => Nr(i) && n <= i && A >= i))(e, r))), lt: (e) => Tr(le(t, ((r) => j((n) => Nr(n) && n < r))(e))), gt: (e) => Tr(le(t, ((r) => j((n) => Nr(n) && n > r))(e))), lte: (e) => Tr(le(t, ((r) => j((n) => Nr(n) && n <= r))(e))), gte: (e) => Tr(le(t, ((r) => j((n) => Nr(n) && n >= r))(e))), positive: () => Tr(le(t, j((e) => Nr(e) && e > 0))), negative: () => Tr(le(t, j((e) => Nr(e) && e < 0))) });
    var __ = Tr(j(Nr));
    var j_ = ct(j(function(t) {
      return typeof t == "boolean";
    }));
    var Z_ = ct(j(function(t) {
      return typeof t == "symbol";
    }));
    var X_ = ct(j(function(t) {
      return t == null;
    }));
    var K_ = ct(j(function(t) {
      return t != null;
    }));
    var Ol = class extends Error {
      constructor(e) {
        let r;
        try {
          r = JSON.stringify(e);
        } catch {
          r = e;
        }
        super(`Pattern matching error: no pattern matches value ${r}`), this.input = void 0, this.input = e;
      }
    };
    var Vl = { matched: false, value: void 0 };
    function fo(t) {
      return new Hl(t, Vl);
    }
    var Hl = class t {
      constructor(e, r) {
        this.input = void 0, this.state = void 0, this.input = e, this.state = r;
      }
      with(...e) {
        if (this.state.matched) return this;
        let r = e[e.length - 1], n = [e[0]], A;
        e.length === 3 && typeof e[1] == "function" ? A = e[1] : e.length > 2 && n.push(...e.slice(1, e.length - 1));
        let i = false, s = {}, o = (c, l) => {
          i = true, s[c] = l;
        }, a = !n.some((c) => xt(c, this.input, o)) || A && !A(this.input) ? Vl : { matched: true, value: r(i ? ho in s ? s[ho] : s : this.input, this.input) };
        return new t(this.input, a);
      }
      when(e, r) {
        if (this.state.matched) return this;
        let n = !!e(this.input);
        return new t(this.input, n ? { matched: true, value: r(this.input, this.input) } : Vl);
      }
      otherwise(e) {
        return this.state.matched ? this.state.value : e(this.input);
      }
      exhaustive() {
        if (this.state.matched) return this.state.value;
        throw new Ol(this.input);
      }
      run() {
        return this.exhaustive();
      }
      returnType() {
        return this;
      }
    };
    var Qf = require("node:util");
    var $b = { warn: rr("prisma:warn") };
    var zb = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
    function Qo(t, ...e) {
      zb.warn() && console.warn(`${$b.warn} ${t}`, ...e);
    }
    var eN = (0, Qf.promisify)(ff.default.exec);
    var Ge = Wn("prisma:get-platform");
    var tN = ["1.0.x", "1.1.x", "3.0.x"];
    async function Cf() {
      let t = Io.default.platform(), e = process.arch;
      if (t === "freebsd") {
        let s = await po("freebsd-version");
        if (s && s.trim().length > 0) {
          let a = /^(\d+)\.?/.exec(s);
          if (a) return { platform: "freebsd", targetDistro: `freebsd${a[1]}`, arch: e };
        }
      }
      if (t !== "linux") return { platform: t, arch: e };
      let r = await nN(), n = await gN(), A = iN({ arch: e, archFromUname: n, familyDistro: r.familyDistro }), { libssl: i } = await sN(A);
      return { platform: "linux", libssl: i, arch: e, archFromUname: n, ...r };
    }
    function rN(t) {
      let e = /^ID="?([^"\n]*)"?$/im, r = /^ID_LIKE="?([^"\n]*)"?$/im, n = e.exec(t), A = n && n[1] && n[1].toLowerCase() || "", i = r.exec(t), s = i && i[1] && i[1].toLowerCase() || "", o = fo({ id: A, idLike: s }).with({ id: "alpine" }, ({ id: a }) => ({ targetDistro: "musl", familyDistro: a, originalDistro: a })).with({ id: "raspbian" }, ({ id: a }) => ({ targetDistro: "arm", familyDistro: "debian", originalDistro: a })).with({ id: "nixos" }, ({ id: a }) => ({ targetDistro: "nixos", originalDistro: a, familyDistro: "nixos" })).with({ id: "debian" }, { id: "ubuntu" }, ({ id: a }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: a })).with({ id: "rhel" }, { id: "centos" }, { id: "fedora" }, ({ id: a }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: a })).when(({ idLike: a }) => a.includes("debian") || a.includes("ubuntu"), ({ id: a }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: a })).when(({ idLike: a }) => A === "arch" || a.includes("arch"), ({ id: a }) => ({ targetDistro: "debian", familyDistro: "arch", originalDistro: a })).when(({ idLike: a }) => a.includes("centos") || a.includes("fedora") || a.includes("rhel") || a.includes("suse"), ({ id: a }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: a })).otherwise(({ id: a }) => ({ targetDistro: void 0, familyDistro: void 0, originalDistro: a }));
      return Ge(`Found distro info:
${JSON.stringify(o, null, 2)}`), o;
    }
    async function nN() {
      let t = "/etc/os-release";
      try {
        let e = await ql.default.readFile(t, { encoding: "utf-8" });
        return rN(e);
      } catch {
        return { targetDistro: void 0, familyDistro: void 0, originalDistro: void 0 };
      }
    }
    function AN(t) {
      let e = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(t);
      if (e) {
        let r = `${e[1]}.x`;
        return If(r);
      }
    }
    function df(t) {
      let e = /libssl\.so\.(\d)(\.\d)?/.exec(t);
      if (e) {
        let r = `${e[1]}${e[2] ?? ".0"}.x`;
        return If(r);
      }
    }
    function If(t) {
      let e = (() => {
        if (pf(t)) return t;
        let r = t.split(".");
        return r[1] = "0", r.join(".");
      })();
      if (tN.includes(e)) return e;
    }
    function iN(t) {
      return fo(t).with({ familyDistro: "musl" }, () => (Ge('Trying platform-specific paths for "alpine"'), ["/lib", "/usr/lib"])).with({ familyDistro: "debian" }, ({ archFromUname: e }) => (Ge('Trying platform-specific paths for "debian" (and "ubuntu")'), [`/usr/lib/${e}-linux-gnu`, `/lib/${e}-linux-gnu`])).with({ familyDistro: "rhel" }, () => (Ge('Trying platform-specific paths for "rhel"'), ["/lib64", "/usr/lib64"])).otherwise(({ familyDistro: e, arch: r, archFromUname: n }) => (Ge(`Don't know any platform-specific paths for "${e}" on ${r} (${n})`), []));
    }
    async function sN(t) {
      let e = 'grep -v "libssl.so.0"', r = await hf(t);
      if (r) {
        Ge(`Found libssl.so file using platform-specific paths: ${r}`);
        let i = df(r);
        if (Ge(`The parsed libssl version is: ${i}`), i) return { libssl: i, strategy: "libssl-specific-path" };
      }
      Ge('Falling back to "ldconfig" and other generic paths');
      let n = await po(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${e}`);
      if (n || (n = await hf(["/lib64", "/usr/lib64", "/lib", "/usr/lib"])), n) {
        Ge(`Found libssl.so file using "ldconfig" or other generic paths: ${n}`);
        let i = df(n);
        if (Ge(`The parsed libssl version is: ${i}`), i) return { libssl: i, strategy: "ldconfig" };
      }
      let A = await po("openssl version -v");
      if (A) {
        Ge(`Found openssl binary with version: ${A}`);
        let i = AN(A);
        if (Ge(`The parsed openssl version is: ${i}`), i) return { libssl: i, strategy: "openssl-binary" };
      }
      return Ge("Couldn't find any version of libssl or OpenSSL in the system"), {};
    }
    async function hf(t) {
      for (let e of t) {
        let r = await oN(e);
        if (r) return r;
      }
    }
    async function oN(t) {
      try {
        return (await ql.default.readdir(t)).find((r) => r.startsWith("libssl.so.") && !r.startsWith("libssl.so.0"));
      } catch (e) {
        if (e.code === "ENOENT") return;
        throw e;
      }
    }
    async function sn() {
      let { binaryTarget: t } = await cN();
      return t;
    }
    function aN(t) {
      return t.binaryTarget !== void 0;
    }
    var Co = {};
    async function cN() {
      if (aN(Co)) return Promise.resolve({ ...Co, memoized: true });
      let t = await Cf(), e = lN(t);
      return Co = { ...t, binaryTarget: e }, { ...Co, memoized: false };
    }
    function lN(t) {
      let { platform: e, arch: r, archFromUname: n, libssl: A, targetDistro: i, familyDistro: s, originalDistro: o } = t;
      e === "linux" && !["x64", "arm64"].includes(r) && Qo(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures (detected "${r}" instead). If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n}".`);
      let a = "1.1.x";
      if (e === "linux" && A === void 0) {
        let l = fo({ familyDistro: s }).with({ familyDistro: "debian" }, () => "Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(() => "Please manually install OpenSSL and try installing Prisma again.");
        Qo(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${a}".
${l}`);
      }
      let c = "debian";
      if (e === "linux" && i === void 0 && Ge(`Distro is "${o}". Falling back to Prisma engines built for "${c}".`), e === "darwin" && r === "arm64") return "darwin-arm64";
      if (e === "darwin") return "darwin";
      if (e === "win32") return "windows";
      if (e === "freebsd") return i;
      if (e === "openbsd") return "openbsd";
      if (e === "netbsd") return "netbsd";
      if (e === "linux" && i === "nixos") return "linux-nixos";
      if (e === "linux" && r === "arm64") return `${i === "musl" ? "linux-musl-arm64" : "linux-arm64"}-openssl-${A || a}`;
      if (e === "linux" && r === "arm") return `linux-arm-openssl-${A || a}`;
      if (e === "linux" && i === "musl") {
        let l = "linux-musl";
        return !A || pf(A) ? l : `${l}-openssl-${A}`;
      }
      return e === "linux" && i && A ? `${i}-openssl-${A}` : (e !== "linux" && Qo(`Prisma detected unknown OS "${e}" and may not work as expected. Defaulting to "linux".`), A ? `${c}-openssl-${A}` : i ? `${i}-openssl-${a}` : `${c}-openssl-${a}`);
    }
    async function uN(t) {
      try {
        return await t();
      } catch {
        return;
      }
    }
    function po(t) {
      return uN(async () => {
        let e = await eN(t);
        return Ge(`Command "${t}" successfully returned "${e.stdout}"`), e.stdout;
      });
    }
    async function gN() {
      return typeof Io.default.machine == "function" ? Io.default.machine() : (await po("uname -m"))?.trim();
    }
    function pf(t) {
      return t.startsWith("1.");
    }
    var oT = nC();
    var uu = oT.version;
    function tA(t) {
      let e = aT();
      return e || (t?.config.engineType === "library" ? "library" : t?.config.engineType === "binary" ? "binary" : t?.config.engineType === "client" ? "client" : cT(t));
    }
    function aT() {
      let t = process.env.PRISMA_CLIENT_ENGINE_TYPE;
      return t === "library" ? "library" : t === "binary" ? "binary" : t === "client" ? "client" : void 0;
    }
    function cT(t) {
      return t?.previewFeatures.includes("queryCompiler") ? "client" : "library";
    }
    var CT = G(vo());
    var ie = G(require("node:path"));
    var IT = G(vo());
    var cj = ce("prisma:engines");
    function gC() {
      return ie.default.join(__dirname, "../");
    }
    ie.default.join(__dirname, "../query-engine-darwin");
    ie.default.join(__dirname, "../query-engine-darwin-arm64");
    ie.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
    ie.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
    ie.default.join(__dirname, "../query-engine-debian-openssl-3.0.x");
    ie.default.join(__dirname, "../query-engine-linux-static-x64");
    ie.default.join(__dirname, "../query-engine-linux-static-arm64");
    ie.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
    ie.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
    ie.default.join(__dirname, "../query-engine-rhel-openssl-3.0.x");
    ie.default.join(__dirname, "../libquery_engine-darwin.dylib.node");
    ie.default.join(__dirname, "../libquery_engine-darwin-arm64.dylib.node");
    ie.default.join(__dirname, "../libquery_engine-debian-openssl-1.0.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-debian-openssl-1.1.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-debian-openssl-3.0.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-linux-musl.so.node");
    ie.default.join(__dirname, "../libquery_engine-linux-musl-openssl-3.0.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-rhel-openssl-1.0.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-rhel-openssl-1.1.x.so.node");
    ie.default.join(__dirname, "../libquery_engine-rhel-openssl-3.0.x.so.node");
    ie.default.join(__dirname, "../query_engine-windows.dll.node");
    var hu = G(require("node:fs"));
    var EC = Wn("chmodPlusX");
    function fu(t) {
      if (process.platform === "win32") return;
      let e = hu.default.statSync(t), r = e.mode | 64 | 8 | 1;
      if (e.mode === r) {
        EC(`Execution permissions of ${t} are fine`);
        return;
      }
      let n = r.toString(8).slice(-3);
      EC(`Have to call chmodPlusX on ${t}`), hu.default.chmodSync(t, n);
    }
    var fC = G(hC(), 1);
    function Qu(t) {
      let e = (0, fC.default)(t);
      if (e === 0) return t;
      let r = new RegExp(`^[ \\t]{${e}}`, "gm");
      return t.replace(r, "");
    }
    var QC = "prisma+postgres";
    var Po = `${QC}:`;
    function Yo(t) {
      return t?.toString().startsWith(`${Po}//`) ?? false;
    }
    function Cu(t) {
      if (!Yo(t)) return false;
      let { host: e } = new URL(t);
      return e.includes("localhost") || e.includes("127.0.0.1") || e.includes("[::1]");
    }
    var IC = G(Iu());
    function Bu(t) {
      return String(new pu(t));
    }
    var pu = class {
      constructor(e) {
        this.config = e;
      }
      toString() {
        let { config: e } = this, r = e.provider.fromEnvVar ? `env("${e.provider.fromEnvVar}")` : e.provider.value, n = JSON.parse(JSON.stringify({ provider: r, binaryTargets: pT(e.binaryTargets) }));
        return `generator ${e.name} {
${(0, IC.default)(BT(n), 2)}
}`;
      }
    };
    function pT(t) {
      let e;
      if (t.length > 0) {
        let r = t.find((n) => n.fromEnvVar !== null);
        r ? e = `env("${r.fromEnvVar}")` : e = t.map((n) => n.native ? "native" : n.value);
      } else e = void 0;
      return e;
    }
    function BT(t) {
      let e = Object.keys(t).reduce((r, n) => Math.max(r, n.length), 0);
      return Object.entries(t).map(([r, n]) => `${r.padEnd(e)} = ${mT(n)}`).join(`
`);
    }
    function mT(t) {
      return JSON.parse(JSON.stringify(t, (e, r) => Array.isArray(r) ? `[${r.map((n) => JSON.stringify(n)).join(", ")}]` : JSON.stringify(r)));
    }
    var Di = {};
    Jn(Di, { error: () => DT, info: () => wT, log: () => yT, query: () => RT, should: () => pC, tags: () => wi, warn: () => mu });
    var wi = { error: at("prisma:error"), warn: rr("prisma:warn"), info: nr("prisma:info"), query: An("prisma:query") };
    var pC = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
    function yT(...t) {
      console.log(...t);
    }
    function mu(t, ...e) {
      pC.warn() && console.warn(`${wi.warn} ${t}`, ...e);
    }
    function wT(t, ...e) {
      console.info(`${wi.info} ${t}`, ...e);
    }
    function DT(t, ...e) {
      console.error(`${wi.error} ${t}`, ...e);
    }
    function RT(t, ...e) {
      console.log(`${wi.query} ${t}`, ...e);
    }
    function ln(t, e) {
      throw new Error(e);
    }
    var Go = G(require("node:stream"));
    var wC = G(require("node:util"));
    function Ri(t, e) {
      return bT(t, e);
    }
    function bT(t, e) {
      return t ? NT(t, e) : new un(e);
    }
    function NT(t, e) {
      if (!t) throw new Error("expected readStream");
      if (!t.readable) throw new Error("readStream must be readable");
      let r = new un(e);
      return t.pipe(r), r;
    }
    function un(t) {
      Go.default.Transform.call(this, t), t = t || {}, this._readableState.objectMode = true, this._lineBuffer = [], this._keepEmptyLines = t.keepEmptyLines || false, this._lastChunkEndedWithCR = false, this.on("pipe", function(e) {
        this.encoding || e instanceof Go.default.Readable && (this.encoding = e._readableState.encoding);
      });
    }
    wC.default.inherits(un, Go.default.Transform);
    un.prototype._transform = function(t, e, r) {
      e = e || "utf8", Buffer.isBuffer(t) && (e == "buffer" ? (t = t.toString(), e = "utf8") : t = t.toString(e)), this._chunkEncoding = e;
      let n = t.split(/\r\n|\r|\n/g);
      this._lastChunkEndedWithCR && t[0] == `
` && n.shift(), this._lineBuffer.length > 0 && (this._lineBuffer[this._lineBuffer.length - 1] += n[0], n.shift()), this._lastChunkEndedWithCR = t[t.length - 1] == "\r", this._lineBuffer = this._lineBuffer.concat(n), this._pushBuffer(e, 1, r);
    };
    un.prototype._pushBuffer = function(t, e, r) {
      for (; this._lineBuffer.length > e; ) {
        let n = this._lineBuffer.shift();
        if ((this._keepEmptyLines || n.length > 0) && !this.push(this._reencode(n, t))) {
          let A = this;
          setImmediate(function() {
            A._pushBuffer(t, e, r);
          });
          return;
        }
      }
      r();
    };
    un.prototype._flush = function(t) {
      this._pushBuffer(this._chunkEncoding, 0, t);
    };
    un.prototype._reencode = function(t, e) {
      return this.encoding && this.encoding != e ? Buffer.from(t, e).toString(this.encoding) : this.encoding ? t : Buffer.from(t, e);
    };
    var Si = G(require("node:path"));
    function wu(t) {
      return Si.default.sep === Si.default.posix.sep ? t : t.split(Si.default.sep).join(Si.default.posix.sep);
    }
    var bu = G(FC());
    var Oo = G(require("node:fs"));
    var rA = G(require("node:path"));
    function TC(t) {
      let e = t.ignoreProcessEnv ? {} : process.env, r = (n) => n.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(i, s) {
        let o = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);
        if (!o) return i;
        let a = o[1], c, l;
        if (a === "\\") l = o[0], c = l.replace("\\$", "$");
        else {
          let u = o[2];
          l = o[0].substring(a.length), c = Object.hasOwnProperty.call(e, u) ? e[u] : t.parsed[u] || "", c = r(c);
        }
        return i.replace(l, c);
      }, n) ?? n;
      for (let n in t.parsed) {
        let A = Object.hasOwnProperty.call(e, n) ? e[n] : t.parsed[n];
        t.parsed[n] = r(A);
      }
      for (let n in t.parsed) e[n] = t.parsed[n];
      return t;
    }
    var Su = Wn("prisma:tryLoadEnv");
    function Ni({ rootEnvPath: t, schemaEnvPath: e }, r = { conflictCheck: "none" }) {
      let n = xC(t);
      r.conflictCheck !== "none" && qT(n, e, r.conflictCheck);
      let A = null;
      return UC(n?.path, e) || (A = xC(e)), !n && !A && Su("No Environment variables loaded"), A?.dotenvResult.error ? console.error(at(be("Schema Env Error: ")) + A.dotenvResult.error) : { message: [n?.message, A?.message].filter(Boolean).join(`
`), parsed: { ...n?.dotenvResult?.parsed, ...A?.dotenvResult?.parsed } };
    }
    function qT(t, e, r) {
      let n = t?.dotenvResult.parsed, A = !UC(t?.path, e);
      if (n && e && A && Oo.default.existsSync(e)) {
        let i = bu.default.parse(Oo.default.readFileSync(e)), s = [];
        for (let o in i) n[o] === i[o] && s.push(o);
        if (s.length > 0) {
          let o = rA.default.relative(process.cwd(), t.path), a = rA.default.relative(process.cwd(), e);
          if (r === "error") {
            let c = `There is a conflict between env var${s.length > 1 ? "s" : ""} in ${Je(o)} and ${Je(a)}
Conflicting env vars:
${s.map((l) => `  ${be(l)}`).join(`
`)}

We suggest to move the contents of ${Je(a)} to ${Je(o)} to consolidate your env vars.
`;
            throw new Error(c);
          } else if (r === "warn") {
            let c = `Conflict for env var${s.length > 1 ? "s" : ""} ${s.map((l) => be(l)).join(", ")} in ${Je(o)} and ${Je(a)}
Env vars from ${Je(a)} overwrite the ones from ${Je(o)}
      `;
            console.warn(`${rr("warn(prisma)")} ${c}`);
          }
        }
      }
    }
    function xC(t) {
      if (JT(t)) {
        Su(`Environment variables loaded from ${t}`);
        let e = bu.default.config({ path: t, debug: process.env.DOTENV_CONFIG_DEBUG ? true : void 0 });
        return { dotenvResult: TC(e), message: nn(`Environment variables loaded from ${rA.default.relative(process.cwd(), t)}`), path: t };
      } else Su(`Environment variables not found at ${t}`);
      return null;
    }
    function UC(t, e) {
      return t && e && rA.default.resolve(t) === rA.default.resolve(e);
    }
    function JT(t) {
      return !!(t && Oo.default.existsSync(t));
    }
    function Nu(t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }
    function Ho(t, e) {
      let r = {};
      for (let n of Object.keys(t)) r[n] = e(t[n], n);
      return r;
    }
    function Fu(t, e) {
      if (t.length === 0) return;
      let r = t[0];
      for (let n = 1; n < t.length; n++) e(r, t[n]) < 0 && (r = t[n]);
      return r;
    }
    function M(t, e) {
      Object.defineProperty(t, "name", { value: e, configurable: true });
    }
    var MC = /* @__PURE__ */ new Set();
    var Fi = (t, e, ...r) => {
      MC.has(t) || (MC.add(t), mu(e, ...r));
    };
    var Z = class t extends Error {
      clientVersion;
      errorCode;
      retryable;
      constructor(e, r, n) {
        super(e), this.name = "PrismaClientInitializationError", this.clientVersion = r, this.errorCode = n, Error.captureStackTrace(t);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientInitializationError";
      }
    };
    M(Z, "PrismaClientInitializationError");
    var Ne = class extends Error {
      code;
      meta;
      clientVersion;
      batchRequestIdx;
      constructor(e, { code: r, clientVersion: n, meta: A, batchRequestIdx: i }) {
        super(e), this.name = "PrismaClientKnownRequestError", this.code = r, this.clientVersion = n, this.meta = A, Object.defineProperty(this, "batchRequestIdx", { value: i, enumerable: false, writable: true });
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientKnownRequestError";
      }
    };
    M(Ne, "PrismaClientKnownRequestError");
    var ut = class extends Error {
      clientVersion;
      constructor(e, r) {
        super(e), this.name = "PrismaClientRustPanicError", this.clientVersion = r;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientRustPanicError";
      }
    };
    M(ut, "PrismaClientRustPanicError");
    var Be = class extends Error {
      clientVersion;
      batchRequestIdx;
      constructor(e, { clientVersion: r, batchRequestIdx: n }) {
        super(e), this.name = "PrismaClientUnknownRequestError", this.clientVersion = r, Object.defineProperty(this, "batchRequestIdx", { value: n, writable: true, enumerable: false });
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientUnknownRequestError";
      }
    };
    M(Be, "PrismaClientUnknownRequestError");
    var Ue = class extends Error {
      name = "PrismaClientValidationError";
      clientVersion;
      constructor(e, { clientVersion: r }) {
        super(e), this.clientVersion = r;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientValidationError";
      }
    };
    M(Ue, "PrismaClientValidationError");
    var kt = class {
      _map = /* @__PURE__ */ new Map();
      get(e) {
        return this._map.get(e)?.value;
      }
      set(e, r) {
        this._map.set(e, { value: r });
      }
      getOrCreate(e, r) {
        let n = this._map.get(e);
        if (n) return n.value;
        let A = r();
        return this.set(e, A), A;
      }
    };
    function Ur(t) {
      return t.substring(0, 1).toLowerCase() + t.substring(1);
    }
    function LC(t, e) {
      let r = {};
      for (let n of t) {
        let A = n[e];
        r[A] = n;
      }
      return r;
    }
    function Ti(t) {
      let e;
      return { get() {
        return e || (e = { value: t() }), e.value;
      } };
    }
    function vC(t) {
      return { models: Tu(t.models), enums: Tu(t.enums), types: Tu(t.types) };
    }
    function Tu(t) {
      let e = {};
      for (let { name: r, ...n } of t) e[r] = n;
      return e;
    }
    function nA(t) {
      return t instanceof Date || Object.prototype.toString.call(t) === "[object Date]";
    }
    function Jo(t) {
      return t.toString() !== "Invalid Date";
    }
    var AA = 9e15;
    var vr = 1e9;
    var xu = "0123456789abcdef";
    var jo = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
    var Zo = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
    var Uu = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -AA, maxE: AA, crypto: false };
    var OC;
    var sr;
    var L = true;
    var Ko = "[DecimalError] ";
    var Lr = Ko + "Invalid argument: ";
    var VC = Ko + "Precision limit exceeded";
    var HC = Ko + "crypto unavailable";
    var qC = "[object Decimal]";
    var ke = Math.floor;
    var me = Math.pow;
    var WT = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
    var _T = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
    var jT = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
    var JC = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
    var pt = 1e7;
    var N = 7;
    var ZT = 9007199254740991;
    var XT = jo.length - 1;
    var ku = Zo.length - 1;
    var y = { toStringTag: qC };
    y.absoluteValue = y.abs = function() {
      var t = new this.constructor(this);
      return t.s < 0 && (t.s = 1), b(t);
    };
    y.ceil = function() {
      return b(new this.constructor(this), this.e + 1, 2);
    };
    y.clampedTo = y.clamp = function(t, e) {
      var r, n = this, A = n.constructor;
      if (t = new A(t), e = new A(e), !t.s || !e.s) return new A(NaN);
      if (t.gt(e)) throw Error(Lr + e);
      return r = n.cmp(t), r < 0 ? t : n.cmp(e) > 0 ? e : new A(n);
    };
    y.comparedTo = y.cmp = function(t) {
      var e, r, n, A, i = this, s = i.d, o = (t = new i.constructor(t)).d, a = i.s, c = t.s;
      if (!s || !o) return !a || !c ? NaN : a !== c ? a : s === o ? 0 : !s ^ a < 0 ? 1 : -1;
      if (!s[0] || !o[0]) return s[0] ? a : o[0] ? -c : 0;
      if (a !== c) return a;
      if (i.e !== t.e) return i.e > t.e ^ a < 0 ? 1 : -1;
      for (n = s.length, A = o.length, e = 0, r = n < A ? n : A; e < r; ++e) if (s[e] !== o[e]) return s[e] > o[e] ^ a < 0 ? 1 : -1;
      return n === A ? 0 : n > A ^ a < 0 ? 1 : -1;
    };
    y.cosine = y.cos = function() {
      var t, e, r = this, n = r.constructor;
      return r.d ? r.d[0] ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + N, n.rounding = 1, r = KT(n, XC(n, r)), n.precision = t, n.rounding = e, b(sr == 2 || sr == 3 ? r.neg() : r, t, e, true)) : new n(1) : new n(NaN);
    };
    y.cubeRoot = y.cbrt = function() {
      var t, e, r, n, A, i, s, o, a, c, l = this, u = l.constructor;
      if (!l.isFinite() || l.isZero()) return new u(l);
      for (L = false, i = l.s * me(l.s * l, 1 / 3), !i || Math.abs(i) == 1 / 0 ? (r = Fe(l.d), t = l.e, (i = (t - r.length + 1) % 3) && (r += i == 1 || i == -2 ? "0" : "00"), i = me(r, 1 / 3), t = ke((t + 1) / 3) - (t % 3 == (t < 0 ? -1 : 2)), i == 1 / 0 ? r = "5e" + t : (r = i.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + t), n = new u(r), n.s = l.s) : n = new u(i.toString()), s = (t = u.precision) + 3; ; ) if (o = n, a = o.times(o).times(o), c = a.plus(l), n = re(c.plus(l).times(o), c.plus(a), s + 2, 1), Fe(o.d).slice(0, s) === (r = Fe(n.d)).slice(0, s)) if (r = r.slice(s - 3, s + 1), r == "9999" || !A && r == "4999") {
        if (!A && (b(o, t + 1, 0), o.times(o).times(o).eq(l))) {
          n = o;
          break;
        }
        s += 4, A = 1;
      } else {
        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (b(n, t + 1, 1), e = !n.times(n).times(n).eq(l));
        break;
      }
      return L = true, b(n, t, u.rounding, e);
    };
    y.decimalPlaces = y.dp = function() {
      var t, e = this.d, r = NaN;
      if (e) {
        if (t = e.length - 1, r = (t - ke(this.e / N)) * N, t = e[t], t) for (; t % 10 == 0; t /= 10) r--;
        r < 0 && (r = 0);
      }
      return r;
    };
    y.dividedBy = y.div = function(t) {
      return re(this, new this.constructor(t));
    };
    y.dividedToIntegerBy = y.divToInt = function(t) {
      var e = this, r = e.constructor;
      return b(re(e, new r(t), 0, 1, 1), r.precision, r.rounding);
    };
    y.equals = y.eq = function(t) {
      return this.cmp(t) === 0;
    };
    y.floor = function() {
      return b(new this.constructor(this), this.e + 1, 3);
    };
    y.greaterThan = y.gt = function(t) {
      return this.cmp(t) > 0;
    };
    y.greaterThanOrEqualTo = y.gte = function(t) {
      var e = this.cmp(t);
      return e == 1 || e === 0;
    };
    y.hyperbolicCosine = y.cosh = function() {
      var t, e, r, n, A, i = this, s = i.constructor, o = new s(1);
      if (!i.isFinite()) return new s(i.s ? 1 / 0 : NaN);
      if (i.isZero()) return o;
      r = s.precision, n = s.rounding, s.precision = r + Math.max(i.e, i.sd()) + 4, s.rounding = 1, A = i.d.length, A < 32 ? (t = Math.ceil(A / 3), e = (1 / zo(4, t)).toString()) : (t = 16, e = "2.3283064365386962890625e-10"), i = iA(s, 1, i.times(e), new s(1), true);
      for (var a, c = t, l = new s(8); c--; ) a = i.times(i), i = o.minus(a.times(l.minus(a.times(l))));
      return b(i, s.precision = r, s.rounding = n, true);
    };
    y.hyperbolicSine = y.sinh = function() {
      var t, e, r, n, A = this, i = A.constructor;
      if (!A.isFinite() || A.isZero()) return new i(A);
      if (e = i.precision, r = i.rounding, i.precision = e + Math.max(A.e, A.sd()) + 4, i.rounding = 1, n = A.d.length, n < 3) A = iA(i, 2, A, A, true);
      else {
        t = 1.4 * Math.sqrt(n), t = t > 16 ? 16 : t | 0, A = A.times(1 / zo(5, t)), A = iA(i, 2, A, A, true);
        for (var s, o = new i(5), a = new i(16), c = new i(20); t--; ) s = A.times(A), A = A.times(o.plus(s.times(a.times(s).plus(c))));
      }
      return i.precision = e, i.rounding = r, b(A, e, r, true);
    };
    y.hyperbolicTangent = y.tanh = function() {
      var t, e, r = this, n = r.constructor;
      return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 7, n.rounding = 1, re(r.sinh(), r.cosh(), n.precision = t, n.rounding = e)) : new n(r.s);
    };
    y.inverseCosine = y.acos = function() {
      var t = this, e = t.constructor, r = t.abs().cmp(1), n = e.precision, A = e.rounding;
      return r !== -1 ? r === 0 ? t.isNeg() ? Mt(e, n, A) : new e(0) : new e(NaN) : t.isZero() ? Mt(e, n + 4, A).times(0.5) : (e.precision = n + 6, e.rounding = 1, t = new e(1).minus(t).div(t.plus(1)).sqrt().atan(), e.precision = n, e.rounding = A, t.times(2));
    };
    y.inverseHyperbolicCosine = y.acosh = function() {
      var t, e, r = this, n = r.constructor;
      return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, L = false, r = r.times(r).minus(1).sqrt().plus(r), L = true, n.precision = t, n.rounding = e, r.ln()) : new n(r);
    };
    y.inverseHyperbolicSine = y.asinh = function() {
      var t, e, r = this, n = r.constructor;
      return !r.isFinite() || r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, L = false, r = r.times(r).plus(1).sqrt().plus(r), L = true, n.precision = t, n.rounding = e, r.ln());
    };
    y.inverseHyperbolicTangent = y.atanh = function() {
      var t, e, r, n, A = this, i = A.constructor;
      return A.isFinite() ? A.e >= 0 ? new i(A.abs().eq(1) ? A.s / 0 : A.isZero() ? A : NaN) : (t = i.precision, e = i.rounding, n = A.sd(), Math.max(n, t) < 2 * -A.e - 1 ? b(new i(A), t, e, true) : (i.precision = r = n - A.e, A = re(A.plus(1), new i(1).minus(A), r + t, 1), i.precision = t + 4, i.rounding = 1, A = A.ln(), i.precision = t, i.rounding = e, A.times(0.5))) : new i(NaN);
    };
    y.inverseSine = y.asin = function() {
      var t, e, r, n, A = this, i = A.constructor;
      return A.isZero() ? new i(A) : (e = A.abs().cmp(1), r = i.precision, n = i.rounding, e !== -1 ? e === 0 ? (t = Mt(i, r + 4, n).times(0.5), t.s = A.s, t) : new i(NaN) : (i.precision = r + 6, i.rounding = 1, A = A.div(new i(1).minus(A.times(A)).sqrt().plus(1)).atan(), i.precision = r, i.rounding = n, A.times(2)));
    };
    y.inverseTangent = y.atan = function() {
      var t, e, r, n, A, i, s, o, a, c = this, l = c.constructor, u = l.precision, g = l.rounding;
      if (c.isFinite()) {
        if (c.isZero()) return new l(c);
        if (c.abs().eq(1) && u + 4 <= ku) return s = Mt(l, u + 4, g).times(0.25), s.s = c.s, s;
      } else {
        if (!c.s) return new l(NaN);
        if (u + 4 <= ku) return s = Mt(l, u + 4, g).times(0.5), s.s = c.s, s;
      }
      for (l.precision = o = u + 10, l.rounding = 1, r = Math.min(28, o / N + 2 | 0), t = r; t; --t) c = c.div(c.times(c).plus(1).sqrt().plus(1));
      for (L = false, e = Math.ceil(o / N), n = 1, a = c.times(c), s = new l(c), A = c; t !== -1; ) if (A = A.times(a), i = s.minus(A.div(n += 2)), A = A.times(a), s = i.plus(A.div(n += 2)), s.d[e] !== void 0) for (t = e; s.d[t] === i.d[t] && t--; ) ;
      return r && (s = s.times(2 << r - 1)), L = true, b(s, l.precision = u, l.rounding = g, true);
    };
    y.isFinite = function() {
      return !!this.d;
    };
    y.isInteger = y.isInt = function() {
      return !!this.d && ke(this.e / N) > this.d.length - 2;
    };
    y.isNaN = function() {
      return !this.s;
    };
    y.isNegative = y.isNeg = function() {
      return this.s < 0;
    };
    y.isPositive = y.isPos = function() {
      return this.s > 0;
    };
    y.isZero = function() {
      return !!this.d && this.d[0] === 0;
    };
    y.lessThan = y.lt = function(t) {
      return this.cmp(t) < 0;
    };
    y.lessThanOrEqualTo = y.lte = function(t) {
      return this.cmp(t) < 1;
    };
    y.logarithm = y.log = function(t) {
      var e, r, n, A, i, s, o, a, c = this, l = c.constructor, u = l.precision, g = l.rounding, E = 5;
      if (t == null) t = new l(10), e = true;
      else {
        if (t = new l(t), r = t.d, t.s < 0 || !r || !r[0] || t.eq(1)) return new l(NaN);
        e = t.eq(10);
      }
      if (r = c.d, c.s < 0 || !r || !r[0] || c.eq(1)) return new l(r && !r[0] ? -1 / 0 : c.s != 1 ? NaN : r ? 0 : 1 / 0);
      if (e) if (r.length > 1) i = true;
      else {
        for (A = r[0]; A % 10 === 0; ) A /= 10;
        i = A !== 1;
      }
      if (L = false, o = u + E, s = Mr(c, o), n = e ? Xo(l, o + 10) : Mr(t, o), a = re(s, n, o, 1), xi(a.d, A = u, g)) do
        if (o += 10, s = Mr(c, o), n = e ? Xo(l, o + 10) : Mr(t, o), a = re(s, n, o, 1), !i) {
          +Fe(a.d).slice(A + 1, A + 15) + 1 == 1e14 && (a = b(a, u + 1, 0));
          break;
        }
      while (xi(a.d, A += 10, g));
      return L = true, b(a, u, g);
    };
    y.minus = y.sub = function(t) {
      var e, r, n, A, i, s, o, a, c, l, u, g, E = this, h = E.constructor;
      if (t = new h(t), !E.d || !t.d) return !E.s || !t.s ? t = new h(NaN) : E.d ? t.s = -t.s : t = new h(t.d || E.s !== t.s ? E : NaN), t;
      if (E.s != t.s) return t.s = -t.s, E.plus(t);
      if (c = E.d, g = t.d, o = h.precision, a = h.rounding, !c[0] || !g[0]) {
        if (g[0]) t.s = -t.s;
        else if (c[0]) t = new h(E);
        else return new h(a === 3 ? -0 : 0);
        return L ? b(t, o, a) : t;
      }
      if (r = ke(t.e / N), l = ke(E.e / N), c = c.slice(), i = l - r, i) {
        for (u = i < 0, u ? (e = c, i = -i, s = g.length) : (e = g, r = l, s = c.length), n = Math.max(Math.ceil(o / N), s) + 2, i > n && (i = n, e.length = 1), e.reverse(), n = i; n--; ) e.push(0);
        e.reverse();
      } else {
        for (n = c.length, s = g.length, u = n < s, u && (s = n), n = 0; n < s; n++) if (c[n] != g[n]) {
          u = c[n] < g[n];
          break;
        }
        i = 0;
      }
      for (u && (e = c, c = g, g = e, t.s = -t.s), s = c.length, n = g.length - s; n > 0; --n) c[s++] = 0;
      for (n = g.length; n > i; ) {
        if (c[--n] < g[n]) {
          for (A = n; A && c[--A] === 0; ) c[A] = pt - 1;
          --c[A], c[n] += pt;
        }
        c[n] -= g[n];
      }
      for (; c[--s] === 0; ) c.pop();
      for (; c[0] === 0; c.shift()) --r;
      return c[0] ? (t.d = c, t.e = $o(c, r), L ? b(t, o, a) : t) : new h(a === 3 ? -0 : 0);
    };
    y.modulo = y.mod = function(t) {
      var e, r = this, n = r.constructor;
      return t = new n(t), !r.d || !t.s || t.d && !t.d[0] ? new n(NaN) : !t.d || r.d && !r.d[0] ? b(new n(r), n.precision, n.rounding) : (L = false, n.modulo == 9 ? (e = re(r, t.abs(), 0, 3, 1), e.s *= t.s) : e = re(r, t, 0, n.modulo, 1), e = e.times(t), L = true, r.minus(e));
    };
    y.naturalExponential = y.exp = function() {
      return Mu(this);
    };
    y.naturalLogarithm = y.ln = function() {
      return Mr(this);
    };
    y.negated = y.neg = function() {
      var t = new this.constructor(this);
      return t.s = -t.s, b(t);
    };
    y.plus = y.add = function(t) {
      var e, r, n, A, i, s, o, a, c, l, u = this, g = u.constructor;
      if (t = new g(t), !u.d || !t.d) return !u.s || !t.s ? t = new g(NaN) : u.d || (t = new g(t.d || u.s === t.s ? u : NaN)), t;
      if (u.s != t.s) return t.s = -t.s, u.minus(t);
      if (c = u.d, l = t.d, o = g.precision, a = g.rounding, !c[0] || !l[0]) return l[0] || (t = new g(u)), L ? b(t, o, a) : t;
      if (i = ke(u.e / N), n = ke(t.e / N), c = c.slice(), A = i - n, A) {
        for (A < 0 ? (r = c, A = -A, s = l.length) : (r = l, n = i, s = c.length), i = Math.ceil(o / N), s = i > s ? i + 1 : s + 1, A > s && (A = s, r.length = 1), r.reverse(); A--; ) r.push(0);
        r.reverse();
      }
      for (s = c.length, A = l.length, s - A < 0 && (A = s, r = l, l = c, c = r), e = 0; A; ) e = (c[--A] = c[A] + l[A] + e) / pt | 0, c[A] %= pt;
      for (e && (c.unshift(e), ++n), s = c.length; c[--s] == 0; ) c.pop();
      return t.d = c, t.e = $o(c, n), L ? b(t, o, a) : t;
    };
    y.precision = y.sd = function(t) {
      var e, r = this;
      if (t !== void 0 && t !== !!t && t !== 1 && t !== 0) throw Error(Lr + t);
      return r.d ? (e = WC(r.d), t && r.e + 1 > e && (e = r.e + 1)) : e = NaN, e;
    };
    y.round = function() {
      var t = this, e = t.constructor;
      return b(new e(t), t.e + 1, e.rounding);
    };
    y.sine = y.sin = function() {
      var t, e, r = this, n = r.constructor;
      return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + N, n.rounding = 1, r = zT(n, XC(n, r)), n.precision = t, n.rounding = e, b(sr > 2 ? r.neg() : r, t, e, true)) : new n(NaN);
    };
    y.squareRoot = y.sqrt = function() {
      var t, e, r, n, A, i, s = this, o = s.d, a = s.e, c = s.s, l = s.constructor;
      if (c !== 1 || !o || !o[0]) return new l(!c || c < 0 && (!o || o[0]) ? NaN : o ? s : 1 / 0);
      for (L = false, c = Math.sqrt(+s), c == 0 || c == 1 / 0 ? (e = Fe(o), (e.length + a) % 2 == 0 && (e += "0"), c = Math.sqrt(e), a = ke((a + 1) / 2) - (a < 0 || a % 2), c == 1 / 0 ? e = "5e" + a : (e = c.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + a), n = new l(e)) : n = new l(c.toString()), r = (a = l.precision) + 3; ; ) if (i = n, n = i.plus(re(s, i, r + 2, 1)).times(0.5), Fe(i.d).slice(0, r) === (e = Fe(n.d)).slice(0, r)) if (e = e.slice(r - 3, r + 1), e == "9999" || !A && e == "4999") {
        if (!A && (b(i, a + 1, 0), i.times(i).eq(s))) {
          n = i;
          break;
        }
        r += 4, A = 1;
      } else {
        (!+e || !+e.slice(1) && e.charAt(0) == "5") && (b(n, a + 1, 1), t = !n.times(n).eq(s));
        break;
      }
      return L = true, b(n, a, l.rounding, t);
    };
    y.tangent = y.tan = function() {
      var t, e, r = this, n = r.constructor;
      return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = re(r, new n(1).minus(r.times(r)).sqrt(), t + 10, 0), n.precision = t, n.rounding = e, b(sr == 2 || sr == 4 ? r.neg() : r, t, e, true)) : new n(NaN);
    };
    y.times = y.mul = function(t) {
      var e, r, n, A, i, s, o, a, c, l = this, u = l.constructor, g = l.d, E = (t = new u(t)).d;
      if (t.s *= l.s, !g || !g[0] || !E || !E[0]) return new u(!t.s || g && !g[0] && !E || E && !E[0] && !g ? NaN : !g || !E ? t.s / 0 : t.s * 0);
      for (r = ke(l.e / N) + ke(t.e / N), a = g.length, c = E.length, a < c && (i = g, g = E, E = i, s = a, a = c, c = s), i = [], s = a + c, n = s; n--; ) i.push(0);
      for (n = c; --n >= 0; ) {
        for (e = 0, A = a + n; A > n; ) o = i[A] + E[n] * g[A - n - 1] + e, i[A--] = o % pt | 0, e = o / pt | 0;
        i[A] = (i[A] + e) % pt | 0;
      }
      for (; !i[--s]; ) i.pop();
      return e ? ++r : i.shift(), t.d = i, t.e = $o(i, r), L ? b(t, u.precision, u.rounding) : t;
    };
    y.toBinary = function(t, e) {
      return Lu(this, 2, t, e);
    };
    y.toDecimalPlaces = y.toDP = function(t, e) {
      var r = this, n = r.constructor;
      return r = new n(r), t === void 0 ? r : (We(t, 0, vr), e === void 0 ? e = n.rounding : We(e, 0, 8), b(r, t + r.e + 1, e));
    };
    y.toExponential = function(t, e) {
      var r, n = this, A = n.constructor;
      return t === void 0 ? r = Lt(n, true) : (We(t, 0, vr), e === void 0 ? e = A.rounding : We(e, 0, 8), n = b(new A(n), t + 1, e), r = Lt(n, true, t + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
    };
    y.toFixed = function(t, e) {
      var r, n, A = this, i = A.constructor;
      return t === void 0 ? r = Lt(A) : (We(t, 0, vr), e === void 0 ? e = i.rounding : We(e, 0, 8), n = b(new i(A), t + A.e + 1, e), r = Lt(n, false, t + n.e + 1)), A.isNeg() && !A.isZero() ? "-" + r : r;
    };
    y.toFraction = function(t) {
      var e, r, n, A, i, s, o, a, c, l, u, g, E = this, h = E.d, f = E.constructor;
      if (!h) return new f(E);
      if (c = r = new f(1), n = a = new f(0), e = new f(n), i = e.e = WC(h) - E.e - 1, s = i % N, e.d[0] = me(10, s < 0 ? N + s : s), t == null) t = i > 0 ? e : c;
      else {
        if (o = new f(t), !o.isInt() || o.lt(c)) throw Error(Lr + o);
        t = o.gt(e) ? i > 0 ? e : c : o;
      }
      for (L = false, o = new f(Fe(h)), l = f.precision, f.precision = i = h.length * N * 2; u = re(o, e, 0, 1, 1), A = r.plus(u.times(n)), A.cmp(t) != 1; ) r = n, n = A, A = c, c = a.plus(u.times(A)), a = A, A = e, e = o.minus(u.times(A)), o = A;
      return A = re(t.minus(r), n, 0, 1, 1), a = a.plus(A.times(c)), r = r.plus(A.times(n)), a.s = c.s = E.s, g = re(c, n, i, 1).minus(E).abs().cmp(re(a, r, i, 1).minus(E).abs()) < 1 ? [c, n] : [a, r], f.precision = l, L = true, g;
    };
    y.toHexadecimal = y.toHex = function(t, e) {
      return Lu(this, 16, t, e);
    };
    y.toNearest = function(t, e) {
      var r = this, n = r.constructor;
      if (r = new n(r), t == null) {
        if (!r.d) return r;
        t = new n(1), e = n.rounding;
      } else {
        if (t = new n(t), e === void 0 ? e = n.rounding : We(e, 0, 8), !r.d) return t.s ? r : t;
        if (!t.d) return t.s && (t.s = r.s), t;
      }
      return t.d[0] ? (L = false, r = re(r, t, 0, e, 1).times(t), L = true, b(r)) : (t.s = r.s, r = t), r;
    };
    y.toNumber = function() {
      return +this;
    };
    y.toOctal = function(t, e) {
      return Lu(this, 8, t, e);
    };
    y.toPower = y.pow = function(t) {
      var e, r, n, A, i, s, o = this, a = o.constructor, c = +(t = new a(t));
      if (!o.d || !t.d || !o.d[0] || !t.d[0]) return new a(me(+o, c));
      if (o = new a(o), o.eq(1)) return o;
      if (n = a.precision, i = a.rounding, t.eq(1)) return b(o, n, i);
      if (e = ke(t.e / N), e >= t.d.length - 1 && (r = c < 0 ? -c : c) <= ZT) return A = _C(a, o, r, n), t.s < 0 ? new a(1).div(A) : b(A, n, i);
      if (s = o.s, s < 0) {
        if (e < t.d.length - 1) return new a(NaN);
        if ((t.d[e] & 1) == 0 && (s = 1), o.e == 0 && o.d[0] == 1 && o.d.length == 1) return o.s = s, o;
      }
      return r = me(+o, c), e = r == 0 || !isFinite(r) ? ke(c * (Math.log("0." + Fe(o.d)) / Math.LN10 + o.e + 1)) : new a(r + "").e, e > a.maxE + 1 || e < a.minE - 1 ? new a(e > 0 ? s / 0 : 0) : (L = false, a.rounding = o.s = 1, r = Math.min(12, (e + "").length), A = Mu(t.times(Mr(o, n + r)), n), A.d && (A = b(A, n + 5, 1), xi(A.d, n, i) && (e = n + 10, A = b(Mu(t.times(Mr(o, e + r)), e), e + 5, 1), +Fe(A.d).slice(n + 1, n + 15) + 1 == 1e14 && (A = b(A, n + 1, 0)))), A.s = s, L = true, a.rounding = i, b(A, n, i));
    };
    y.toPrecision = function(t, e) {
      var r, n = this, A = n.constructor;
      return t === void 0 ? r = Lt(n, n.e <= A.toExpNeg || n.e >= A.toExpPos) : (We(t, 1, vr), e === void 0 ? e = A.rounding : We(e, 0, 8), n = b(new A(n), t, e), r = Lt(n, t <= n.e || n.e <= A.toExpNeg, t)), n.isNeg() && !n.isZero() ? "-" + r : r;
    };
    y.toSignificantDigits = y.toSD = function(t, e) {
      var r = this, n = r.constructor;
      return t === void 0 ? (t = n.precision, e = n.rounding) : (We(t, 1, vr), e === void 0 ? e = n.rounding : We(e, 0, 8)), b(new n(r), t, e);
    };
    y.toString = function() {
      var t = this, e = t.constructor, r = Lt(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
      return t.isNeg() && !t.isZero() ? "-" + r : r;
    };
    y.truncated = y.trunc = function() {
      return b(new this.constructor(this), this.e + 1, 1);
    };
    y.valueOf = y.toJSON = function() {
      var t = this, e = t.constructor, r = Lt(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
      return t.isNeg() ? "-" + r : r;
    };
    function Fe(t) {
      var e, r, n, A = t.length - 1, i = "", s = t[0];
      if (A > 0) {
        for (i += s, e = 1; e < A; e++) n = t[e] + "", r = N - n.length, r && (i += kr(r)), i += n;
        s = t[e], n = s + "", r = N - n.length, r && (i += kr(r));
      } else if (s === 0) return "0";
      for (; s % 10 === 0; ) s /= 10;
      return i + s;
    }
    function We(t, e, r) {
      if (t !== ~~t || t < e || t > r) throw Error(Lr + t);
    }
    function xi(t, e, r, n) {
      var A, i, s, o;
      for (i = t[0]; i >= 10; i /= 10) --e;
      return --e < 0 ? (e += N, A = 0) : (A = Math.ceil((e + 1) / N), e %= N), i = me(10, N - e), o = t[A] % i | 0, n == null ? e < 3 ? (e == 0 ? o = o / 100 | 0 : e == 1 && (o = o / 10 | 0), s = r < 4 && o == 99999 || r > 3 && o == 49999 || o == 5e4 || o == 0) : s = (r < 4 && o + 1 == i || r > 3 && o + 1 == i / 2) && (t[A + 1] / i / 100 | 0) == me(10, e - 2) - 1 || (o == i / 2 || o == 0) && (t[A + 1] / i / 100 | 0) == 0 : e < 4 ? (e == 0 ? o = o / 1e3 | 0 : e == 1 ? o = o / 100 | 0 : e == 2 && (o = o / 10 | 0), s = (n || r < 4) && o == 9999 || !n && r > 3 && o == 4999) : s = ((n || r < 4) && o + 1 == i || !n && r > 3 && o + 1 == i / 2) && (t[A + 1] / i / 1e3 | 0) == me(10, e - 3) - 1, s;
    }
    function Wo(t, e, r) {
      for (var n, A = [0], i, s = 0, o = t.length; s < o; ) {
        for (i = A.length; i--; ) A[i] *= e;
        for (A[0] += xu.indexOf(t.charAt(s++)), n = 0; n < A.length; n++) A[n] > r - 1 && (A[n + 1] === void 0 && (A[n + 1] = 0), A[n + 1] += A[n] / r | 0, A[n] %= r);
      }
      return A.reverse();
    }
    function KT(t, e) {
      var r, n, A;
      if (e.isZero()) return e;
      n = e.d.length, n < 32 ? (r = Math.ceil(n / 3), A = (1 / zo(4, r)).toString()) : (r = 16, A = "2.3283064365386962890625e-10"), t.precision += r, e = iA(t, 1, e.times(A), new t(1));
      for (var i = r; i--; ) {
        var s = e.times(e);
        e = s.times(s).minus(s).times(8).plus(1);
      }
      return t.precision -= r, e;
    }
    var re = /* @__PURE__ */ (function() {
      function t(n, A, i) {
        var s, o = 0, a = n.length;
        for (n = n.slice(); a--; ) s = n[a] * A + o, n[a] = s % i | 0, o = s / i | 0;
        return o && n.unshift(o), n;
      }
      function e(n, A, i, s) {
        var o, a;
        if (i != s) a = i > s ? 1 : -1;
        else for (o = a = 0; o < i; o++) if (n[o] != A[o]) {
          a = n[o] > A[o] ? 1 : -1;
          break;
        }
        return a;
      }
      function r(n, A, i, s) {
        for (var o = 0; i--; ) n[i] -= o, o = n[i] < A[i] ? 1 : 0, n[i] = o * s + n[i] - A[i];
        for (; !n[0] && n.length > 1; ) n.shift();
      }
      return function(n, A, i, s, o, a) {
        var c, l, u, g, E, h, f, p, Q, I, B, w, D, v, K, W, ae, xe, te, Rr, rn = n.constructor, Se = n.s == A.s ? 1 : -1, he = n.d, ee = A.d;
        if (!he || !he[0] || !ee || !ee[0]) return new rn(!n.s || !A.s || (he ? ee && he[0] == ee[0] : !ee) ? NaN : he && he[0] == 0 || !ee ? Se * 0 : Se / 0);
        for (a ? (E = 1, l = n.e - A.e) : (a = pt, E = N, l = ke(n.e / E) - ke(A.e / E)), te = ee.length, ae = he.length, Q = new rn(Se), I = Q.d = [], u = 0; ee[u] == (he[u] || 0); u++) ;
        if (ee[u] > (he[u] || 0) && l--, i == null ? (v = i = rn.precision, s = rn.rounding) : o ? v = i + (n.e - A.e) + 1 : v = i, v < 0) I.push(1), h = true;
        else {
          if (v = v / E + 2 | 0, u = 0, te == 1) {
            for (g = 0, ee = ee[0], v++; (u < ae || g) && v--; u++) K = g * a + (he[u] || 0), I[u] = K / ee | 0, g = K % ee | 0;
            h = g || u < ae;
          } else {
            for (g = a / (ee[0] + 1) | 0, g > 1 && (ee = t(ee, g, a), he = t(he, g, a), te = ee.length, ae = he.length), W = te, B = he.slice(0, te), w = B.length; w < te; ) B[w++] = 0;
            Rr = ee.slice(), Rr.unshift(0), xe = ee[0], ee[1] >= a / 2 && ++xe;
            do
              g = 0, c = e(ee, B, te, w), c < 0 ? (D = B[0], te != w && (D = D * a + (B[1] || 0)), g = D / xe | 0, g > 1 ? (g >= a && (g = a - 1), f = t(ee, g, a), p = f.length, w = B.length, c = e(f, B, p, w), c == 1 && (g--, r(f, te < p ? Rr : ee, p, a))) : (g == 0 && (c = g = 1), f = ee.slice()), p = f.length, p < w && f.unshift(0), r(B, f, w, a), c == -1 && (w = B.length, c = e(ee, B, te, w), c < 1 && (g++, r(B, te < w ? Rr : ee, w, a))), w = B.length) : c === 0 && (g++, B = [0]), I[u++] = g, c && B[0] ? B[w++] = he[W] || 0 : (B = [he[W]], w = 1);
            while ((W++ < ae || B[0] !== void 0) && v--);
            h = B[0] !== void 0;
          }
          I[0] || I.shift();
        }
        if (E == 1) Q.e = l, OC = h;
        else {
          for (u = 1, g = I[0]; g >= 10; g /= 10) u++;
          Q.e = u + l * E - 1, b(Q, o ? i + Q.e + 1 : i, s, h);
        }
        return Q;
      };
    })();
    function b(t, e, r, n) {
      var A, i, s, o, a, c, l, u, g, E = t.constructor;
      e: if (e != null) {
        if (u = t.d, !u) return t;
        for (A = 1, o = u[0]; o >= 10; o /= 10) A++;
        if (i = e - A, i < 0) i += N, s = e, l = u[g = 0], a = l / me(10, A - s - 1) % 10 | 0;
        else if (g = Math.ceil((i + 1) / N), o = u.length, g >= o) if (n) {
          for (; o++ <= g; ) u.push(0);
          l = a = 0, A = 1, i %= N, s = i - N + 1;
        } else break e;
        else {
          for (l = o = u[g], A = 1; o >= 10; o /= 10) A++;
          i %= N, s = i - N + A, a = s < 0 ? 0 : l / me(10, A - s - 1) % 10 | 0;
        }
        if (n = n || e < 0 || u[g + 1] !== void 0 || (s < 0 ? l : l % me(10, A - s - 1)), c = r < 4 ? (a || n) && (r == 0 || r == (t.s < 0 ? 3 : 2)) : a > 5 || a == 5 && (r == 4 || n || r == 6 && (i > 0 ? s > 0 ? l / me(10, A - s) : 0 : u[g - 1]) % 10 & 1 || r == (t.s < 0 ? 8 : 7)), e < 1 || !u[0]) return u.length = 0, c ? (e -= t.e + 1, u[0] = me(10, (N - e % N) % N), t.e = -e || 0) : u[0] = t.e = 0, t;
        if (i == 0 ? (u.length = g, o = 1, g--) : (u.length = g + 1, o = me(10, N - i), u[g] = s > 0 ? (l / me(10, A - s) % me(10, s) | 0) * o : 0), c) for (; ; ) if (g == 0) {
          for (i = 1, s = u[0]; s >= 10; s /= 10) i++;
          for (s = u[0] += o, o = 1; s >= 10; s /= 10) o++;
          i != o && (t.e++, u[0] == pt && (u[0] = 1));
          break;
        } else {
          if (u[g] += o, u[g] != pt) break;
          u[g--] = 0, o = 1;
        }
        for (i = u.length; u[--i] === 0; ) u.pop();
      }
      return L && (t.e > E.maxE ? (t.d = null, t.e = NaN) : t.e < E.minE && (t.e = 0, t.d = [0])), t;
    }
    function Lt(t, e, r) {
      if (!t.isFinite()) return ZC(t);
      var n, A = t.e, i = Fe(t.d), s = i.length;
      return e ? (r && (n = r - s) > 0 ? i = i.charAt(0) + "." + i.slice(1) + kr(n) : s > 1 && (i = i.charAt(0) + "." + i.slice(1)), i = i + (t.e < 0 ? "e" : "e+") + t.e) : A < 0 ? (i = "0." + kr(-A - 1) + i, r && (n = r - s) > 0 && (i += kr(n))) : A >= s ? (i += kr(A + 1 - s), r && (n = r - A - 1) > 0 && (i = i + "." + kr(n))) : ((n = A + 1) < s && (i = i.slice(0, n) + "." + i.slice(n)), r && (n = r - s) > 0 && (A + 1 === s && (i += "."), i += kr(n))), i;
    }
    function $o(t, e) {
      var r = t[0];
      for (e *= N; r >= 10; r /= 10) e++;
      return e;
    }
    function Xo(t, e, r) {
      if (e > XT) throw L = true, r && (t.precision = r), Error(VC);
      return b(new t(jo), e, 1, true);
    }
    function Mt(t, e, r) {
      if (e > ku) throw Error(VC);
      return b(new t(Zo), e, r, true);
    }
    function WC(t) {
      var e = t.length - 1, r = e * N + 1;
      if (e = t[e], e) {
        for (; e % 10 == 0; e /= 10) r--;
        for (e = t[0]; e >= 10; e /= 10) r++;
      }
      return r;
    }
    function kr(t) {
      for (var e = ""; t--; ) e += "0";
      return e;
    }
    function _C(t, e, r, n) {
      var A, i = new t(1), s = Math.ceil(n / N + 4);
      for (L = false; ; ) {
        if (r % 2 && (i = i.times(e), YC(i.d, s) && (A = true)), r = ke(r / 2), r === 0) {
          r = i.d.length - 1, A && i.d[r] === 0 && ++i.d[r];
          break;
        }
        e = e.times(e), YC(e.d, s);
      }
      return L = true, i;
    }
    function PC(t) {
      return t.d[t.d.length - 1] & 1;
    }
    function jC(t, e, r) {
      for (var n, A, i = new t(e[0]), s = 0; ++s < e.length; ) {
        if (A = new t(e[s]), !A.s) {
          i = A;
          break;
        }
        n = i.cmp(A), (n === r || n === 0 && i.s === r) && (i = A);
      }
      return i;
    }
    function Mu(t, e) {
      var r, n, A, i, s, o, a, c = 0, l = 0, u = 0, g = t.constructor, E = g.rounding, h = g.precision;
      if (!t.d || !t.d[0] || t.e > 17) return new g(t.d ? t.d[0] ? t.s < 0 ? 0 : 1 / 0 : 1 : t.s ? t.s < 0 ? 0 : t : NaN);
      for (e == null ? (L = false, a = h) : a = e, o = new g(0.03125); t.e > -2; ) t = t.times(o), u += 5;
      for (n = Math.log(me(2, u)) / Math.LN10 * 2 + 5 | 0, a += n, r = i = s = new g(1), g.precision = a; ; ) {
        if (i = b(i.times(t), a, 1), r = r.times(++l), o = s.plus(re(i, r, a, 1)), Fe(o.d).slice(0, a) === Fe(s.d).slice(0, a)) {
          for (A = u; A--; ) s = b(s.times(s), a, 1);
          if (e == null) if (c < 3 && xi(s.d, a - n, E, c)) g.precision = a += 10, r = i = o = new g(1), l = 0, c++;
          else return b(s, g.precision = h, E, L = true);
          else return g.precision = h, s;
        }
        s = o;
      }
    }
    function Mr(t, e) {
      var r, n, A, i, s, o, a, c, l, u, g, E = 1, h = 10, f = t, p = f.d, Q = f.constructor, I = Q.rounding, B = Q.precision;
      if (f.s < 0 || !p || !p[0] || !f.e && p[0] == 1 && p.length == 1) return new Q(p && !p[0] ? -1 / 0 : f.s != 1 ? NaN : p ? 0 : f);
      if (e == null ? (L = false, l = B) : l = e, Q.precision = l += h, r = Fe(p), n = r.charAt(0), Math.abs(i = f.e) < 15e14) {
        for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; ) f = f.times(t), r = Fe(f.d), n = r.charAt(0), E++;
        i = f.e, n > 1 ? (f = new Q("0." + r), i++) : f = new Q(n + "." + r.slice(1));
      } else return c = Xo(Q, l + 2, B).times(i + ""), f = Mr(new Q(n + "." + r.slice(1)), l - h).plus(c), Q.precision = B, e == null ? b(f, B, I, L = true) : f;
      for (u = f, a = s = f = re(f.minus(1), f.plus(1), l, 1), g = b(f.times(f), l, 1), A = 3; ; ) {
        if (s = b(s.times(g), l, 1), c = a.plus(re(s, new Q(A), l, 1)), Fe(c.d).slice(0, l) === Fe(a.d).slice(0, l)) if (a = a.times(2), i !== 0 && (a = a.plus(Xo(Q, l + 2, B).times(i + ""))), a = re(a, new Q(E), l, 1), e == null) if (xi(a.d, l - h, I, o)) Q.precision = l += h, c = s = f = re(u.minus(1), u.plus(1), l, 1), g = b(f.times(f), l, 1), A = o = 1;
        else return b(a, Q.precision = B, I, L = true);
        else return Q.precision = B, a;
        a = c, A += 2;
      }
    }
    function ZC(t) {
      return String(t.s * t.s / 0);
    }
    function _o(t, e) {
      var r, n, A;
      for ((r = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (n = e.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +e.slice(n + 1), e = e.substring(0, n)) : r < 0 && (r = e.length), n = 0; e.charCodeAt(n) === 48; n++) ;
      for (A = e.length; e.charCodeAt(A - 1) === 48; --A) ;
      if (e = e.slice(n, A), e) {
        if (A -= n, t.e = r = r - n - 1, t.d = [], n = (r + 1) % N, r < 0 && (n += N), n < A) {
          for (n && t.d.push(+e.slice(0, n)), A -= N; n < A; ) t.d.push(+e.slice(n, n += N));
          e = e.slice(n), n = N - e.length;
        } else n -= A;
        for (; n--; ) e += "0";
        t.d.push(+e), L && (t.e > t.constructor.maxE ? (t.d = null, t.e = NaN) : t.e < t.constructor.minE && (t.e = 0, t.d = [0]));
      } else t.e = 0, t.d = [0];
      return t;
    }
    function $T(t, e) {
      var r, n, A, i, s, o, a, c, l;
      if (e.indexOf("_") > -1) {
        if (e = e.replace(/(\d)_(?=\d)/g, "$1"), JC.test(e)) return _o(t, e);
      } else if (e === "Infinity" || e === "NaN") return +e || (t.s = NaN), t.e = NaN, t.d = null, t;
      if (_T.test(e)) r = 16, e = e.toLowerCase();
      else if (WT.test(e)) r = 2;
      else if (jT.test(e)) r = 8;
      else throw Error(Lr + e);
      for (i = e.search(/p/i), i > 0 ? (a = +e.slice(i + 1), e = e.substring(2, i)) : e = e.slice(2), i = e.indexOf("."), s = i >= 0, n = t.constructor, s && (e = e.replace(".", ""), o = e.length, i = o - i, A = _C(n, new n(r), i, i * 2)), c = Wo(e, r, pt), l = c.length - 1, i = l; c[i] === 0; --i) c.pop();
      return i < 0 ? new n(t.s * 0) : (t.e = $o(c, l), t.d = c, L = false, s && (t = re(t, A, o * 4)), a && (t = t.times(Math.abs(a) < 54 ? me(2, a) : or.pow(2, a))), L = true, t);
    }
    function zT(t, e) {
      var r, n = e.d.length;
      if (n < 3) return e.isZero() ? e : iA(t, 2, e, e);
      r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, e = e.times(1 / zo(5, r)), e = iA(t, 2, e, e);
      for (var A, i = new t(5), s = new t(16), o = new t(20); r--; ) A = e.times(e), e = e.times(i.plus(A.times(s.times(A).minus(o))));
      return e;
    }
    function iA(t, e, r, n, A) {
      var i, s, o, a, c = 1, l = t.precision, u = Math.ceil(l / N);
      for (L = false, a = r.times(r), o = new t(n); ; ) {
        if (s = re(o.times(a), new t(e++ * e++), l, 1), o = A ? n.plus(s) : n.minus(s), n = re(s.times(a), new t(e++ * e++), l, 1), s = o.plus(n), s.d[u] !== void 0) {
          for (i = u; s.d[i] === o.d[i] && i--; ) ;
          if (i == -1) break;
        }
        i = o, o = n, n = s, s = i, c++;
      }
      return L = true, s.d.length = u + 1, s;
    }
    function zo(t, e) {
      for (var r = t; --e; ) r *= t;
      return r;
    }
    function XC(t, e) {
      var r, n = e.s < 0, A = Mt(t, t.precision, 1), i = A.times(0.5);
      if (e = e.abs(), e.lte(i)) return sr = n ? 4 : 1, e;
      if (r = e.divToInt(A), r.isZero()) sr = n ? 3 : 2;
      else {
        if (e = e.minus(r.times(A)), e.lte(i)) return sr = PC(r) ? n ? 2 : 3 : n ? 4 : 1, e;
        sr = PC(r) ? n ? 1 : 4 : n ? 3 : 2;
      }
      return e.minus(A).abs();
    }
    function Lu(t, e, r, n) {
      var A, i, s, o, a, c, l, u, g, E = t.constructor, h = r !== void 0;
      if (h ? (We(r, 1, vr), n === void 0 ? n = E.rounding : We(n, 0, 8)) : (r = E.precision, n = E.rounding), !t.isFinite()) l = ZC(t);
      else {
        for (l = Lt(t), s = l.indexOf("."), h ? (A = 2, e == 16 ? r = r * 4 - 3 : e == 8 && (r = r * 3 - 2)) : A = e, s >= 0 && (l = l.replace(".", ""), g = new E(1), g.e = l.length - s, g.d = Wo(Lt(g), 10, A), g.e = g.d.length), u = Wo(l, 10, A), i = a = u.length; u[--a] == 0; ) u.pop();
        if (!u[0]) l = h ? "0p+0" : "0";
        else {
          if (s < 0 ? i-- : (t = new E(t), t.d = u, t.e = i, t = re(t, g, r, n, 0, A), u = t.d, i = t.e, c = OC), s = u[r], o = A / 2, c = c || u[r + 1] !== void 0, c = n < 4 ? (s !== void 0 || c) && (n === 0 || n === (t.s < 0 ? 3 : 2)) : s > o || s === o && (n === 4 || c || n === 6 && u[r - 1] & 1 || n === (t.s < 0 ? 8 : 7)), u.length = r, c) for (; ++u[--r] > A - 1; ) u[r] = 0, r || (++i, u.unshift(1));
          for (a = u.length; !u[a - 1]; --a) ;
          for (s = 0, l = ""; s < a; s++) l += xu.charAt(u[s]);
          if (h) {
            if (a > 1) if (e == 16 || e == 8) {
              for (s = e == 16 ? 4 : 3, --a; a % s; a++) l += "0";
              for (u = Wo(l, A, e), a = u.length; !u[a - 1]; --a) ;
              for (s = 1, l = "1."; s < a; s++) l += xu.charAt(u[s]);
            } else l = l.charAt(0) + "." + l.slice(1);
            l = l + (i < 0 ? "p" : "p+") + i;
          } else if (i < 0) {
            for (; ++i; ) l = "0" + l;
            l = "0." + l;
          } else if (++i > a) for (i -= a; i--; ) l += "0";
          else i < a && (l = l.slice(0, i) + "." + l.slice(i));
        }
        l = (e == 16 ? "0x" : e == 2 ? "0b" : e == 8 ? "0o" : "") + l;
      }
      return t.s < 0 ? "-" + l : l;
    }
    function YC(t, e) {
      if (t.length > e) return t.length = e, true;
    }
    function ex(t) {
      return new this(t).abs();
    }
    function tx(t) {
      return new this(t).acos();
    }
    function rx(t) {
      return new this(t).acosh();
    }
    function nx(t, e) {
      return new this(t).plus(e);
    }
    function Ax(t) {
      return new this(t).asin();
    }
    function ix(t) {
      return new this(t).asinh();
    }
    function sx(t) {
      return new this(t).atan();
    }
    function ox(t) {
      return new this(t).atanh();
    }
    function ax(t, e) {
      t = new this(t), e = new this(e);
      var r, n = this.precision, A = this.rounding, i = n + 4;
      return !t.s || !e.s ? r = new this(NaN) : !t.d && !e.d ? (r = Mt(this, i, 1).times(e.s > 0 ? 0.25 : 0.75), r.s = t.s) : !e.d || t.isZero() ? (r = e.s < 0 ? Mt(this, n, A) : new this(0), r.s = t.s) : !t.d || e.isZero() ? (r = Mt(this, i, 1).times(0.5), r.s = t.s) : e.s < 0 ? (this.precision = i, this.rounding = 1, r = this.atan(re(t, e, i, 1)), e = Mt(this, i, 1), this.precision = n, this.rounding = A, r = t.s < 0 ? r.minus(e) : r.plus(e)) : r = this.atan(re(t, e, i, 1)), r;
    }
    function cx(t) {
      return new this(t).cbrt();
    }
    function lx(t) {
      return b(t = new this(t), t.e + 1, 2);
    }
    function ux(t, e, r) {
      return new this(t).clamp(e, r);
    }
    function gx(t) {
      if (!t || typeof t != "object") throw Error(Ko + "Object expected");
      var e, r, n, A = t.defaults === true, i = ["precision", 1, vr, "rounding", 0, 8, "toExpNeg", -AA, 0, "toExpPos", 0, AA, "maxE", 0, AA, "minE", -AA, 0, "modulo", 0, 9];
      for (e = 0; e < i.length; e += 3) if (r = i[e], A && (this[r] = Uu[r]), (n = t[r]) !== void 0) if (ke(n) === n && n >= i[e + 1] && n <= i[e + 2]) this[r] = n;
      else throw Error(Lr + r + ": " + n);
      if (r = "crypto", A && (this[r] = Uu[r]), (n = t[r]) !== void 0) if (n === true || n === false || n === 0 || n === 1) if (n) if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) this[r] = true;
      else throw Error(HC);
      else this[r] = false;
      else throw Error(Lr + r + ": " + n);
      return this;
    }
    function Ex(t) {
      return new this(t).cos();
    }
    function dx(t) {
      return new this(t).cosh();
    }
    function KC(t) {
      var e, r, n;
      function A(i) {
        var s, o, a, c = this;
        if (!(c instanceof A)) return new A(i);
        if (c.constructor = A, GC(i)) {
          c.s = i.s, L ? !i.d || i.e > A.maxE ? (c.e = NaN, c.d = null) : i.e < A.minE ? (c.e = 0, c.d = [0]) : (c.e = i.e, c.d = i.d.slice()) : (c.e = i.e, c.d = i.d ? i.d.slice() : i.d);
          return;
        }
        if (a = typeof i, a === "number") {
          if (i === 0) {
            c.s = 1 / i < 0 ? -1 : 1, c.e = 0, c.d = [0];
            return;
          }
          if (i < 0 ? (i = -i, c.s = -1) : c.s = 1, i === ~~i && i < 1e7) {
            for (s = 0, o = i; o >= 10; o /= 10) s++;
            L ? s > A.maxE ? (c.e = NaN, c.d = null) : s < A.minE ? (c.e = 0, c.d = [0]) : (c.e = s, c.d = [i]) : (c.e = s, c.d = [i]);
            return;
          }
          if (i * 0 !== 0) {
            i || (c.s = NaN), c.e = NaN, c.d = null;
            return;
          }
          return _o(c, i.toString());
        }
        if (a === "string") return (o = i.charCodeAt(0)) === 45 ? (i = i.slice(1), c.s = -1) : (o === 43 && (i = i.slice(1)), c.s = 1), JC.test(i) ? _o(c, i) : $T(c, i);
        if (a === "bigint") return i < 0 ? (i = -i, c.s = -1) : c.s = 1, _o(c, i.toString());
        throw Error(Lr + i);
      }
      if (A.prototype = y, A.ROUND_UP = 0, A.ROUND_DOWN = 1, A.ROUND_CEIL = 2, A.ROUND_FLOOR = 3, A.ROUND_HALF_UP = 4, A.ROUND_HALF_DOWN = 5, A.ROUND_HALF_EVEN = 6, A.ROUND_HALF_CEIL = 7, A.ROUND_HALF_FLOOR = 8, A.EUCLID = 9, A.config = A.set = gx, A.clone = KC, A.isDecimal = GC, A.abs = ex, A.acos = tx, A.acosh = rx, A.add = nx, A.asin = Ax, A.asinh = ix, A.atan = sx, A.atanh = ox, A.atan2 = ax, A.cbrt = cx, A.ceil = lx, A.clamp = ux, A.cos = Ex, A.cosh = dx, A.div = hx, A.exp = fx, A.floor = Qx, A.hypot = Cx, A.ln = Ix, A.log = px, A.log10 = mx, A.log2 = Bx, A.max = yx, A.min = wx, A.mod = Dx, A.mul = Rx, A.pow = Sx, A.random = bx, A.round = Nx, A.sign = Fx, A.sin = Tx, A.sinh = xx, A.sqrt = Ux, A.sub = kx, A.sum = Mx, A.tan = Lx, A.tanh = vx, A.trunc = Px, t === void 0 && (t = {}), t && t.defaults !== true) for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], e = 0; e < n.length; ) t.hasOwnProperty(r = n[e++]) || (t[r] = this[r]);
      return A.config(t), A;
    }
    function hx(t, e) {
      return new this(t).div(e);
    }
    function fx(t) {
      return new this(t).exp();
    }
    function Qx(t) {
      return b(t = new this(t), t.e + 1, 3);
    }
    function Cx() {
      var t, e, r = new this(0);
      for (L = false, t = 0; t < arguments.length; ) if (e = new this(arguments[t++]), e.d) r.d && (r = r.plus(e.times(e)));
      else {
        if (e.s) return L = true, new this(1 / 0);
        r = e;
      }
      return L = true, r.sqrt();
    }
    function GC(t) {
      return t instanceof or || t && t.toStringTag === qC || false;
    }
    function Ix(t) {
      return new this(t).ln();
    }
    function px(t, e) {
      return new this(t).log(e);
    }
    function Bx(t) {
      return new this(t).log(2);
    }
    function mx(t) {
      return new this(t).log(10);
    }
    function yx() {
      return jC(this, arguments, -1);
    }
    function wx() {
      return jC(this, arguments, 1);
    }
    function Dx(t, e) {
      return new this(t).mod(e);
    }
    function Rx(t, e) {
      return new this(t).mul(e);
    }
    function Sx(t, e) {
      return new this(t).pow(e);
    }
    function bx(t) {
      var e, r, n, A, i = 0, s = new this(1), o = [];
      if (t === void 0 ? t = this.precision : We(t, 1, vr), n = Math.ceil(t / N), this.crypto) if (crypto.getRandomValues) for (e = crypto.getRandomValues(new Uint32Array(n)); i < n; ) A = e[i], A >= 429e7 ? e[i] = crypto.getRandomValues(new Uint32Array(1))[0] : o[i++] = A % 1e7;
      else if (crypto.randomBytes) {
        for (e = crypto.randomBytes(n *= 4); i < n; ) A = e[i] + (e[i + 1] << 8) + (e[i + 2] << 16) + ((e[i + 3] & 127) << 24), A >= 214e7 ? crypto.randomBytes(4).copy(e, i) : (o.push(A % 1e7), i += 4);
        i = n / 4;
      } else throw Error(HC);
      else for (; i < n; ) o[i++] = Math.random() * 1e7 | 0;
      for (n = o[--i], t %= N, n && t && (A = me(10, N - t), o[i] = (n / A | 0) * A); o[i] === 0; i--) o.pop();
      if (i < 0) r = 0, o = [0];
      else {
        for (r = -1; o[0] === 0; r -= N) o.shift();
        for (n = 1, A = o[0]; A >= 10; A /= 10) n++;
        n < N && (r -= N - n);
      }
      return s.e = r, s.d = o, s;
    }
    function Nx(t) {
      return b(t = new this(t), t.e + 1, this.rounding);
    }
    function Fx(t) {
      return t = new this(t), t.d ? t.d[0] ? t.s : 0 * t.s : t.s || NaN;
    }
    function Tx(t) {
      return new this(t).sin();
    }
    function xx(t) {
      return new this(t).sinh();
    }
    function Ux(t) {
      return new this(t).sqrt();
    }
    function kx(t, e) {
      return new this(t).sub(e);
    }
    function Mx() {
      var t = 0, e = arguments, r = new this(e[t]);
      for (L = false; r.s && ++t < e.length; ) r = r.plus(e[t]);
      return L = true, b(r, this.precision, this.rounding);
    }
    function Lx(t) {
      return new this(t).tan();
    }
    function vx(t) {
      return new this(t).tanh();
    }
    function Px(t) {
      return b(t = new this(t), t.e + 1, 1);
    }
    y[/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")] = y.toString;
    y[Symbol.toStringTag] = "Decimal";
    var or = y.constructor = KC(Uu);
    jo = new or(jo);
    Zo = new or(Zo);
    var ar = or;
    function sA(t) {
      return or.isDecimal(t) ? true : t !== null && typeof t == "object" && typeof t.s == "number" && typeof t.e == "number" && typeof t.toFixed == "function" && Array.isArray(t.d);
    }
    var Ui = {};
    Jn(Ui, { ModelAction: () => oA, datamodelEnumToSchemaEnum: () => Yx });
    function Yx(t) {
      return { name: t.name, values: t.values.map((e) => e.name) };
    }
    var oA = ((B) => (B.findUnique = "findUnique", B.findUniqueOrThrow = "findUniqueOrThrow", B.findFirst = "findFirst", B.findFirstOrThrow = "findFirstOrThrow", B.findMany = "findMany", B.create = "create", B.createMany = "createMany", B.createManyAndReturn = "createManyAndReturn", B.update = "update", B.updateMany = "updateMany", B.updateManyAndReturn = "updateManyAndReturn", B.upsert = "upsert", B.delete = "delete", B.deleteMany = "deleteMany", B.groupBy = "groupBy", B.count = "count", B.aggregate = "aggregate", B.findRaw = "findRaw", B.aggregateRaw = "aggregateRaw", B))(oA || {});
    var rI = G(Iu());
    var tI = G(require("node:fs"));
    var $C = { keyword: nr, entity: nr, value: (t) => be(An(t)), punctuation: An, directive: nr, function: nr, variable: (t) => be(An(t)), string: (t) => be(Sr(t)), boolean: rr, number: nr, comment: hi };
    var Gx = (t) => t;
    var ea = {};
    var Ox = 0;
    var P = { manual: ea.Prism && ea.Prism.manual, disableWorkerMessageHandler: ea.Prism && ea.Prism.disableWorkerMessageHandler, util: { encode: function(t) {
      if (t instanceof Bt) {
        let e = t;
        return new Bt(e.type, P.util.encode(e.content), e.alias);
      } else return Array.isArray(t) ? t.map(P.util.encode) : t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
    }, type: function(t) {
      return Object.prototype.toString.call(t).slice(8, -1);
    }, objId: function(t) {
      return t.__id || Object.defineProperty(t, "__id", { value: ++Ox }), t.__id;
    }, clone: function t(e, r) {
      let n, A, i = P.util.type(e);
      switch (r = r || {}, i) {
        case "Object":
          if (A = P.util.objId(e), r[A]) return r[A];
          n = {}, r[A] = n;
          for (let s in e) e.hasOwnProperty(s) && (n[s] = t(e[s], r));
          return n;
        case "Array":
          return A = P.util.objId(e), r[A] ? r[A] : (n = [], r[A] = n, e.forEach(function(s, o) {
            n[o] = t(s, r);
          }), n);
        default:
          return e;
      }
    } }, languages: { extend: function(t, e) {
      let r = P.util.clone(P.languages[t]);
      for (let n in e) r[n] = e[n];
      return r;
    }, insertBefore: function(t, e, r, n) {
      n = n || P.languages;
      let A = n[t], i = {};
      for (let o in A) if (A.hasOwnProperty(o)) {
        if (o == e) for (let a in r) r.hasOwnProperty(a) && (i[a] = r[a]);
        r.hasOwnProperty(o) || (i[o] = A[o]);
      }
      let s = n[t];
      return n[t] = i, P.languages.DFS(P.languages, function(o, a) {
        a === s && o != t && (this[o] = i);
      }), i;
    }, DFS: function t(e, r, n, A) {
      A = A || {};
      let i = P.util.objId;
      for (let s in e) if (e.hasOwnProperty(s)) {
        r.call(e, s, e[s], n || s);
        let o = e[s], a = P.util.type(o);
        a === "Object" && !A[i(o)] ? (A[i(o)] = true, t(o, r, null, A)) : a === "Array" && !A[i(o)] && (A[i(o)] = true, t(o, r, s, A));
      }
    } }, plugins: {}, highlight: function(t, e, r) {
      let n = { code: t, grammar: e, language: r };
      return P.hooks.run("before-tokenize", n), n.tokens = P.tokenize(n.code, n.grammar), P.hooks.run("after-tokenize", n), Bt.stringify(P.util.encode(n.tokens), n.language);
    }, matchGrammar: function(t, e, r, n, A, i, s) {
      for (let f in r) {
        if (!r.hasOwnProperty(f) || !r[f]) continue;
        if (f == s) return;
        let p = r[f];
        p = P.util.type(p) === "Array" ? p : [p];
        for (let Q = 0; Q < p.length; ++Q) {
          let I = p[Q], B = I.inside, w = !!I.lookbehind, D = !!I.greedy, v = 0, K = I.alias;
          if (D && !I.pattern.global) {
            let W = I.pattern.toString().match(/[imuy]*$/)[0];
            I.pattern = RegExp(I.pattern.source, W + "g");
          }
          I = I.pattern || I;
          for (let W = n, ae = A; W < e.length; ae += e[W].length, ++W) {
            let xe = e[W];
            if (e.length > t.length) return;
            if (xe instanceof Bt) continue;
            if (D && W != e.length - 1) {
              I.lastIndex = ae;
              var u = I.exec(t);
              if (!u) break;
              var l = u.index + (w ? u[1].length : 0), g = u.index + u[0].length, o = W, a = ae;
              for (let ee = e.length; o < ee && (a < g || !e[o].type && !e[o - 1].greedy); ++o) a += e[o].length, l >= a && (++W, ae = a);
              if (e[W] instanceof Bt) continue;
              c = o - W, xe = t.slice(ae, a), u.index -= ae;
            } else {
              I.lastIndex = 0;
              var u = I.exec(xe), c = 1;
            }
            if (!u) {
              if (i) break;
              continue;
            }
            w && (v = u[1] ? u[1].length : 0);
            var l = u.index + v, u = u[0].slice(v), g = l + u.length, E = xe.slice(0, l), h = xe.slice(g);
            let te = [W, c];
            E && (++W, ae += E.length, te.push(E));
            let Rr = new Bt(f, B ? P.tokenize(u, B) : u, K, u, D);
            if (te.push(Rr), h && te.push(h), Array.prototype.splice.apply(e, te), c != 1 && P.matchGrammar(t, e, r, W, ae, true, f), i) break;
          }
        }
      }
    }, tokenize: function(t, e) {
      let r = [t], n = e.rest;
      if (n) {
        for (let A in n) e[A] = n[A];
        delete e.rest;
      }
      return P.matchGrammar(t, r, e, 0, 0, false), r;
    }, hooks: { all: {}, add: function(t, e) {
      let r = P.hooks.all;
      r[t] = r[t] || [], r[t].push(e);
    }, run: function(t, e) {
      let r = P.hooks.all[t];
      if (!(!r || !r.length)) for (var n = 0, A; A = r[n++]; ) A(e);
    } }, Token: Bt };
    P.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
    P.languages.javascript = P.languages.extend("clike", { "class-name": [P.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
    P.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
    P.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: P.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: P.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: P.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: P.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
    P.languages.markup && P.languages.markup.tag.addInlined("script", "javascript");
    P.languages.js = P.languages.javascript;
    P.languages.typescript = P.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
    P.languages.ts = P.languages.typescript;
    function Bt(t, e, r, n, A) {
      this.type = t, this.content = e, this.alias = r, this.length = (n || "").length | 0, this.greedy = !!A;
    }
    Bt.stringify = function(t, e) {
      return typeof t == "string" ? t : Array.isArray(t) ? t.map(function(r) {
        return Bt.stringify(r, e);
      }).join("") : Vx(t.type)(t.content);
    };
    function Vx(t) {
      return $C[t] || Gx;
    }
    function zC(t) {
      return Hx(t, P.languages.javascript);
    }
    function Hx(t, e) {
      return P.tokenize(t, e).map((n) => Bt.stringify(n)).join("");
    }
    function eI(t) {
      return Qu(t);
    }
    var ta = class t {
      firstLineNumber;
      lines;
      static read(e) {
        let r;
        try {
          r = tI.default.readFileSync(e, "utf-8");
        } catch {
          return null;
        }
        return t.fromContent(r);
      }
      static fromContent(e) {
        let r = e.split(/\r?\n/);
        return new t(1, r);
      }
      constructor(e, r) {
        this.firstLineNumber = e, this.lines = r;
      }
      get lastLineNumber() {
        return this.firstLineNumber + this.lines.length - 1;
      }
      mapLineAt(e, r) {
        if (e < this.firstLineNumber || e > this.lines.length + this.firstLineNumber) return this;
        let n = e - this.firstLineNumber, A = [...this.lines];
        return A[n] = r(A[n]), new t(this.firstLineNumber, A);
      }
      mapLines(e) {
        return new t(this.firstLineNumber, this.lines.map((r, n) => e(r, this.firstLineNumber + n)));
      }
      lineAt(e) {
        return this.lines[e - this.firstLineNumber];
      }
      prependSymbolAt(e, r) {
        return this.mapLines((n, A) => A === e ? `${r} ${n}` : `  ${n}`);
      }
      slice(e, r) {
        let n = this.lines.slice(e - 1, r).join(`
`);
        return new t(e, eI(n).split(`
`));
      }
      highlight() {
        let e = zC(this.toString());
        return new t(this.firstLineNumber, e.split(`
`));
      }
      toString() {
        return this.lines.join(`
`);
      }
    };
    var qx = { red: at, gray: hi, dim: nn, bold: be, underline: Je, highlightSource: (t) => t.highlight() };
    var Jx = { red: (t) => t, gray: (t) => t, dim: (t) => t, bold: (t) => t, underline: (t) => t, highlightSource: (t) => t };
    function Wx({ message: t, originalMethod: e, isPanic: r, callArguments: n }) {
      return { functionName: `prisma.${e}()`, message: t, isPanic: r ?? false, callArguments: n };
    }
    function _x({ callsite: t, message: e, originalMethod: r, isPanic: n, callArguments: A }, i) {
      let s = Wx({ message: e, originalMethod: r, isPanic: n, callArguments: A });
      if (!t || typeof window < "u" || process.env.NODE_ENV === "production") return s;
      let o = t.getLocation();
      if (!o || !o.lineNumber || !o.columnNumber) return s;
      let a = Math.max(1, o.lineNumber - 3), c = ta.read(o.fileName)?.slice(a, o.lineNumber), l = c?.lineAt(o.lineNumber);
      if (c && l) {
        let u = Zx(l), g = jx(l);
        if (!g) return s;
        s.functionName = `${g.code})`, s.location = o, n || (c = c.mapLineAt(o.lineNumber, (h) => h.slice(0, g.openingBraceIndex))), c = i.highlightSource(c);
        let E = String(c.lastLineNumber).length;
        if (s.contextLines = c.mapLines((h, f) => i.gray(String(f).padStart(E)) + " " + h).mapLines((h) => i.dim(h)).prependSymbolAt(o.lineNumber, i.bold(i.red("\u2192"))), A) {
          let h = u + E + 1;
          h += 2, s.callArguments = (0, rI.default)(A, h).slice(h);
        }
      }
      return s;
    }
    function jx(t) {
      let e = Object.keys(oA).join("|"), n = new RegExp(String.raw`\.(${e})\(`).exec(t);
      if (n) {
        let A = n.index + n[0].length, i = t.lastIndexOf(" ", n.index) + 1;
        return { code: t.slice(i, A), openingBraceIndex: A };
      }
      return null;
    }
    function Zx(t) {
      let e = 0;
      for (let r = 0; r < t.length; r++) {
        if (t.charAt(r) !== " ") return e;
        e++;
      }
      return e;
    }
    function Xx({ functionName: t, location: e, message: r, isPanic: n, contextLines: A, callArguments: i }, s) {
      let o = [""], a = e ? " in" : ":";
      if (n ? (o.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)), o.push(s.red(`It occurred in the ${s.bold(`\`${t}\``)} invocation${a}`))) : o.push(s.red(`Invalid ${s.bold(`\`${t}\``)} invocation${a}`)), e && o.push(s.underline(Kx(e))), A) {
        o.push("");
        let c = [A.toString()];
        i && (c.push(i), c.push(s.dim(")"))), o.push(c.join("")), i && o.push("");
      } else o.push(""), i && o.push(i), o.push("");
      return o.push(r), o.join(`
`);
    }
    function Kx(t) {
      let e = [t.fileName];
      return t.lineNumber && e.push(String(t.lineNumber)), t.columnNumber && e.push(String(t.columnNumber)), e.join(":");
    }
    function ra(t) {
      let e = t.showColors ? qx : Jx, r;
      return r = _x(t, e), Xx(r, e);
    }
    var uI = G(vu());
    function sI(t, e, r) {
      let n = oI(t), A = $x(n), i = eU(A);
      i ? na(i, e, r) : e.addErrorMessage(() => "Unknown error");
    }
    function oI(t) {
      return t.errors.flatMap((e) => e.kind === "Union" ? oI(e) : [e]);
    }
    function $x(t) {
      let e = /* @__PURE__ */ new Map(), r = [];
      for (let n of t) {
        if (n.kind !== "InvalidArgumentType") {
          r.push(n);
          continue;
        }
        let A = `${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`, i = e.get(A);
        i ? e.set(A, { ...n, argument: { ...n.argument, typeNames: zx(i.argument.typeNames, n.argument.typeNames) } }) : e.set(A, n);
      }
      return r.push(...e.values()), r;
    }
    function zx(t, e) {
      return [...new Set(t.concat(e))];
    }
    function eU(t) {
      return Fu(t, (e, r) => {
        let n = AI(e), A = AI(r);
        return n !== A ? n - A : iI(e) - iI(r);
      });
    }
    function AI(t) {
      let e = 0;
      return Array.isArray(t.selectionPath) && (e += t.selectionPath.length), Array.isArray(t.argumentPath) && (e += t.argumentPath.length), e;
    }
    function iI(t) {
      switch (t.kind) {
        case "InvalidArgumentValue":
        case "ValueTooLarge":
          return 20;
        case "InvalidArgumentType":
          return 10;
        case "RequiredArgumentMissing":
          return -10;
        default:
          return 0;
      }
    }
    var et = class {
      constructor(e, r) {
        this.name = e;
        this.value = r;
      }
      isRequired = false;
      makeRequired() {
        return this.isRequired = true, this;
      }
      write(e) {
        let { colors: { green: r } } = e.context;
        e.addMarginSymbol(r(this.isRequired ? "+" : "?")), e.write(r(this.name)), this.isRequired || e.write(r("?")), e.write(r(": ")), typeof this.value == "string" ? e.write(r(this.value)) : e.write(this.value);
      }
    };
    cI();
    var aA = class {
      constructor(e = 0, r) {
        this.context = r;
        this.currentIndent = e;
      }
      lines = [];
      currentLine = "";
      currentIndent = 0;
      marginSymbol;
      afterNextNewLineCallback;
      write(e) {
        return typeof e == "string" ? this.currentLine += e : e.write(this), this;
      }
      writeJoined(e, r, n = (A, i) => i.write(A)) {
        let A = r.length - 1;
        for (let i = 0; i < r.length; i++) n(r[i], this), i !== A && this.write(e);
        return this;
      }
      writeLine(e) {
        return this.write(e).newLine();
      }
      newLine() {
        this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = void 0;
        let e = this.afterNextNewLineCallback;
        return this.afterNextNewLineCallback = void 0, e?.(), this;
      }
      withIndent(e) {
        return this.indent(), e(this), this.unindent(), this;
      }
      afterNextNewline(e) {
        return this.afterNextNewLineCallback = e, this;
      }
      indent() {
        return this.currentIndent++, this;
      }
      unindent() {
        return this.currentIndent > 0 && this.currentIndent--, this;
      }
      addMarginSymbol(e) {
        return this.marginSymbol = e, this;
      }
      toString() {
        return this.lines.concat(this.indentedCurrentLine()).join(`
`);
      }
      getCurrentLineLength() {
        return this.currentLine.length;
      }
      indentedCurrentLine() {
        let e = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
        return this.marginSymbol ? this.marginSymbol + e.slice(1) : e;
      }
    };
    aI();
    var Aa = class {
      constructor(e) {
        this.value = e;
      }
      write(e) {
        e.write(this.value);
      }
      markAsError() {
        this.value.markAsError();
      }
    };
    var ia = (t) => t;
    var sa = { bold: ia, red: ia, green: ia, dim: ia, enabled: false };
    var lI = { bold: be, red: at, green: Sr, dim: nn, enabled: true };
    var cA = { write(t) {
      t.writeLine(",");
    } };
    var vt = class {
      constructor(e) {
        this.contents = e;
      }
      isUnderlined = false;
      color = (e) => e;
      underline() {
        return this.isUnderlined = true, this;
      }
      setColor(e) {
        return this.color = e, this;
      }
      write(e) {
        let r = e.getCurrentLineLength();
        e.write(this.color(this.contents)), this.isUnderlined && e.afterNextNewline(() => {
          e.write(" ".repeat(r)).writeLine(this.color("~".repeat(this.contents.length)));
        });
      }
    };
    var Pr = class {
      hasError = false;
      markAsError() {
        return this.hasError = true, this;
      }
    };
    var lA = class extends Pr {
      items = [];
      addItem(e) {
        return this.items.push(new Aa(e)), this;
      }
      getField(e) {
        return this.items[e];
      }
      getPrintWidth() {
        return this.items.length === 0 ? 2 : Math.max(...this.items.map((r) => r.value.getPrintWidth())) + 2;
      }
      write(e) {
        if (this.items.length === 0) {
          this.writeEmpty(e);
          return;
        }
        this.writeWithItems(e);
      }
      writeEmpty(e) {
        let r = new vt("[]");
        this.hasError && r.setColor(e.context.colors.red).underline(), e.write(r);
      }
      writeWithItems(e) {
        let { colors: r } = e.context;
        e.writeLine("[").withIndent(() => e.writeJoined(cA, this.items).newLine()).write("]"), this.hasError && e.afterNextNewline(() => {
          e.writeLine(r.red("~".repeat(this.getPrintWidth())));
        });
      }
      asObject() {
      }
    };
    var uA = class t extends Pr {
      fields = {};
      suggestions = [];
      addField(e) {
        this.fields[e.name] = e;
      }
      addSuggestion(e) {
        this.suggestions.push(e);
      }
      getField(e) {
        return this.fields[e];
      }
      getDeepField(e) {
        let [r, ...n] = e, A = this.getField(r);
        if (!A) return;
        let i = A;
        for (let s of n) {
          let o;
          if (i.value instanceof t ? o = i.value.getField(s) : i.value instanceof lA && (o = i.value.getField(Number(s))), !o) return;
          i = o;
        }
        return i;
      }
      getDeepFieldValue(e) {
        return e.length === 0 ? this : this.getDeepField(e)?.value;
      }
      hasField(e) {
        return !!this.getField(e);
      }
      removeAllFields() {
        this.fields = {};
      }
      removeField(e) {
        delete this.fields[e];
      }
      getFields() {
        return this.fields;
      }
      isEmpty() {
        return Object.keys(this.fields).length === 0;
      }
      getFieldValue(e) {
        return this.getField(e)?.value;
      }
      getDeepSubSelectionValue(e) {
        let r = this;
        for (let n of e) {
          if (!(r instanceof t)) return;
          let A = r.getSubSelectionValue(n);
          if (!A) return;
          r = A;
        }
        return r;
      }
      getDeepSelectionParent(e) {
        let r = this.getSelectionParent();
        if (!r) return;
        let n = r;
        for (let A of e) {
          let i = n.value.getFieldValue(A);
          if (!i || !(i instanceof t)) return;
          let s = i.getSelectionParent();
          if (!s) return;
          n = s;
        }
        return n;
      }
      getSelectionParent() {
        let e = this.getField("select")?.value.asObject();
        if (e) return { kind: "select", value: e };
        let r = this.getField("include")?.value.asObject();
        if (r) return { kind: "include", value: r };
      }
      getSubSelectionValue(e) {
        return this.getSelectionParent()?.value.fields[e].value;
      }
      getPrintWidth() {
        let e = Object.values(this.fields);
        return e.length == 0 ? 2 : Math.max(...e.map((n) => n.getPrintWidth())) + 2;
      }
      write(e) {
        let r = Object.values(this.fields);
        if (r.length === 0 && this.suggestions.length === 0) {
          this.writeEmpty(e);
          return;
        }
        this.writeWithContents(e, r);
      }
      asObject() {
        return this;
      }
      writeEmpty(e) {
        let r = new vt("{}");
        this.hasError && r.setColor(e.context.colors.red).underline(), e.write(r);
      }
      writeWithContents(e, r) {
        e.writeLine("{").withIndent(() => {
          e.writeJoined(cA, [...r, ...this.suggestions]).newLine();
        }), e.write("}"), this.hasError && e.afterNextNewline(() => {
          e.writeLine(e.context.colors.red("~".repeat(this.getPrintWidth())));
        });
      }
    };
    var De = class extends Pr {
      constructor(r) {
        super();
        this.text = r;
      }
      getPrintWidth() {
        return this.text.length;
      }
      write(r) {
        let n = new vt(this.text);
        this.hasError && n.underline().setColor(r.context.colors.red), r.write(n);
      }
      asObject() {
      }
    };
    var ki = class {
      fields = [];
      addField(e, r) {
        return this.fields.push({ write(n) {
          let { green: A, dim: i } = n.context.colors;
          n.write(A(i(`${e}: ${r}`))).addMarginSymbol(A(i("+")));
        } }), this;
      }
      write(e) {
        let { colors: { green: r } } = e.context;
        e.writeLine(r("{")).withIndent(() => {
          e.writeJoined(cA, this.fields).newLine();
        }).write(r("}")).addMarginSymbol(r("+"));
      }
    };
    function na(t, e, r) {
      switch (t.kind) {
        case "MutuallyExclusiveFields":
          tU(t, e);
          break;
        case "IncludeOnScalar":
          rU(t, e);
          break;
        case "EmptySelection":
          nU(t, e, r);
          break;
        case "UnknownSelectionField":
          oU(t, e);
          break;
        case "InvalidSelectionValue":
          aU(t, e);
          break;
        case "UnknownArgument":
          cU(t, e);
          break;
        case "UnknownInputField":
          lU(t, e);
          break;
        case "RequiredArgumentMissing":
          uU(t, e);
          break;
        case "InvalidArgumentType":
          gU(t, e);
          break;
        case "InvalidArgumentValue":
          EU(t, e);
          break;
        case "ValueTooLarge":
          dU(t, e);
          break;
        case "SomeFieldsMissing":
          hU(t, e);
          break;
        case "TooManyFieldsGiven":
          fU(t, e);
          break;
        case "Union":
          sI(t, e, r);
          break;
        default:
          throw new Error("not implemented: " + t.kind);
      }
    }
    function tU(t, e) {
      let r = e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();
      r && (r.getField(t.firstField)?.markAsError(), r.getField(t.secondField)?.markAsError()), e.addErrorMessage((n) => `Please ${n.bold("either")} use ${n.green(`\`${t.firstField}\``)} or ${n.green(`\`${t.secondField}\``)}, but ${n.red("not both")} at the same time.`);
    }
    function rU(t, e) {
      let [r, n] = gA(t.selectionPath), A = t.outputType, i = e.arguments.getDeepSelectionParent(r)?.value;
      if (i && (i.getField(n)?.markAsError(), A)) for (let s of A.fields) s.isRelation && i.addSuggestion(new et(s.name, "true"));
      e.addErrorMessage((s) => {
        let o = `Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;
        return A ? o += ` on model ${s.bold(A.name)}. ${Mi(s)}` : o += ".", o += `
Note that ${s.bold("include")} statements only accept relation fields.`, o;
      });
    }
    function nU(t, e, r) {
      let n = e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();
      if (n) {
        let A = n.getField("omit")?.value.asObject();
        if (A) {
          AU(t, e, A);
          return;
        }
        if (n.hasField("select")) {
          iU(t, e);
          return;
        }
      }
      if (r?.[Ur(t.outputType.name)]) {
        sU(t, e);
        return;
      }
      e.addErrorMessage(() => `Unknown field at "${t.selectionPath.join(".")} selection"`);
    }
    function AU(t, e, r) {
      r.removeAllFields();
      for (let n of t.outputType.fields) r.addSuggestion(new et(n.name, "false"));
      e.addErrorMessage((n) => `The ${n.red("omit")} statement includes every field of the model ${n.bold(t.outputType.name)}. At least one field must be included in the result`);
    }
    function iU(t, e) {
      let r = t.outputType, n = e.arguments.getDeepSelectionParent(t.selectionPath)?.value, A = n?.isEmpty() ?? false;
      n && (n.removeAllFields(), dI(n, r)), e.addErrorMessage((i) => A ? `The ${i.red("`select`")} statement for type ${i.bold(r.name)} must not be empty. ${Mi(i)}` : `The ${i.red("`select`")} statement for type ${i.bold(r.name)} needs ${i.bold("at least one truthy value")}.`);
    }
    function sU(t, e) {
      let r = new ki();
      for (let A of t.outputType.fields) A.isRelation || r.addField(A.name, "false");
      let n = new et("omit", r).makeRequired();
      if (t.selectionPath.length === 0) e.arguments.addSuggestion(n);
      else {
        let [A, i] = gA(t.selectionPath), o = e.arguments.getDeepSelectionParent(A)?.value.asObject()?.getField(i);
        if (o) {
          let a = o?.value.asObject() ?? new uA();
          a.addSuggestion(n), o.value = a;
        }
      }
      e.addErrorMessage((A) => `The global ${A.red("omit")} configuration excludes every field of the model ${A.bold(t.outputType.name)}. At least one field must be included in the result`);
    }
    function oU(t, e) {
      let r = hI(t.selectionPath, e);
      if (r.parentKind !== "unknown") {
        r.field.markAsError();
        let n = r.parent;
        switch (r.parentKind) {
          case "select":
            dI(n, t.outputType);
            break;
          case "include":
            QU(n, t.outputType);
            break;
          case "omit":
            CU(n, t.outputType);
            break;
        }
      }
      e.addErrorMessage((n) => {
        let A = [`Unknown field ${n.red(`\`${r.fieldName}\``)}`];
        return r.parentKind !== "unknown" && A.push(`for ${n.bold(r.parentKind)} statement`), A.push(`on model ${n.bold(`\`${t.outputType.name}\``)}.`), A.push(Mi(n)), A.join(" ");
      });
    }
    function aU(t, e) {
      let r = hI(t.selectionPath, e);
      r.parentKind !== "unknown" && r.field.value.markAsError(), e.addErrorMessage((n) => `Invalid value for selection field \`${n.red(r.fieldName)}\`: ${t.underlyingError}`);
    }
    function cU(t, e) {
      let r = t.argumentPath[0], n = e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();
      n && (n.getField(r)?.markAsError(), IU(n, t.arguments)), e.addErrorMessage((A) => gI(A, r, t.arguments.map((i) => i.name)));
    }
    function lU(t, e) {
      let [r, n] = gA(t.argumentPath), A = e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();
      if (A) {
        A.getDeepField(t.argumentPath)?.markAsError();
        let i = A.getDeepFieldValue(r)?.asObject();
        i && fI(i, t.inputType);
      }
      e.addErrorMessage((i) => gI(i, n, t.inputType.fields.map((s) => s.name)));
    }
    function gI(t, e, r) {
      let n = [`Unknown argument \`${t.red(e)}\`.`], A = BU(e, r);
      return A && n.push(`Did you mean \`${t.green(A)}\`?`), r.length > 0 && n.push(Mi(t)), n.join(" ");
    }
    function uU(t, e) {
      let r;
      e.addErrorMessage((a) => r?.value instanceof De && r.value.text === "null" ? `Argument \`${a.green(i)}\` must not be ${a.red("null")}.` : `Argument \`${a.green(i)}\` is missing.`);
      let n = e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();
      if (!n) return;
      let [A, i] = gA(t.argumentPath), s = new ki(), o = n.getDeepFieldValue(A)?.asObject();
      if (o) {
        if (r = o.getField(i), r && o.removeField(i), t.inputTypes.length === 1 && t.inputTypes[0].kind === "object") {
          for (let a of t.inputTypes[0].fields) s.addField(a.name, a.typeNames.join(" | "));
          o.addSuggestion(new et(i, s).makeRequired());
        } else {
          let a = t.inputTypes.map(EI).join(" | ");
          o.addSuggestion(new et(i, a).makeRequired());
        }
        if (t.dependentArgumentPath) {
          n.getDeepField(t.dependentArgumentPath)?.markAsError();
          let [, a] = gA(t.dependentArgumentPath);
          e.addErrorMessage((c) => `Argument \`${c.green(i)}\` is required because argument \`${c.green(a)}\` was provided.`);
        }
      }
    }
    function EI(t) {
      return t.kind === "list" ? `${EI(t.elementType)}[]` : t.name;
    }
    function gU(t, e) {
      let r = t.argument.name, n = e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();
      n && n.getDeepFieldValue(t.argumentPath)?.markAsError(), e.addErrorMessage((A) => {
        let i = oa("or", t.argument.typeNames.map((s) => A.green(s)));
        return `Argument \`${A.bold(r)}\`: Invalid value provided. Expected ${i}, provided ${A.red(t.inferredType)}.`;
      });
    }
    function EU(t, e) {
      let r = t.argument.name, n = e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();
      n && n.getDeepFieldValue(t.argumentPath)?.markAsError(), e.addErrorMessage((A) => {
        let i = [`Invalid value for argument \`${A.bold(r)}\``];
        if (t.underlyingError && i.push(`: ${t.underlyingError}`), i.push("."), t.argument.typeNames.length > 0) {
          let s = oa("or", t.argument.typeNames.map((o) => A.green(o)));
          i.push(` Expected ${s}.`);
        }
        return i.join("");
      });
    }
    function dU(t, e) {
      let r = t.argument.name, n = e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject(), A;
      if (n) {
        let s = n.getDeepField(t.argumentPath)?.value;
        s?.markAsError(), s instanceof De && (A = s.text);
      }
      e.addErrorMessage((i) => {
        let s = ["Unable to fit value"];
        return A && s.push(i.red(A)), s.push(`into a 64-bit signed integer for field \`${i.bold(r)}\``), s.join(" ");
      });
    }
    function hU(t, e) {
      let r = t.argumentPath[t.argumentPath.length - 1], n = e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();
      if (n) {
        let A = n.getDeepFieldValue(t.argumentPath)?.asObject();
        A && fI(A, t.inputType);
      }
      e.addErrorMessage((A) => {
        let i = [`Argument \`${A.bold(r)}\` of type ${A.bold(t.inputType.name)} needs`];
        return t.constraints.minFieldCount === 1 ? t.constraints.requiredFields ? i.push(`${A.green("at least one of")} ${oa("or", t.constraints.requiredFields.map((s) => `\`${A.bold(s)}\``))} arguments.`) : i.push(`${A.green("at least one")} argument.`) : i.push(`${A.green(`at least ${t.constraints.minFieldCount}`)} arguments.`), i.push(Mi(A)), i.join(" ");
      });
    }
    function fU(t, e) {
      let r = t.argumentPath[t.argumentPath.length - 1], n = e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject(), A = [];
      if (n) {
        let i = n.getDeepFieldValue(t.argumentPath)?.asObject();
        i && (i.markAsError(), A = Object.keys(i.getFields()));
      }
      e.addErrorMessage((i) => {
        let s = [`Argument \`${i.bold(r)}\` of type ${i.bold(t.inputType.name)} needs`];
        return t.constraints.minFieldCount === 1 && t.constraints.maxFieldCount == 1 ? s.push(`${i.green("exactly one")} argument,`) : t.constraints.maxFieldCount == 1 ? s.push(`${i.green("at most one")} argument,`) : s.push(`${i.green(`at most ${t.constraints.maxFieldCount}`)} arguments,`), s.push(`but you provided ${oa("and", A.map((o) => i.red(o)))}. Please choose`), t.constraints.maxFieldCount === 1 ? s.push("one.") : s.push(`${t.constraints.maxFieldCount}.`), s.join(" ");
      });
    }
    function dI(t, e) {
      for (let r of e.fields) t.hasField(r.name) || t.addSuggestion(new et(r.name, "true"));
    }
    function QU(t, e) {
      for (let r of e.fields) r.isRelation && !t.hasField(r.name) && t.addSuggestion(new et(r.name, "true"));
    }
    function CU(t, e) {
      for (let r of e.fields) !t.hasField(r.name) && !r.isRelation && t.addSuggestion(new et(r.name, "true"));
    }
    function IU(t, e) {
      for (let r of e) t.hasField(r.name) || t.addSuggestion(new et(r.name, r.typeNames.join(" | ")));
    }
    function hI(t, e) {
      let [r, n] = gA(t), A = e.arguments.getDeepSubSelectionValue(r)?.asObject();
      if (!A) return { parentKind: "unknown", fieldName: n };
      let i = A.getFieldValue("select")?.asObject(), s = A.getFieldValue("include")?.asObject(), o = A.getFieldValue("omit")?.asObject(), a = i?.getField(n);
      return i && a ? { parentKind: "select", parent: i, field: a, fieldName: n } : (a = s?.getField(n), s && a ? { parentKind: "include", field: a, parent: s, fieldName: n } : (a = o?.getField(n), o && a ? { parentKind: "omit", field: a, parent: o, fieldName: n } : { parentKind: "unknown", fieldName: n }));
    }
    function fI(t, e) {
      if (e.kind === "object") for (let r of e.fields) t.hasField(r.name) || t.addSuggestion(new et(r.name, r.typeNames.join(" | ")));
    }
    function gA(t) {
      let e = [...t], r = e.pop();
      if (!r) throw new Error("unexpected empty path");
      return [e, r];
    }
    function Mi({ green: t, enabled: e }) {
      return "Available options are " + (e ? `listed in ${t("green")}` : "marked with ?") + ".";
    }
    function oa(t, e) {
      if (e.length === 1) return e[0];
      let r = [...e], n = r.pop();
      return `${r.join(", ")} ${t} ${n}`;
    }
    var pU = 3;
    function BU(t, e) {
      let r = 1 / 0, n;
      for (let A of e) {
        let i = (0, uI.default)(t, A);
        i > pU || i < r && (r = i, n = A);
      }
      return n;
    }
    var Li = class {
      modelName;
      name;
      typeName;
      isList;
      isEnum;
      constructor(e, r, n, A, i) {
        this.modelName = e, this.name = r, this.typeName = n, this.isList = A, this.isEnum = i;
      }
      _toGraphQLInputType() {
        let e = this.isList ? "List" : "", r = this.isEnum ? "Enum" : "";
        return `${e}${r}${this.typeName}FieldRefInput<${this.modelName}>`;
      }
    };
    function EA(t) {
      return t instanceof Li;
    }
    var aa = /* @__PURE__ */ Symbol();
    var Yu = /* @__PURE__ */ new WeakMap();
    var cr = class {
      constructor(e) {
        e === aa ? Yu.set(this, `Prisma.${this._getName()}`) : Yu.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
      }
      _getName() {
        return this.constructor.name;
      }
      toString() {
        return Yu.get(this);
      }
    };
    var vi = class extends cr {
      _getNamespace() {
        return "NullTypes";
      }
    };
    var Pi = class extends vi {
      #e;
    };
    Gu(Pi, "DbNull");
    var Yi = class extends vi {
      #e;
    };
    Gu(Yi, "JsonNull");
    var Gi = class extends vi {
      #e;
    };
    Gu(Gi, "AnyNull");
    var ca = { classes: { DbNull: Pi, JsonNull: Yi, AnyNull: Gi }, instances: { DbNull: new Pi(aa), JsonNull: new Yi(aa), AnyNull: new Gi(aa) } };
    function Gu(t, e) {
      Object.defineProperty(t, "name", { value: e, configurable: true });
    }
    var QI = ": ";
    var la = class {
      constructor(e, r) {
        this.name = e;
        this.value = r;
      }
      hasError = false;
      markAsError() {
        this.hasError = true;
      }
      getPrintWidth() {
        return this.name.length + this.value.getPrintWidth() + QI.length;
      }
      write(e) {
        let r = new vt(this.name);
        this.hasError && r.underline().setColor(e.context.colors.red), e.write(r).write(QI).write(this.value);
      }
    };
    var Ou = class {
      arguments;
      errorMessages = [];
      constructor(e) {
        this.arguments = e;
      }
      write(e) {
        e.write(this.arguments);
      }
      addErrorMessage(e) {
        this.errorMessages.push(e);
      }
      renderAllMessages(e) {
        return this.errorMessages.map((r) => r(e)).join(`
`);
      }
    };
    function dA(t) {
      return new Ou(CI(t));
    }
    function CI(t) {
      let e = new uA();
      for (let [r, n] of Object.entries(t)) {
        let A = new la(r, II(n));
        e.addField(A);
      }
      return e;
    }
    function II(t) {
      if (typeof t == "string") return new De(JSON.stringify(t));
      if (typeof t == "number" || typeof t == "boolean") return new De(String(t));
      if (typeof t == "bigint") return new De(`${t}n`);
      if (t === null) return new De("null");
      if (t === void 0) return new De("undefined");
      if (sA(t)) return new De(`new Prisma.Decimal("${t.toFixed()}")`);
      if (t instanceof Uint8Array) return Buffer.isBuffer(t) ? new De(`Buffer.alloc(${t.byteLength})`) : new De(`new Uint8Array(${t.byteLength})`);
      if (t instanceof Date) {
        let e = Jo(t) ? t.toISOString() : "Invalid Date";
        return new De(`new Date("${e}")`);
      }
      return t instanceof cr ? new De(`Prisma.${t._getName()}`) : EA(t) ? new De(`prisma.${Ur(t.modelName)}.$fields.${t.name}`) : Array.isArray(t) ? mU(t) : typeof t == "object" ? CI(t) : new De(Object.prototype.toString.call(t));
    }
    function mU(t) {
      let e = new lA();
      for (let r of t) e.addItem(II(r));
      return e;
    }
    function ua(t, e) {
      let r = e === "pretty" ? lI : sa, n = t.renderAllMessages(r), A = new aA(0, { colors: r }).write(t).toString();
      return { message: n, args: A };
    }
    function ga({ args: t, errors: e, errorFormat: r, callsite: n, originalMethod: A, clientVersion: i, globalOmit: s }) {
      let o = dA(t);
      for (let u of e) na(u, o, s);
      let { message: a, args: c } = ua(o, r), l = ra({ message: a, callsite: n, originalMethod: A, showColors: r === "pretty", callArguments: c });
      throw new Ue(l, { clientVersion: i });
    }
    function Pt(t) {
      return t.replace(/^./, (e) => e.toLowerCase());
    }
    function BI(t, e, r) {
      let n = Pt(r);
      return !e.result || !(e.result.$allModels || e.result[n]) ? t : yU({ ...t, ...pI(e.name, t, e.result.$allModels), ...pI(e.name, t, e.result[n]) });
    }
    function yU(t) {
      let e = new kt(), r = (n, A) => e.getOrCreate(n, () => A.has(n) ? [n] : (A.add(n), t[n] ? t[n].needs.flatMap((i) => r(i, A)) : [n]));
      return Ho(t, (n) => ({ ...n, needs: r(n.name, /* @__PURE__ */ new Set()) }));
    }
    function pI(t, e, r) {
      return r ? Ho(r, ({ needs: n, compute: A }, i) => ({ name: i, needs: n ? Object.keys(n).filter((s) => n[s]) : [], compute: wU(e, i, A) })) : {};
    }
    function wU(t, e, r) {
      let n = t?.[e]?.compute;
      return n ? (A) => r({ ...A, [e]: n(A) }) : r;
    }
    function mI(t, e) {
      if (!e) return t;
      let r = { ...t };
      for (let n of Object.values(e)) if (t[n.name]) for (let A of n.needs) r[A] = true;
      return r;
    }
    function yI(t, e) {
      if (!e) return t;
      let r = { ...t };
      for (let n of Object.values(e)) if (!t[n.name]) for (let A of n.needs) delete r[A];
      return r;
    }
    var Ea = class {
      constructor(e, r) {
        this.extension = e;
        this.previous = r;
      }
      computedFieldsCache = new kt();
      modelExtensionsCache = new kt();
      queryCallbacksCache = new kt();
      clientExtensions = Ti(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions());
      batchCallbacks = Ti(() => {
        let e = this.previous?.getAllBatchQueryCallbacks() ?? [], r = this.extension.query?.$__internalBatch;
        return r ? e.concat(r) : e;
      });
      getAllComputedFields(e) {
        return this.computedFieldsCache.getOrCreate(e, () => BI(this.previous?.getAllComputedFields(e), this.extension, e));
      }
      getAllClientExtensions() {
        return this.clientExtensions.get();
      }
      getAllModelExtensions(e) {
        return this.modelExtensionsCache.getOrCreate(e, () => {
          let r = Pt(e);
          return !this.extension.model || !(this.extension.model[r] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(e) : { ...this.previous?.getAllModelExtensions(e), ...this.extension.model.$allModels, ...this.extension.model[r] };
        });
      }
      getAllQueryCallbacks(e, r) {
        return this.queryCallbacksCache.getOrCreate(`${e}:${r}`, () => {
          let n = this.previous?.getAllQueryCallbacks(e, r) ?? [], A = [], i = this.extension.query;
          return !i || !(i[e] || i.$allModels || i[r] || i.$allOperations) ? n : (i[e] !== void 0 && (i[e][r] !== void 0 && A.push(i[e][r]), i[e].$allOperations !== void 0 && A.push(i[e].$allOperations)), e !== "$none" && i.$allModels !== void 0 && (i.$allModels[r] !== void 0 && A.push(i.$allModels[r]), i.$allModels.$allOperations !== void 0 && A.push(i.$allModels.$allOperations)), i[r] !== void 0 && A.push(i[r]), i.$allOperations !== void 0 && A.push(i.$allOperations), n.concat(A));
        });
      }
      getAllBatchQueryCallbacks() {
        return this.batchCallbacks.get();
      }
    };
    var hA = class t {
      constructor(e) {
        this.head = e;
      }
      static empty() {
        return new t();
      }
      static single(e) {
        return new t(new Ea(e));
      }
      isEmpty() {
        return this.head === void 0;
      }
      append(e) {
        return new t(new Ea(e, this.head));
      }
      getAllComputedFields(e) {
        return this.head?.getAllComputedFields(e);
      }
      getAllClientExtensions() {
        return this.head?.getAllClientExtensions();
      }
      getAllModelExtensions(e) {
        return this.head?.getAllModelExtensions(e);
      }
      getAllQueryCallbacks(e, r) {
        return this.head?.getAllQueryCallbacks(e, r) ?? [];
      }
      getAllBatchQueryCallbacks() {
        return this.head?.getAllBatchQueryCallbacks() ?? [];
      }
    };
    var da = class {
      constructor(e) {
        this.name = e;
      }
    };
    function wI(t) {
      return t instanceof da;
    }
    function DI(t) {
      return new da(t);
    }
    var RI = /* @__PURE__ */ Symbol();
    var Oi = class {
      constructor(e) {
        if (e !== RI) throw new Error("Skip instance can not be constructed directly");
      }
      ifUndefined(e) {
        return e === void 0 ? ha : e;
      }
    };
    var ha = new Oi(RI);
    function Yt(t) {
      return t instanceof Oi;
    }
    var DU = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", createManyAndReturn: "createManyAndReturn", update: "updateOne", updateMany: "updateMany", updateManyAndReturn: "updateManyAndReturn", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
    var SI = "explicitly `undefined` values are not allowed";
    function fa({ modelName: t, action: e, args: r, runtimeDataModel: n, extensions: A = hA.empty(), callsite: i, clientMethod: s, errorFormat: o, clientVersion: a, previewFeatures: c, globalOmit: l }) {
      let u = new Vu({ runtimeDataModel: n, modelName: t, action: e, rootArgs: r, callsite: i, extensions: A, selectionPath: [], argumentPath: [], originalMethod: s, errorFormat: o, clientVersion: a, previewFeatures: c, globalOmit: l });
      return { modelName: t, action: DU[e], query: Vi(r, u) };
    }
    function Vi({ select: t, include: e, ...r } = {}, n) {
      let A = r.omit;
      return delete r.omit, { arguments: NI(r, n), selection: RU(t, e, A, n) };
    }
    function RU(t, e, r, n) {
      return t ? (e ? n.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "include", secondField: "select", selectionPath: n.getSelectionPath() }) : r && n.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "omit", secondField: "select", selectionPath: n.getSelectionPath() }), FU(t, n)) : SU(n, e, r);
    }
    function SU(t, e, r) {
      let n = {};
      return t.modelOrType && !t.isRawAction() && (n.$composites = true, n.$scalars = true), e && bU(n, e, t), NU(n, r, t), n;
    }
    function bU(t, e, r) {
      for (let [n, A] of Object.entries(e)) {
        if (Yt(A)) continue;
        let i = r.nestSelection(n);
        if (Hu(A, i), A === false || A === void 0) {
          t[n] = false;
          continue;
        }
        let s = r.findField(n);
        if (s && s.kind !== "object" && r.throwValidationError({ kind: "IncludeOnScalar", selectionPath: r.getSelectionPath().concat(n), outputType: r.getOutputTypeDescription() }), s) {
          t[n] = Vi(A === true ? {} : A, i);
          continue;
        }
        if (A === true) {
          t[n] = true;
          continue;
        }
        t[n] = Vi(A, i);
      }
    }
    function NU(t, e, r) {
      let n = r.getComputedFields(), A = { ...r.getGlobalOmit(), ...e }, i = yI(A, n);
      for (let [s, o] of Object.entries(i)) {
        if (Yt(o)) continue;
        Hu(o, r.nestSelection(s));
        let a = r.findField(s);
        n?.[s] && !a || (t[s] = !o);
      }
    }
    function FU(t, e) {
      let r = {}, n = e.getComputedFields(), A = mI(t, n);
      for (let [i, s] of Object.entries(A)) {
        if (Yt(s)) continue;
        let o = e.nestSelection(i);
        Hu(s, o);
        let a = e.findField(i);
        if (!(n?.[i] && !a)) {
          if (s === false || s === void 0 || Yt(s)) {
            r[i] = false;
            continue;
          }
          if (s === true) {
            a?.kind === "object" ? r[i] = Vi({}, o) : r[i] = true;
            continue;
          }
          r[i] = Vi(s, o);
        }
      }
      return r;
    }
    function bI(t, e) {
      if (t === null) return null;
      if (typeof t == "string" || typeof t == "number" || typeof t == "boolean") return t;
      if (typeof t == "bigint") return { $type: "BigInt", value: String(t) };
      if (nA(t)) {
        if (Jo(t)) return { $type: "DateTime", value: t.toISOString() };
        e.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: e.getSelectionPath(), argumentPath: e.getArgumentPath(), argument: { name: e.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
      }
      if (wI(t)) return { $type: "Param", value: t.name };
      if (EA(t)) return { $type: "FieldRef", value: { _ref: t.name, _container: t.modelName } };
      if (Array.isArray(t)) return TU(t, e);
      if (ArrayBuffer.isView(t)) {
        let { buffer: r, byteOffset: n, byteLength: A } = t;
        return { $type: "Bytes", value: Buffer.from(r, n, A).toString("base64") };
      }
      if (xU(t)) return t.values;
      if (sA(t)) return { $type: "Decimal", value: t.toFixed() };
      if (t instanceof cr) {
        if (t !== ca.instances[t._getName()]) throw new Error("Invalid ObjectEnumValue");
        return { $type: "Enum", value: t._getName() };
      }
      if (UU(t)) return t.toJSON();
      if (typeof t == "object") return NI(t, e);
      e.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: e.getSelectionPath(), argumentPath: e.getArgumentPath(), argument: { name: e.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(t)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
    }
    function NI(t, e) {
      if (t.$type) return { $type: "Raw", value: t };
      let r = {};
      for (let n in t) {
        let A = t[n], i = e.nestArgument(n);
        Yt(A) || (A !== void 0 ? r[n] = bI(A, i) : e.isPreviewFeatureOn("strictUndefinedChecks") && e.throwValidationError({ kind: "InvalidArgumentValue", argumentPath: i.getArgumentPath(), selectionPath: e.getSelectionPath(), argument: { name: e.getArgumentName(), typeNames: [] }, underlyingError: SI }));
      }
      return r;
    }
    function TU(t, e) {
      let r = [];
      for (let n = 0; n < t.length; n++) {
        let A = e.nestArgument(String(n)), i = t[n];
        if (i === void 0 || Yt(i)) {
          let s = i === void 0 ? "undefined" : "Prisma.skip";
          e.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: A.getSelectionPath(), argumentPath: A.getArgumentPath(), argument: { name: `${e.getArgumentName()}[${n}]`, typeNames: [] }, underlyingError: `Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values` });
        }
        r.push(bI(i, A));
      }
      return r;
    }
    function xU(t) {
      return typeof t == "object" && t !== null && t.__prismaRawParameters__ === true;
    }
    function UU(t) {
      return typeof t == "object" && t !== null && typeof t.toJSON == "function";
    }
    function Hu(t, e) {
      t === void 0 && e.isPreviewFeatureOn("strictUndefinedChecks") && e.throwValidationError({ kind: "InvalidSelectionValue", selectionPath: e.getSelectionPath(), underlyingError: SI });
    }
    var Vu = class t {
      constructor(e) {
        this.params = e;
        this.params.modelName && (this.modelOrType = this.params.runtimeDataModel.models[this.params.modelName] ?? this.params.runtimeDataModel.types[this.params.modelName]);
      }
      modelOrType;
      throwValidationError(e) {
        ga({ errors: [e], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion, globalOmit: this.params.globalOmit });
      }
      getSelectionPath() {
        return this.params.selectionPath;
      }
      getArgumentPath() {
        return this.params.argumentPath;
      }
      getArgumentName() {
        return this.params.argumentPath[this.params.argumentPath.length - 1];
      }
      getOutputTypeDescription() {
        if (!(!this.params.modelName || !this.modelOrType)) return { name: this.params.modelName, fields: this.modelOrType.fields.map((e) => ({ name: e.name, typeName: "boolean", isRelation: e.kind === "object" })) };
      }
      isRawAction() {
        return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
      }
      isPreviewFeatureOn(e) {
        return this.params.previewFeatures.includes(e);
      }
      getComputedFields() {
        if (this.params.modelName) return this.params.extensions.getAllComputedFields(this.params.modelName);
      }
      findField(e) {
        return this.modelOrType?.fields.find((r) => r.name === e);
      }
      nestSelection(e) {
        let r = this.findField(e), n = r?.kind === "object" ? r.type : void 0;
        return new t({ ...this.params, modelName: n, selectionPath: this.params.selectionPath.concat(e) });
      }
      getGlobalOmit() {
        return this.params.modelName && this.shouldApplyGlobalOmit() ? this.params.globalOmit?.[Ur(this.params.modelName)] ?? {} : {};
      }
      shouldApplyGlobalOmit() {
        switch (this.params.action) {
          case "findFirst":
          case "findFirstOrThrow":
          case "findUniqueOrThrow":
          case "findMany":
          case "upsert":
          case "findUnique":
          case "createManyAndReturn":
          case "create":
          case "update":
          case "updateManyAndReturn":
          case "delete":
            return true;
          case "executeRaw":
          case "aggregateRaw":
          case "runCommandRaw":
          case "findRaw":
          case "createMany":
          case "deleteMany":
          case "groupBy":
          case "updateMany":
          case "count":
          case "aggregate":
          case "queryRaw":
            return false;
          default:
            ln(this.params.action, "Unknown action");
        }
      }
      nestArgument(e) {
        return new t({ ...this.params, argumentPath: this.params.argumentPath.concat(e) });
      }
    };
    function FI(t) {
      if (!t._hasPreviewFlag("metrics")) throw new Ue("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: t._clientVersion });
    }
    var fA = class {
      _client;
      constructor(e) {
        this._client = e;
      }
      prometheus(e) {
        return FI(this._client), this._client._engine.metrics({ format: "prometheus", ...e });
      }
      json(e) {
        return FI(this._client), this._client._engine.metrics({ format: "json", ...e });
      }
    };
    function TI(t, e) {
      let r = Ti(() => kU(e));
      Object.defineProperty(t, "dmmf", { get: () => r.get() });
    }
    function kU(t) {
      return { datamodel: { models: qu(t.models), enums: qu(t.enums), types: qu(t.types) } };
    }
    function qu(t) {
      return Object.entries(t).map(([e, r]) => ({ name: e, ...r }));
    }
    var Ju = /* @__PURE__ */ new WeakMap();
    var Qa = "$$PrismaTypedSql";
    var Hi = class {
      constructor(e, r) {
        Ju.set(this, { sql: e, values: r }), Object.defineProperty(this, Qa, { value: Qa });
      }
      get sql() {
        return Ju.get(this).sql;
      }
      get values() {
        return Ju.get(this).values;
      }
    };
    function xI(t) {
      return (...e) => new Hi(t, e);
    }
    function Ca(t) {
      return t != null && t[Qa] === Qa;
    }
    var hb = G(du());
    var fb = require("node:async_hooks");
    var Qb = require("node:events");
    var Cb = G(require("node:fs"));
    var kl = G(require("node:path"));
    var _e = class t {
      constructor(e, r) {
        if (e.length - 1 !== r.length) throw e.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${e.length} strings to have ${e.length - 1} values`);
        let n = r.reduce((s, o) => s + (o instanceof t ? o.values.length : 1), 0);
        this.values = new Array(n), this.strings = new Array(n + 1), this.strings[0] = e[0];
        let A = 0, i = 0;
        for (; A < r.length; ) {
          let s = r[A++], o = e[A];
          if (s instanceof t) {
            this.strings[i] += s.strings[0];
            let a = 0;
            for (; a < s.values.length; ) this.values[i++] = s.values[a++], this.strings[i] = s.strings[a];
            this.strings[i] += o;
          } else this.values[i++] = s, this.strings[i] = o;
        }
      }
      get sql() {
        let e = this.strings.length, r = 1, n = this.strings[0];
        for (; r < e; ) n += `?${this.strings[r++]}`;
        return n;
      }
      get statement() {
        let e = this.strings.length, r = 1, n = this.strings[0];
        for (; r < e; ) n += `:${r}${this.strings[r++]}`;
        return n;
      }
      get text() {
        let e = this.strings.length, r = 1, n = this.strings[0];
        for (; r < e; ) n += `$${r}${this.strings[r++]}`;
        return n;
      }
      inspect() {
        return { sql: this.sql, statement: this.statement, text: this.text, values: this.values };
      }
    };
    function UI(t, e = ",", r = "", n = "") {
      if (t.length === 0) throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
      return new _e([r, ...Array(t.length - 1).fill(e), n], t);
    }
    function Wu(t) {
      return new _e([t], []);
    }
    var kI = Wu("");
    function _u(t, ...e) {
      return new _e(t, e);
    }
    function qi(t) {
      return { getKeys() {
        return Object.keys(t);
      }, getPropertyValue(e) {
        return t[e];
      } };
    }
    function Oe(t, e) {
      return { getKeys() {
        return [t];
      }, getPropertyValue() {
        return e();
      } };
    }
    function gn(t) {
      let e = new kt();
      return { getKeys() {
        return t.getKeys();
      }, getPropertyValue(r) {
        return e.getOrCreate(r, () => t.getPropertyValue(r));
      }, getPropertyDescriptor(r) {
        return t.getPropertyDescriptor?.(r);
      } };
    }
    var Ia = { enumerable: true, configurable: true, writable: true };
    function pa(t) {
      let e = new Set(t);
      return { getPrototypeOf: () => Object.prototype, getOwnPropertyDescriptor: () => Ia, has: (r, n) => e.has(n), set: (r, n, A) => e.add(n) && Reflect.set(r, n, A), ownKeys: () => [...e] };
    }
    var MI = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
    function mt(t, e) {
      let r = MU(e), n = /* @__PURE__ */ new Set(), A = new Proxy(t, { get(i, s) {
        if (n.has(s)) return i[s];
        let o = r.get(s);
        return o ? o.getPropertyValue(s) : i[s];
      }, has(i, s) {
        if (n.has(s)) return true;
        let o = r.get(s);
        return o ? o.has?.(s) ?? true : Reflect.has(i, s);
      }, ownKeys(i) {
        let s = LI(Reflect.ownKeys(i), r), o = LI(Array.from(r.keys()), r);
        return [.../* @__PURE__ */ new Set([...s, ...o, ...n])];
      }, set(i, s, o) {
        return r.get(s)?.getPropertyDescriptor?.(s)?.writable === false ? false : (n.add(s), Reflect.set(i, s, o));
      }, getOwnPropertyDescriptor(i, s) {
        let o = Reflect.getOwnPropertyDescriptor(i, s);
        if (o && !o.configurable) return o;
        let a = r.get(s);
        return a ? a.getPropertyDescriptor ? { ...Ia, ...a?.getPropertyDescriptor(s) } : Ia : o;
      }, defineProperty(i, s, o) {
        return n.add(s), Reflect.defineProperty(i, s, o);
      }, getPrototypeOf: () => Object.prototype });
      return A[MI] = function() {
        let i = { ...this };
        return delete i[MI], i;
      }, A;
    }
    function MU(t) {
      let e = /* @__PURE__ */ new Map();
      for (let r of t) {
        let n = r.getKeys();
        for (let A of n) e.set(A, r);
      }
      return e;
    }
    function LI(t, e) {
      return t.filter((r) => e.get(r)?.has?.(r) ?? true);
    }
    function QA(t) {
      return { getKeys() {
        return t;
      }, has() {
        return false;
      }, getPropertyValue() {
      } };
    }
    function CA(t, e) {
      return { batch: t, transaction: e?.kind === "batch" ? { isolationLevel: e.options.isolationLevel } : void 0 };
    }
    function vI(t) {
      if (t === void 0) return "";
      let e = dA(t);
      return new aA(0, { colors: sa }).write(e).toString();
    }
    var LU = "P2037";
    function Yr({ error: t, user_facing_error: e }, r, n) {
      return e.error_code ? new Ne(vU(e, n), { code: e.error_code, clientVersion: r, meta: e.meta, batchRequestIdx: e.batch_request_idx }) : new Be(t, { clientVersion: r, batchRequestIdx: e.batch_request_idx });
    }
    function vU(t, e) {
      let r = t.message;
      return (e === "postgresql" || e === "postgres" || e === "mysql") && t.error_code === LU && (r += `
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`), r;
    }
    var Ji = "<unknown>";
    function PI(t) {
      var e = t.split(`
`);
      return e.reduce(function(r, n) {
        var A = GU(n) || VU(n) || JU(n) || ZU(n) || _U(n);
        return A && r.push(A), r;
      }, []);
    }
    var PU = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    var YU = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    function GU(t) {
      var e = PU.exec(t);
      if (!e) return null;
      var r = e[2] && e[2].indexOf("native") === 0, n = e[2] && e[2].indexOf("eval") === 0, A = YU.exec(e[2]);
      return n && A != null && (e[2] = A[1], e[3] = A[2], e[4] = A[3]), { file: r ? null : e[2], methodName: e[1] || Ji, arguments: r ? [e[2]] : [], lineNumber: e[3] ? +e[3] : null, column: e[4] ? +e[4] : null };
    }
    var OU = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function VU(t) {
      var e = OU.exec(t);
      return e ? { file: e[2], methodName: e[1] || Ji, arguments: [], lineNumber: +e[3], column: e[4] ? +e[4] : null } : null;
    }
    var HU = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
    var qU = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    function JU(t) {
      var e = HU.exec(t);
      if (!e) return null;
      var r = e[3] && e[3].indexOf(" > eval") > -1, n = qU.exec(e[3]);
      return r && n != null && (e[3] = n[1], e[4] = n[2], e[5] = null), { file: e[3], methodName: e[1] || Ji, arguments: e[2] ? e[2].split(",") : [], lineNumber: e[4] ? +e[4] : null, column: e[5] ? +e[5] : null };
    }
    var WU = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
    function _U(t) {
      var e = WU.exec(t);
      return e ? { file: e[3], methodName: e[1] || Ji, arguments: [], lineNumber: +e[4], column: e[5] ? +e[5] : null } : null;
    }
    var jU = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function ZU(t) {
      var e = jU.exec(t);
      return e ? { file: e[2], methodName: e[1] || Ji, arguments: [], lineNumber: +e[3], column: e[4] ? +e[4] : null } : null;
    }
    var ju = class {
      getLocation() {
        return null;
      }
    };
    var Zu = class {
      _error;
      constructor() {
        this._error = new Error();
      }
      getLocation() {
        let e = this._error.stack;
        if (!e) return null;
        let n = PI(e).find((A) => {
          if (!A.file) return false;
          let i = wu(A.file);
          return i !== "<anonymous>" && !i.includes("@prisma") && !i.includes("/packages/client/src/runtime/") && !i.endsWith("/runtime/binary.js") && !i.endsWith("/runtime/library.js") && !i.endsWith("/runtime/edge.js") && !i.endsWith("/runtime/edge-esm.js") && !i.startsWith("internal/") && !A.methodName.includes("new ") && !A.methodName.includes("getCallSite") && !A.methodName.includes("Proxy.") && A.methodName.split(".").length < 4;
        });
        return !n || !n.file ? null : { fileName: n.file, lineNumber: n.lineNumber, columnNumber: n.column };
      }
    };
    function Gr(t) {
      return t === "minimal" ? typeof $EnabledCallSite == "function" && t !== "minimal" ? new $EnabledCallSite() : new ju() : new Zu();
    }
    var YI = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
    function IA(t = {}) {
      let e = KU(t);
      return Object.entries(e).reduce((n, [A, i]) => (YI[A] !== void 0 ? n.select[A] = { select: i } : n[A] = i, n), { select: {} });
    }
    function KU(t = {}) {
      return typeof t._count == "boolean" ? { ...t, _count: { _all: t._count } } : t;
    }
    function Ba(t = {}) {
      return (e) => (typeof t._count == "boolean" && (e._count = e._count._all), e);
    }
    function GI(t, e) {
      let r = Ba(t);
      return e({ action: "aggregate", unpacker: r, argsMapper: IA })(t);
    }
    function $U(t = {}) {
      let { select: e, ...r } = t;
      return typeof e == "object" ? IA({ ...r, _count: e }) : IA({ ...r, _count: { _all: true } });
    }
    function zU(t = {}) {
      return typeof t.select == "object" ? (e) => Ba(t)(e)._count : (e) => Ba(t)(e)._count._all;
    }
    function OI(t, e) {
      return e({ action: "count", unpacker: zU(t), argsMapper: $U })(t);
    }
    function ek(t = {}) {
      let e = IA(t);
      if (Array.isArray(e.by)) for (let r of e.by) typeof r == "string" && (e.select[r] = true);
      else typeof e.by == "string" && (e.select[e.by] = true);
      return e;
    }
    function tk(t = {}) {
      return (e) => (typeof t?._count == "boolean" && e.forEach((r) => {
        r._count = r._count._all;
      }), e);
    }
    function VI(t, e) {
      return e({ action: "groupBy", unpacker: tk(t), argsMapper: ek })(t);
    }
    function HI(t, e, r) {
      if (e === "aggregate") return (n) => GI(n, r);
      if (e === "count") return (n) => OI(n, r);
      if (e === "groupBy") return (n) => VI(n, r);
    }
    function qI(t, e) {
      let r = e.fields.filter((A) => !A.relationName), n = LC(r, "name");
      return new Proxy({}, { get(A, i) {
        if (i in A || typeof i == "symbol") return A[i];
        let s = n[i];
        if (s) return new Li(t, i, s.type, s.isList, s.kind === "enum");
      }, ...pa(Object.keys(n)) });
    }
    var JI = (t) => Array.isArray(t) ? t : t.split(".");
    var Xu = (t, e) => JI(e).reduce((r, n) => r && r[n], t);
    var WI = (t, e, r) => JI(e).reduceRight((n, A, i, s) => Object.assign({}, Xu(t, s.slice(0, i)), { [A]: n }), r);
    function rk(t, e) {
      return t === void 0 || e === void 0 ? [] : [...e, "select", t];
    }
    function nk(t, e, r) {
      return e === void 0 ? t ?? {} : WI(e, r, t || true);
    }
    function Ku(t, e, r, n, A, i) {
      let o = t._runtimeDataModel.models[e].fields.reduce((a, c) => ({ ...a, [c.name]: c }), {});
      return (a) => {
        let c = Gr(t._errorFormat), l = rk(n, A), u = nk(a, i, l), g = r({ dataPath: l, callsite: c })(u), E = Ak(t, e);
        return new Proxy(g, { get(h, f) {
          if (!E.includes(f)) return h[f];
          let Q = [o[f].type, r, f], I = [l, u];
          return Ku(t, ...Q, ...I);
        }, ...pa([...E, ...Object.getOwnPropertyNames(g)]) });
      };
    }
    function Ak(t, e) {
      return t._runtimeDataModel.models[e].fields.filter((r) => r.kind === "object").map((r) => r.name);
    }
    var ik = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
    var sk = ["aggregate", "count", "groupBy"];
    function $u(t, e) {
      let r = t._extensions.getAllModelExtensions(e) ?? {}, n = [ok(t, e), ck(t, e), qi(r), Oe("name", () => e), Oe("$name", () => e), Oe("$parent", () => t._appliedParent)];
      return mt({}, n);
    }
    function ok(t, e) {
      let r = Pt(e), n = Object.keys(oA).concat("count");
      return { getKeys() {
        return n;
      }, getPropertyValue(A) {
        let i = A, s = (o) => (a) => {
          let c = Gr(t._errorFormat);
          return t._createPrismaPromise((l) => {
            let u = { args: a, dataPath: [], action: i, model: e, clientMethod: `${r}.${A}`, jsModelName: r, transaction: l, callsite: c };
            return t._request({ ...u, ...o });
          }, { action: i, args: a, model: e });
        };
        return ik.includes(i) ? Ku(t, e, s) : ak(A) ? HI(t, A, s) : s({});
      } };
    }
    function ak(t) {
      return sk.includes(t);
    }
    function ck(t, e) {
      return gn(Oe("fields", () => {
        let r = t._runtimeDataModel.models[e];
        return qI(e, r);
      }));
    }
    function _I(t) {
      return t.replace(/^./, (e) => e.toUpperCase());
    }
    var zu = /* @__PURE__ */ Symbol();
    function Wi(t) {
      let e = [lk(t), uk(t), Oe(zu, () => t), Oe("$parent", () => t._appliedParent)], r = t._extensions.getAllClientExtensions();
      return r && e.push(qi(r)), mt(t, e);
    }
    function lk(t) {
      let e = Object.getPrototypeOf(t._originalClient), r = [...new Set(Object.getOwnPropertyNames(e))];
      return { getKeys() {
        return r;
      }, getPropertyValue(n) {
        return t[n];
      } };
    }
    function uk(t) {
      let e = Object.keys(t._runtimeDataModel.models), r = e.map(Pt), n = [...new Set(e.concat(r))];
      return gn({ getKeys() {
        return n;
      }, getPropertyValue(A) {
        let i = _I(A);
        if (t._runtimeDataModel.models[i] !== void 0) return $u(t, i);
        if (t._runtimeDataModel.models[A] !== void 0) return $u(t, A);
      }, getPropertyDescriptor(A) {
        if (!r.includes(A)) return { enumerable: false };
      } });
    }
    function jI(t) {
      return t[zu] ? t[zu] : t;
    }
    function ZI(t) {
      if (typeof t == "function") return t(this);
      if (t.client?.__AccelerateEngine) {
        let r = t.client.__AccelerateEngine;
        this._originalClient._engine = new r(this._originalClient._accelerateEngineConfig);
      }
      let e = Object.create(this._originalClient, { _extensions: { value: this._extensions.append(t) }, _appliedParent: { value: this, configurable: true }, $on: { value: void 0 } });
      return Wi(e);
    }
    function XI({ result: t, modelName: e, select: r, omit: n, extensions: A }) {
      let i = A.getAllComputedFields(e);
      if (!i) return t;
      let s = [], o = [];
      for (let a of Object.values(i)) {
        if (n) {
          if (n[a.name]) continue;
          let c = a.needs.filter((l) => n[l]);
          c.length > 0 && o.push(QA(c));
        } else if (r) {
          if (!r[a.name]) continue;
          let c = a.needs.filter((l) => !r[l]);
          c.length > 0 && o.push(QA(c));
        }
        gk(t, a.needs) && s.push(Ek(a, mt(t, s)));
      }
      return s.length > 0 || o.length > 0 ? mt(t, [...s, ...o]) : t;
    }
    function gk(t, e) {
      return e.every((r) => Nu(t, r));
    }
    function Ek(t, e) {
      return gn(Oe(t.name, () => t.compute(e)));
    }
    function ma({ visitor: t, result: e, args: r, runtimeDataModel: n, modelName: A }) {
      if (Array.isArray(e)) {
        for (let s = 0; s < e.length; s++) e[s] = ma({ result: e[s], args: r, modelName: A, runtimeDataModel: n, visitor: t });
        return e;
      }
      let i = t(e, A, r) ?? e;
      return r.include && KI({ includeOrSelect: r.include, result: i, parentModelName: A, runtimeDataModel: n, visitor: t }), r.select && KI({ includeOrSelect: r.select, result: i, parentModelName: A, runtimeDataModel: n, visitor: t }), i;
    }
    function KI({ includeOrSelect: t, result: e, parentModelName: r, runtimeDataModel: n, visitor: A }) {
      for (let [i, s] of Object.entries(t)) {
        if (!s || e[i] == null || Yt(s)) continue;
        let a = n.models[r].fields.find((l) => l.name === i);
        if (!a || a.kind !== "object" || !a.relationName) continue;
        let c = typeof s == "object" ? s : {};
        e[i] = ma({ visitor: A, result: e[i], args: c, modelName: a.type, runtimeDataModel: n });
      }
    }
    function $I({ result: t, modelName: e, args: r, extensions: n, runtimeDataModel: A, globalOmit: i }) {
      return n.isEmpty() || t == null || typeof t != "object" || !A.models[e] ? t : ma({ result: t, args: r ?? {}, modelName: e, runtimeDataModel: A, visitor: (o, a, c) => {
        let l = Pt(a);
        return XI({ result: o, modelName: l, select: c.select, omit: c.select ? void 0 : { ...i?.[l], ...c.omit }, extensions: n });
      } });
    }
    var dk = ["$connect", "$disconnect", "$on", "$transaction", "$extends"];
    var zI = dk;
    function ep(t) {
      if (t instanceof _e) return hk(t);
      if (Ca(t)) return fk(t);
      if (Array.isArray(t)) {
        let r = [t[0]];
        for (let n = 1; n < t.length; n++) r[n] = _i(t[n]);
        return r;
      }
      let e = {};
      for (let r in t) e[r] = _i(t[r]);
      return e;
    }
    function hk(t) {
      return new _e(t.strings, t.values);
    }
    function fk(t) {
      return new Hi(t.sql, t.values);
    }
    function _i(t) {
      if (typeof t != "object" || t == null || t instanceof cr || EA(t)) return t;
      if (sA(t)) return new ar(t.toFixed());
      if (nA(t)) return /* @__PURE__ */ new Date(+t);
      if (ArrayBuffer.isView(t)) return t.slice(0);
      if (Array.isArray(t)) {
        let e = t.length, r;
        for (r = Array(e); e--; ) r[e] = _i(t[e]);
        return r;
      }
      if (typeof t == "object") {
        let e = {};
        for (let r in t) r === "__proto__" ? Object.defineProperty(e, r, { value: _i(t[r]), configurable: true, enumerable: true, writable: true }) : e[r] = _i(t[r]);
        return e;
      }
      ln(t, "Unknown value");
    }
    function rp(t, e, r, n = 0) {
      return t._createPrismaPromise((A) => {
        let i = e.customDataProxyFetch;
        return "transaction" in e && A !== void 0 && (e.transaction?.kind === "batch" && e.transaction.lock.then(), e.transaction = A), n === r.length ? t._executeRequest(e) : r[n]({ model: e.model, operation: e.model ? e.action : e.clientMethod, args: ep(e.args ?? {}), __internalParams: e, query: (s, o = e) => {
          let a = o.customDataProxyFetch;
          return o.customDataProxyFetch = sp(i, a), o.args = s, rp(t, o, r, n + 1);
        } });
      });
    }
    function np(t, e) {
      let { jsModelName: r, action: n, clientMethod: A } = e, i = r ? n : A;
      if (t._extensions.isEmpty()) return t._executeRequest(e);
      let s = t._extensions.getAllQueryCallbacks(r ?? "$none", i);
      return rp(t, e, s);
    }
    function Ap(t) {
      return (e) => {
        let r = { requests: e }, n = e[0].extensions.getAllBatchQueryCallbacks();
        return n.length ? ip(r, n, 0, t) : t(r);
      };
    }
    function ip(t, e, r, n) {
      if (r === e.length) return n(t);
      let A = t.customDataProxyFetch, i = t.requests[0].transaction;
      return e[r]({ args: { queries: t.requests.map((s) => ({ model: s.modelName, operation: s.action, args: s.args })), transaction: i ? { isolationLevel: i.kind === "batch" ? i.isolationLevel : void 0 } : void 0 }, __internalParams: t, query(s, o = t) {
        let a = o.customDataProxyFetch;
        return o.customDataProxyFetch = sp(A, a), ip(o, e, r + 1, n);
      } });
    }
    var tp = (t) => t;
    function sp(t = tp, e = tp) {
      return (r) => t(e(r));
    }
    var op = ce("prisma:client");
    var ap = { Vercel: "vercel", "Netlify CI": "netlify" };
    function cp({ postinstall: t, ciName: e, clientVersion: r }) {
      if (op("checkPlatformCaching:postinstall", t), op("checkPlatformCaching:ciName", e), t === true && e && e in ap) {
        let n = `Prisma has detected that this project was built on ${e}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${ap[e]}-build`;
        throw console.error(n), new Z(n, r);
      }
    }
    function lp(t, e) {
      return t ? t.datasources ? t.datasources : t.datasourceUrl ? { [e[0]]: { url: t.datasourceUrl } } : {} : {};
    }
    var Qk = () => globalThis.process?.release?.name === "node";
    var Ck = () => !!globalThis.Bun || !!globalThis.process?.versions?.bun;
    var Ik = () => !!globalThis.Deno;
    var pk = () => typeof globalThis.Netlify == "object";
    var Bk = () => typeof globalThis.EdgeRuntime == "object";
    var mk = () => globalThis.navigator?.userAgent === "Cloudflare-Workers";
    function yk() {
      return [[pk, "netlify"], [Bk, "edge-light"], [mk, "workerd"], [Ik, "deno"], [Ck, "bun"], [Qk, "node"]].flatMap((r) => r[0]() ? [r[1]] : []).at(0) ?? "";
    }
    var wk = { node: "Node.js", workerd: "Cloudflare Workers", deno: "Deno and Deno Deploy", netlify: "Netlify Edge Functions", "edge-light": "Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)" };
    function up() {
      let t = yk();
      return { id: t, prettyName: wk[t] || t, isEdge: ["workerd", "deno", "netlify", "edge-light"].includes(t) };
    }
    var SS = require("node:child_process");
    var bS = G(rC());
    var js = G(require("node:fs"));
    var NS = G(uC());
    var Qp = G(require("node:fs"), 1);
    var tg = G(require("node:path"), 1);
    var Cp = G(require("node:stream"), 1);
    var Ip = require("node:util");
    var gp = require("node:util");
    var ya = G(require("node:crypto"), 1);
    var Ep = (0, gp.promisify)(ya.default.randomBytes);
    var Dk = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~".split("");
    var Rk = "0123456789".split("");
    var Sk = "CDEHKMPRTUWXY012458".split("");
    var bk = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~".split("");
    var Nk = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
    var Fk = (t, e) => {
      let r = e.length, n = Math.floor(65536 / r) * r - 1, A = 2 * Math.ceil(1.1 * t), i = "", s = 0;
      for (; s < t; ) {
        let o = ya.default.randomBytes(A), a = 0;
        for (; a < A && s < t; ) {
          let c = o.readUInt16LE(a);
          a += 2, !(c > n) && (i += e[c % r], s++);
        }
      }
      return i;
    };
    var Tk = async (t, e) => {
      let r = e.length, n = Math.floor(65536 / r) * r - 1, A = 2 * Math.ceil(1.1 * t), i = "", s = 0;
      for (; s < t; ) {
        let o = await Ep(A), a = 0;
        for (; a < A && s < t; ) {
          let c = o.readUInt16LE(a);
          a += 2, !(c > n) && (i += e[c % r], s++);
        }
      }
      return i;
    };
    var xk = (t, e, r) => ya.default.randomBytes(t).toString(e).slice(0, r);
    var Uk = async (t, e, r) => (await Ep(t)).toString(e).slice(0, r);
    var kk = /* @__PURE__ */ new Set([void 0, "hex", "base64", "url-safe", "numeric", "distinguishable", "ascii-printable", "alphanumeric"]);
    var dp = (t, e) => ({ length: r, type: n, characters: A }) => {
      if (!(r >= 0 && Number.isFinite(r))) throw new TypeError("Expected a `length` to be a non-negative finite number");
      if (n !== void 0 && A !== void 0) throw new TypeError("Expected either `type` or `characters`");
      if (A !== void 0 && typeof A != "string") throw new TypeError("Expected `characters` to be string");
      if (!kk.has(n)) throw new TypeError(`Unknown type: ${n}`);
      if (n === void 0 && A === void 0 && (n = "hex"), n === "hex" || n === void 0 && A === void 0) return e(Math.ceil(r * 0.5), "hex", r);
      if (n === "base64") return e(Math.ceil(r * 0.75), "base64", r);
      if (n === "url-safe") return t(r, Dk);
      if (n === "numeric") return t(r, Rk);
      if (n === "distinguishable") return t(r, Sk);
      if (n === "ascii-printable") return t(r, bk);
      if (n === "alphanumeric") return t(r, Nk);
      if (A.length === 0) throw new TypeError("Expected `characters` string length to be greater than or equal to 1");
      if (A.length > 65536) throw new TypeError("Expected `characters` string length to be less or equal to 65536");
      return t(r, A.split(""));
    };
    var hp = dp(Fk, xk);
    hp.async = dp(Tk, Uk);
    var fp = hp;
    function eg() {
      return fp({ length: 32 });
    }
    var pp = G(Eu(), 1);
    var Lk = G(Eu(), 1);
    var R8 = (0, Ip.promisify)(Cp.default.pipeline);
    var Bp = (t = "") => tg.default.join(pp.default, t + eg());
    function mp({ name: t, extension: e } = {}) {
      if (t) {
        if (e != null) throw new Error("The `name` and `extension` options are mutually exclusive");
        return tg.default.join(Mk(), t);
      }
      return Bp() + (e == null ? "" : "." + e.replace(/^\./, ""));
    }
    function Mk({ prefix: t = "" } = {}) {
      let e = Bp(t);
      return Qp.default.mkdirSync(e), e;
    }
    function pA(t) {
      return typeof t == "string" ? t : t.message;
    }
    function yp(t) {
      if (t.fields?.message) {
        let e = t.fields?.message;
        return t.fields?.file && (e += ` in ${t.fields.file}`, t.fields?.line && (e += `:${t.fields.line}`), t.fields?.column && (e += `:${t.fields.column}`)), t.fields?.reason && (e += `
${t.fields?.reason}`), e;
      }
      return "Unknown error";
    }
    function wp(t) {
      return t.fields?.message === "PANIC";
    }
    function vk(t) {
      return t.timestamp && typeof t.level == "string" && typeof t.target == "string";
    }
    function rg(t) {
      return vk(t) && (t.level === "error" || t.fields?.message?.includes("fatal error"));
    }
    function Dp(t) {
      let r = Pk(t.fields) ? "query" : t.level.toLowerCase();
      return { ...t, level: r, timestamp: new Date(t.timestamp) };
    }
    function Pk(t) {
      return !!t.query;
    }
    var ji = class extends Error {
      clientVersion;
      _isPanic;
      constructor({ clientVersion: e, error: r }) {
        let n = yp(r);
        super(n ?? "Unknown error"), this._isPanic = wp(r), this.clientVersion = e;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientRustError";
      }
      isPanic() {
        return this._isPanic;
      }
    };
    M(ji, "PrismaClientRustError");
    var Fp = G(require("node:fs"));
    var Zi = G(require("node:path"));
    function wa(t) {
      let { runtimeBinaryTarget: e } = t;
      return `Add "${e}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${Yk(t)}`;
    }
    function Yk(t) {
      let { generator: e, generatorBinaryTargets: r, runtimeBinaryTarget: n } = t, A = { fromEnvVar: null, value: n }, i = [...r, A];
      return Bu({ ...e, binaryTargets: i });
    }
    function Or(t) {
      let { runtimeBinaryTarget: e } = t;
      return `Prisma Client could not locate the Query Engine for runtime "${e}".`;
    }
    function Vr(t) {
      let { searchedLocations: e } = t;
      return `The following locations have been searched:
${[...new Set(e)].map((A) => `  ${A}`).join(`
`)}`;
    }
    function Rp(t) {
      let { runtimeBinaryTarget: e } = t;
      return `${Or(t)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${e}".
${wa(t)}

${Vr(t)}`;
    }
    function Da(t) {
      return `We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${t}`;
    }
    function Ra(t) {
      let { errorStack: e } = t;
      return e?.match(/\/\.next|\/next@|\/next\//) ? `

We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.` : "";
    }
    function Sp(t) {
      let { queryEngineName: e } = t;
      return `${Or(t)}${Ra(t)}

This is likely caused by a bundler that has not copied "${e}" next to the resulting bundle.
Ensure that "${e}" has been copied next to the bundle or in "${t.expectedLocation}".

${Da("engine-not-found-bundler-investigation")}

${Vr(t)}`;
    }
    function bp(t) {
      let { runtimeBinaryTarget: e, generatorBinaryTargets: r } = t, n = r.find((A) => A.native);
      return `${Or(t)}

This happened because Prisma Client was generated for "${n?.value ?? "unknown"}", but the actual deployment required "${e}".
${wa(t)}

${Vr(t)}`;
    }
    function Np(t) {
      let { queryEngineName: e } = t;
      return `${Or(t)}${Ra(t)}

This is likely caused by tooling that has not copied "${e}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${e}" has been copied to "${t.expectedLocation}".

${Da("engine-not-found-tooling-investigation")}

${Vr(t)}`;
    }
    var Gk = ce("prisma:client:engines:resolveEnginePath");
    var Ok = () => new RegExp("runtime[\\\\/]binary\\.m?js$");
    async function ng(t, e) {
      let r = { binary: process.env.PRISMA_QUERY_ENGINE_BINARY, library: process.env.PRISMA_QUERY_ENGINE_LIBRARY }[t] ?? e.prismaPath;
      if (r !== void 0) return r;
      let { enginePath: n, searchedLocations: A } = await Vk(t, e);
      if (Gk("enginePath", n), n !== void 0 && t === "binary" && fu(n), n !== void 0) return e.prismaPath = n;
      let i = await sn(), s = e.generator?.binaryTargets ?? [], o = s.some((g) => g.native), a = !s.some((g) => g.value === i), c = __filename.match(Ok()) === null, l = { searchedLocations: A, generatorBinaryTargets: s, generator: e.generator, runtimeBinaryTarget: i, queryEngineName: Tp(t, i), expectedLocation: Zi.default.relative(process.cwd(), e.dirname), errorStack: new Error().stack }, u;
      throw o && a ? u = bp(l) : a ? u = Rp(l) : c ? u = Sp(l) : u = Np(l), new Z(u, e.clientVersion);
    }
    async function Vk(t, e) {
      let r = await sn(), n = [], A = [e.dirname, Zi.default.resolve(__dirname, ".."), e.generator?.output?.value ?? __dirname, Zi.default.resolve(__dirname, "../../../.prisma/client"), "/tmp/prisma-engines", e.cwd];
      __filename.includes("resolveEnginePath") && A.push(gC());
      for (let i of A) {
        let s = Tp(t, r), o = Zi.default.join(i, s);
        if (n.push(i), Fp.default.existsSync(o)) return { enginePath: o, searchedLocations: n };
      }
      return { enginePath: void 0, searchedLocations: n };
    }
    function Tp(t, e) {
      return t === "library" ? go(e, "fs") : `query-engine-${e}${e === "windows" ? ".exe" : ""}`;
    }
    var Ag = G(yu());
    function xp(t) {
      return t ? t.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (e) => `${e[0]}5`) : "";
    }
    function Up(t) {
      return t.split(`
`).map((e) => e.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "")).join(`
`);
    }
    var kp = G(kC());
    function Mp({ title: t, user: e = "prisma", repo: r = "prisma", template: n = "bug_report.yml", body: A }) {
      return (0, kp.default)({ user: e, repo: r, template: n, title: t, body: A });
    }
    function Lp({ version: t, binaryTarget: e, title: r, description: n, engineVersion: A, database: i, query: s }) {
      let o = uf(6e3 - (s?.length ?? 0)), a = Up((0, Ag.default)(o)), c = n ? `# Description
\`\`\`
${n}
\`\`\`` : "", l = (0, Ag.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${e?.padEnd(19)}|
| Prisma Client   | ${t?.padEnd(19)}|
| Query Engine    | ${A?.padEnd(19)}|
| Database        | ${i?.padEnd(19)}|

${c}

## Logs
\`\`\`
${a}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s ? xp(s) : ""}
\`\`\`
`), u = Mp({ title: r, body: l });
      return `${r}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${Je(u)}

If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
    }
    var mS = G(ou());
    var KW = () => BS();
    function $W(t) {
      if (t === void 0) throw new Error("Connection has not been opened");
    }
    var tr = class {
      _pool;
      constructor() {
      }
      static async onHttpError(e, r) {
        let n = await e;
        return n.statusCode >= 400 ? r(n) : n;
      }
      open(e, r) {
        this._pool || (this._pool = new (KW()).Pool(e, { connections: 1e3, keepAliveMaxTimeout: 6e5, headersTimeout: 0, bodyTimeout: 0, ...r }));
      }
      async raw(e, r, n, A, i = true) {
        $W(this._pool);
        let s = await this._pool.request({ path: r, method: e, headers: { "Content-Type": "application/json", ...n }, body: A }), o = await (0, mS.default)(s.body);
        return { statusCode: s.statusCode, headers: s.headers, data: i ? JSON.parse(o) : o };
      }
      post(e, r, n, A) {
        return this.raw("POST", e, n, r, A);
      }
      get(e, r) {
        return this.raw("GET", e, r);
      }
      close() {
        this._pool && this._pool.close(() => {
        }), this._pool = void 0;
      }
    };
    var Ye = ce("prisma:engine");
    var Ws = (...t) => {
    };
    var yS = [...Yl, "native"];
    var Rl = [];
    var wS = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
    var DS = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
    var oi = class {
      name = "BinaryEngine";
      config;
      logEmitter;
      showColors;
      logQueries;
      env;
      flags;
      enableDebugLogs;
      allowTriggerPanic;
      child;
      clientVersion;
      globalKillSignalReceived;
      startCount = 0;
      engineEndpoint;
      lastError;
      stopPromise;
      beforeExitListener;
      cwd;
      datamodelPath;
      stderrLogs = "";
      currentRequestPromise;
      binaryTargetPromise;
      binaryTarget;
      datasourceOverrides;
      startPromise;
      versionPromise;
      engineStartDeferred;
      engineStopDeferred;
      connection;
      lastQuery;
      lastVersion;
      lastActiveProvider;
      activeProvider;
      tracingHelper;
      constructor(e) {
        this.config = e, this.env = e.env, this.cwd = this.resolveCwd(e.cwd), this.enableDebugLogs = e.enableDebugLogs ?? false, this.allowTriggerPanic = e.allowTriggerPanic ?? false, this.tracingHelper = e.tracingHelper, this.logEmitter = e.logEmitter, this.showColors = e.showColors ?? false, this.logQueries = e.logQueries ?? false, this.clientVersion = e.clientVersion, this.flags = e.flags ?? [], this.activeProvider = e.activeProvider, this.connection = new tr(), this.datamodelPath = mp({ extension: "prisma" }), js.default.writeFileSync(this.datamodelPath, e.inlineSchema);
        let r = Object.keys(e.overrideDatasources)[0], n = e.overrideDatasources[r]?.url;
        if (r !== void 0 && n !== void 0 && (this.datasourceOverrides = [{ name: r, url: n }]), zW(), this.engineEndpoint = e.engineEndpoint, this.binaryTarget) {
          if (!yS.includes(this.binaryTarget) && !js.default.existsSync(this.binaryTarget)) throw new Z(`Unknown ${at("PRISMA_QUERY_ENGINE_BINARY")} ${at(be(this.binaryTarget))}. Possible binaryTargets: ${Sr(yS.join(", "))} or a path to the query engine binary.
You may have to run ${Sr("prisma generate")} for your changes to take effect.`, this.clientVersion);
        } else this.getCurrentBinaryTarget();
        this.enableDebugLogs && ce.enable("*"), Rl.push(this);
      }
      setError(e) {
        rg(e) && (this.lastError = new ji({ clientVersion: this.clientVersion, error: e }), this.lastError.isPanic() && (this.child && (this.stopPromise = e_(this.child)), this.currentRequestPromise?.cancel && this.currentRequestPromise.cancel()));
      }
      resolveCwd(e) {
        return js.default.existsSync(e) && js.default.lstatSync(e).isDirectory() ? e : process.cwd();
      }
      onBeforeExit(e) {
        this.beforeExitListener = e;
      }
      async emitExit() {
        if (this.beforeExitListener) try {
          await this.beforeExitListener();
        } catch (e) {
          console.error(e);
        }
      }
      async getCurrentBinaryTarget() {
        return this.binaryTargetPromise ? this.binaryTargetPromise : (this.binaryTargetPromise = this.tracingHelper.runInChildSpan("detect_platform", () => sn()), this.binaryTargetPromise);
      }
      printDatasources() {
        return this.datasourceOverrides ? JSON.stringify(this.datasourceOverrides) : "[]";
      }
      async start() {
        this.stopPromise && await this.stopPromise;
        let e = { times: 10 }, r = async () => {
          try {
            await this.tracingHelper.runInChildSpan("start_engine", () => this.startAndFetchBootSpans());
          } catch (A) {
            throw A.retryable === true && e.times > 0 && (e.times--, await r()), A;
          }
        }, n = async () => {
          if (this.startPromise || (this.startCount++, this.startPromise = r()), await this.startPromise, !this.child && !this.engineEndpoint) throw new Be("Can't perform request, as the Engine has already been stopped", { clientVersion: this.clientVersion });
        };
        return this.startPromise ? n() : this.tracingHelper.runInChildSpan("connect", n);
      }
      getEngineEnvVars() {
        let e = { PRISMA_DML_PATH: this.datamodelPath };
        return this.logQueries && (e.LOG_QUERIES = "true"), this.datasourceOverrides && (e.OVERWRITE_DATASOURCES = this.printDatasources()), !process.env.NO_COLOR && this.showColors && (e.CLICOLOR_FORCE = "1"), { ...this.env, ...process.env, ...e, RUST_BACKTRACE: process.env.RUST_BACKTRACE ?? "1", RUST_LOG: process.env.RUST_LOG ?? "info" };
      }
      async startAndFetchBootSpans() {
        await this.internalStart();
        let e = await tr.onHttpError(this.connection.get("/boot_trace"), (r) => this.httpErrorHandler(r));
        this.tracingHelper.dispatchEngineSpans(e.data.spans);
      }
      internalStart() {
        return new Promise(async (e, r) => {
          if (await new Promise((n) => process.nextTick(n)), this.stopPromise && await this.stopPromise, this.engineEndpoint) {
            try {
              this.connection.open(this.engineEndpoint), await (0, NS.default)(() => this.connection.get("/status"), { retries: 10 });
            } catch (n) {
              return r(n);
            }
            return e();
          }
          try {
            (this.child?.connected || this.child && !this.child?.killed) && Ye("There is a child that still runs and we want to start again"), this.lastError = void 0, Ws("startin & resettin"), this.globalKillSignalReceived = void 0, Ye("cwd:", this.cwd);
            let n = await ng("binary", this.config), A = this.allowTriggerPanic ? ["--debug"] : [], i = ["--enable-raw-queries", "--enable-metrics", "--enable-open-telemetry", ...this.flags, ...A];
            i.push("--port", "0"), i.push("--engine-protocol", "json"), Ye({ flags: i });
            let s = this.getEngineEnvVars();
            if (this.child = (0, SS.spawn)(n, i, { env: s, cwd: this.cwd, windowsHide: true, stdio: ["ignore", "pipe", "pipe"] }), Ri(this.child.stderr).on("data", (o) => {
              let a = String(o);
              Ye("stderr", a);
              try {
                let c = JSON.parse(a);
                if (typeof c.is_panic < "u" && (Ye(c), this.setError(c), this.engineStartDeferred)) {
                  let l = new Z(c.message, this.clientVersion, c.error_code);
                  this.engineStartDeferred.reject(l);
                }
              } catch {
                !a.includes("Printing to stderr") && !a.includes("Listening on ") && (this.stderrLogs += `
` + a);
              }
            }), Ri(this.child.stdout).on("data", (o) => {
              let a = String(o);
              try {
                let c = JSON.parse(a);
                if (Ye("stdout", pA(c)), this.engineStartDeferred && c.level === "INFO" && c.target === "query_engine::server" && c.fields?.message?.startsWith("Started query engine http server")) {
                  let l = c.fields.ip, u = c.fields.port;
                  if (l === void 0 || u === void 0) {
                    this.engineStartDeferred.reject(new Z('This version of Query Engine is not compatible with Prisma Client: "ip" and "port" fields are missing in the startup log entry', this.clientVersion));
                    return;
                  }
                  this.connection.open(`http://${l}:${u}`), this.engineStartDeferred.resolve(), this.engineStartDeferred = void 0;
                }
                if (typeof c.is_panic > "u") {
                  let l = Dp(c);
                  rg(l) ? this.setError(l) : l.level === "query" ? this.logEmitter.emit(l.level, { timestamp: l.timestamp, query: l.fields.query, params: l.fields.params, duration: l.fields.duration_ms, target: l.target }) : this.logEmitter.emit(l.level, { timestamp: l.timestamp, message: l.fields.message, target: l.target });
                } else this.setError(c);
              } catch (c) {
                Ye(c, a);
              }
            }), this.child.on("exit", (o) => {
              if (Ws("removing startPromise"), this.startPromise = void 0, this.engineStopDeferred) {
                this.engineStopDeferred.resolve(o);
                return;
              }
              if (this.connection.close(), o !== 0 && this.engineStartDeferred && this.startCount === 1) {
                let a, c = this.stderrLogs;
                this.lastError && (c = pA(this.lastError)), o !== null ? (a = new Z(`Query engine exited with code ${o}
` + c, this.clientVersion), a.retryable = true) : this.child?.signalCode ? (a = new Z(`Query engine process killed with signal ${this.child.signalCode} for unknown reason.
Make sure that the engine binary at ${n} is not corrupt.
` + c, this.clientVersion), a.retryable = true) : a = new Z(c, this.clientVersion), this.engineStartDeferred.reject(a);
              }
              this.child && (this.lastError || o === 126 && this.setError({ timestamp: /* @__PURE__ */ new Date(), target: "binary engine process exit", level: "error", fields: { message: `Couldn't start query engine as it's not executable on this operating system.
You very likely have the wrong "binaryTarget" defined in the schema.prisma file.` } }));
            }), this.child.on("error", (o) => {
              this.setError({ timestamp: /* @__PURE__ */ new Date(), target: "binary engine process error", level: "error", fields: { message: `Couldn't start query engine: ${o}` } }), r(o);
            }), this.child.on("close", (o, a) => {
              this.connection.close();
              let c;
              o === null && a === "SIGABRT" && this.child ? c = new ut(this.getErrorMessageWithLink("Panic in Query Engine with SIGABRT signal"), this.clientVersion) : o === 101 && a === null && this.lastError && (c = this.lastError), c && this.logEmitter.emit("error", { message: c.message, timestamp: /* @__PURE__ */ new Date(), target: "binary engine process close" });
            }), this.lastError) return r(new Z(pA(this.lastError), this.clientVersion));
            try {
              await new Promise((o, a) => {
                this.engineStartDeferred = { resolve: o, reject: a };
              });
            } catch (o) {
              throw this.child?.kill(), o;
            }
            (async () => {
              try {
                let o = await this.version(true);
                Ye(`Client Version: ${this.clientVersion}`), Ye(`Engine Version: ${o}`), Ye(`Active provider: ${this.activeProvider}`);
              } catch (o) {
                Ye(o);
              }
            })(), this.stopPromise = void 0, e();
          } catch (n) {
            r(n);
          }
        });
      }
      async stop() {
        let e = async () => (this.stopPromise || (this.stopPromise = this._stop()), this.stopPromise);
        return this.tracingHelper.runInChildSpan("disconnect", e);
      }
      async _stop() {
        if (this.startPromise && await this.startPromise, await new Promise((r) => process.nextTick(r)), this.currentRequestPromise) try {
          await this.currentRequestPromise;
        } catch {
        }
        let e;
        this.child && (Ye("Stopping Prisma engine"), this.startPromise && (Ye("Waiting for start promise"), await this.startPromise), Ye("Done waiting for start promise"), this.child.exitCode === null ? e = new Promise((r, n) => {
          this.engineStopDeferred = { resolve: r, reject: n };
        }) : Ye("Child already exited with code", this.child.exitCode), this.connection.close(), this.child.kill(), this.child = void 0), e && await e, await new Promise((r) => process.nextTick(r)), this.startPromise = void 0, this.engineStopDeferred = void 0;
      }
      kill(e) {
        this.globalKillSignalReceived = e, this.child?.kill(), this.connection.close();
      }
      async version(e = false) {
        return this.versionPromise && !e ? this.versionPromise : (this.versionPromise = this.internalVersion(), this.versionPromise);
      }
      async internalVersion() {
        let e = await ng("binary", this.config), r = await (0, bS.default)(e, ["--version"]);
        return this.lastVersion = r.stdout, this.lastVersion;
      }
      async request(e, { traceparent: r, numTry: n = 1, isWrite: A, interactiveTransaction: i }) {
        await this.start();
        let s = {};
        r && (s.traceparent = r), i && (s["X-transaction-id"] = i.id);
        let o = JSON.stringify(e);
        this.currentRequestPromise = tr.onHttpError(this.connection.post("/", o, s), (a) => this.httpErrorHandler(a)), this.lastQuery = o;
        try {
          let { data: a } = await this.currentRequestPromise;
          if (a.extensions?.traces && this.tracingHelper.dispatchEngineSpans(a.extensions.traces), a.errors) throw a.errors.length === 1 ? Yr(a.errors[0], this.clientVersion, this.config.activeProvider) : new Be(JSON.stringify(a.errors), { clientVersion: this.clientVersion });
          return this.startCount > 0 && (this.startCount = 0), this.currentRequestPromise = void 0, { data: a };
        } catch (a) {
          Ws("req - e", a);
          let { error: c, shouldRetry: l } = await this.handleRequestError(a);
          if (n <= DS && l && !A) return Ws("trying a retry now"), this.request(e, { traceparent: r, numTry: n + 1, isWrite: A, interactiveTransaction: i });
          throw c;
        }
      }
      async requestBatch(e, { traceparent: r, transaction: n, numTry: A = 1, containsWrite: i }) {
        await this.start();
        let s = {};
        r && (s.traceparent = r);
        let o = n?.kind === "itx" ? n.options : void 0;
        o && (s["X-transaction-id"] = o.id);
        let a = CA(e, n);
        return this.lastQuery = JSON.stringify(a), this.currentRequestPromise = tr.onHttpError(this.connection.post("/", this.lastQuery, s), (c) => this.httpErrorHandler(c)), this.currentRequestPromise.then(({ data: c }) => {
          c.extensions?.traces && this.tracingHelper.dispatchEngineSpans(c.extensions.traces);
          let { batchResult: l } = c;
          if (Array.isArray(l)) return l.map((u) => (u.extensions?.traces && this.tracingHelper.dispatchEngineSpans(u.extensions.traces), u.errors && u.errors.length > 0 ? Yr(u.errors[0], this.clientVersion, this.config.activeProvider) : { data: u }));
          throw Yr(c.errors[0], this.clientVersion, this.config.activeProvider);
        }).catch(async (c) => {
          let { error: l, shouldRetry: u } = await this.handleRequestError(c);
          if (u && !i && A <= DS) return this.requestBatch(e, { traceparent: r, transaction: n, numTry: A + 1, containsWrite: i });
          throw l;
        });
      }
      async transaction(e, r, n) {
        if (await this.start(), e === "start") {
          let A = JSON.stringify({ max_wait: n.maxWait, timeout: n.timeout, isolation_level: n.isolationLevel }), i = await tr.onHttpError(this.connection.post("/transaction/start", A, r), (s) => this.httpErrorHandler(s));
          return i.data.extensions?.traces && this.tracingHelper.dispatchEngineSpans(i.data.extensions.traces), i.data;
        } else if (e === "commit") {
          let A = await tr.onHttpError(this.connection.post(`/transaction/${n.id}/commit`, void 0, r), (i) => this.httpErrorHandler(i));
          A.data.extensions?.traces && this.tracingHelper.dispatchEngineSpans(A.data.extensions.traces);
        } else if (e === "rollback") {
          let A = await tr.onHttpError(this.connection.post(`/transaction/${n.id}/rollback`, void 0, r), (i) => this.httpErrorHandler(i));
          A.data.extensions?.traces && this.tracingHelper.dispatchEngineSpans(A.data.extensions.traces);
        }
      }
      get hasMaxRestarts() {
        return this.startCount >= wS;
      }
      throwAsyncErrorIfExists(e = false) {
        if (Ws("throwAsyncErrorIfExists", this.startCount, this.hasMaxRestarts), this.lastError && (this.hasMaxRestarts || e)) {
          let r = this.lastError;
          throw this.lastError = void 0, r.isPanic() ? new ut(this.getErrorMessageWithLink(pA(r)), this.clientVersion) : new Be(this.getErrorMessageWithLink(pA(r)), { clientVersion: this.clientVersion });
        }
      }
      getErrorMessageWithLink(e) {
        return Lp({ binaryTarget: this.binaryTarget, title: e, version: this.clientVersion, engineVersion: this.lastVersion, database: this.lastActiveProvider, query: this.lastQuery });
      }
      handleRequestError = async (e) => {
        Ye({ error: e }), this.startPromise && await this.startPromise;
        let r = ["ECONNRESET", "ECONNREFUSED", "UND_ERR_CLOSED", "UND_ERR_SOCKET", "UND_ERR_DESTROYED", "UND_ERR_ABORTED"].includes(e.code);
        if (e instanceof Ne) return { error: e, shouldRetry: false };
        try {
          if (this.throwAsyncErrorIfExists(), this.currentRequestPromise?.isCanceled) this.throwAsyncErrorIfExists();
          else if (r) {
            if (this.globalKillSignalReceived && !this.child?.connected) throw new Be(`The Node.js process already received a ${this.globalKillSignalReceived} signal, therefore the Prisma query engine exited
  and your request can't be processed.
  You probably have some open handle that prevents your process from exiting.
  It could be an open http server or stream that didn't close yet.
  We recommend using the \`wtfnode\` package to debug open handles.`, { clientVersion: this.clientVersion });
            if (this.throwAsyncErrorIfExists(), this.startCount > wS) {
              for (let n = 0; n < 5; n++) await new Promise((A) => setTimeout(A, 50)), this.throwAsyncErrorIfExists(true);
              throw new Error(`Query engine is trying to restart, but can't.
  Please look into the logs or turn on the env var DEBUG=* to debug the constantly restarting query engine.`);
            }
          }
          throw this.throwAsyncErrorIfExists(true), e;
        } catch (n) {
          return { error: n, shouldRetry: r };
        }
      };
      async metrics({ format: e, globalLabels: r }) {
        await this.start();
        let n = e === "json";
        return (await this.connection.post(`/metrics?format=${encodeURIComponent(e)}`, JSON.stringify(r), null, n)).data;
      }
      httpErrorHandler(e) {
        let r = e.data, n = r.extensions?.traces;
        throw n && this.tracingHelper.dispatchEngineSpans(n), new Ne(r.message, { code: r.error_code, clientVersion: this.clientVersion, meta: r.meta });
      }
      applyPendingMigrations() {
        throw new Error("Method not implemented.");
      }
    };
    function _s(t, e = false) {
      process.once(t, async () => {
        for (let r of Rl) await r.emitExit(), r.kill(t);
        Rl.splice(0, Rl.length), e && process.listenerCount(t) === 0 && process.exit();
      });
    }
    var RS = false;
    function zW() {
      RS || (_s("beforeExit"), _s("exit"), _s("SIGINT", true), _s("SIGUSR2", true), _s("SIGTERM", true), RS = true);
    }
    function e_(t) {
      return new Promise((e) => {
        t.once("exit", e), t.kill();
      });
    }
    function FS(t, e) {
      throw new Error(e);
    }
    function t_(t) {
      return t !== null && typeof t == "object" && typeof t.$type == "string";
    }
    function r_(t, e) {
      let r = {};
      for (let n of Object.keys(t)) r[n] = e(t[n], n);
      return r;
    }
    function ai(t) {
      return t === null ? t : Array.isArray(t) ? t.map(ai) : typeof t == "object" ? t_(t) ? n_(t) : t.constructor !== null && t.constructor.name !== "Object" ? t : r_(t, ai) : t;
    }
    function n_({ $type: t, value: e }) {
      switch (t) {
        case "BigInt":
          return BigInt(e);
        case "Bytes": {
          let { buffer: r, byteOffset: n, byteLength: A } = Buffer.from(e, "base64");
          return new Uint8Array(r, n, A);
        }
        case "DateTime":
          return new Date(e);
        case "Decimal":
          return new or(e);
        case "Json":
          return JSON.parse(e);
        default:
          FS(e, "Unknown tagged value");
      }
    }
    var TS = "6.14.0";
    function ci({ inlineDatasources: t, overrideDatasources: e, env: r, clientVersion: n }) {
      let A, i = Object.keys(t)[0], s = t[i]?.url, o = e[i]?.url;
      if (i === void 0 ? A = void 0 : o ? A = o : s?.value ? A = s.value : s?.fromEnvVar && (A = r[s.fromEnvVar]), s?.fromEnvVar !== void 0 && A === void 0) throw new Z(`error: Environment variable not found: ${s.fromEnvVar}.`, n);
      if (A === void 0) throw new Z("error: Missing URL environment variable, value, or override.", n);
      return A;
    }
    var Sl = class extends Error {
      clientVersion;
      cause;
      constructor(e, r) {
        super(e), this.clientVersion = r.clientVersion, this.cause = r.cause;
      }
      get [Symbol.toStringTag]() {
        return this.name;
      }
    };
    var ze = class extends Sl {
      isRetryable;
      constructor(e, r) {
        super(e, r), this.isRetryable = r.isRetryable ?? true;
      }
    };
    function _(t, e) {
      return { ...t, isRetryable: e };
    }
    var Gn = class extends ze {
      name = "InvalidDatasourceError";
      code = "P6001";
      constructor(e, r) {
        super(e, _(r, false));
      }
    };
    M(Gn, "InvalidDatasourceError");
    function xS(t) {
      let e = { clientVersion: t.clientVersion }, r = Object.keys(t.inlineDatasources)[0], n = ci({ inlineDatasources: t.inlineDatasources, overrideDatasources: t.overrideDatasources, clientVersion: t.clientVersion, env: { ...t.env, ...typeof process < "u" ? process.env : {} } }), A;
      try {
        A = new URL(n);
      } catch {
        throw new Gn(`Error validating datasource \`${r}\`: the URL must start with the protocol \`prisma://\``, e);
      }
      let { protocol: i, searchParams: s } = A;
      if (i !== "prisma:" && i !== Po) throw new Gn(`Error validating datasource \`${r}\`: the URL must start with the protocol \`prisma://\` or \`prisma+postgres://\``, e);
      let o = s.get("api_key");
      if (o === null || o.length < 1) throw new Gn(`Error validating datasource \`${r}\`: the URL must contain a valid API key`, e);
      let a = Cu(A) ? "http:" : "https:", c = new URL(A.href.replace(i, a));
      return { apiKey: o, url: c };
    }
    var US = G(vo());
    var bl = class {
      apiKey;
      tracingHelper;
      logLevel;
      logQueries;
      engineHash;
      constructor({ apiKey: e, tracingHelper: r, logLevel: n, logQueries: A, engineHash: i }) {
        this.apiKey = e, this.tracingHelper = r, this.logLevel = n, this.logQueries = A, this.engineHash = i;
      }
      build({ traceparent: e, transactionId: r } = {}) {
        let n = { Accept: "application/json", Authorization: `Bearer ${this.apiKey}`, "Content-Type": "application/json", "Prisma-Engine-Hash": this.engineHash, "Prisma-Engine-Version": US.enginesVersion };
        this.tracingHelper.isEnabled() && (n.traceparent = e ?? this.tracingHelper.getTraceParent()), r && (n["X-Transaction-Id"] = r);
        let A = this.#e();
        return A.length > 0 && (n["X-Capture-Telemetry"] = A.join(", ")), n;
      }
      #e() {
        let e = [];
        return this.tracingHelper.isEnabled() && e.push("tracing"), this.logLevel && e.push(this.logLevel), this.logQueries && e.push("query"), e;
      }
    };
    function i_(t) {
      return t[0] * 1e3 + t[1] / 1e6;
    }
    function Yh(t) {
      return new Date(i_(t));
    }
    var li = class extends ze {
      name = "ForcedRetryError";
      code = "P5001";
      constructor(e) {
        super("This request must be retried", _(e, true));
      }
    };
    M(li, "ForcedRetryError");
    var On = class extends ze {
      name = "NotImplementedYetError";
      code = "P5004";
      constructor(e, r) {
        super(e, _(r, false));
      }
    };
    M(On, "NotImplementedYetError");
    var oe = class extends ze {
      response;
      constructor(e, r) {
        super(e, r), this.response = r.response;
        let n = this.response.headers.get("prisma-request-id");
        if (n) {
          let A = `(The request id was: ${n})`;
          this.message = this.message + " " + A;
        }
      }
    };
    var Vn = class extends oe {
      name = "SchemaMissingError";
      code = "P5005";
      constructor(e) {
        super("Schema needs to be uploaded", _(e, true));
      }
    };
    M(Vn, "SchemaMissingError");
    var Gh = "This request could not be understood by the server";
    var Zs = class extends oe {
      name = "BadRequestError";
      code = "P5000";
      constructor(e, r, n) {
        super(r || Gh, _(e, false)), n && (this.code = n);
      }
    };
    M(Zs, "BadRequestError");
    var Xs = class extends oe {
      name = "HealthcheckTimeoutError";
      code = "P5013";
      logs;
      constructor(e, r) {
        super("Engine not started: healthcheck timeout", _(e, true)), this.logs = r;
      }
    };
    M(Xs, "HealthcheckTimeoutError");
    var Ks = class extends oe {
      name = "EngineStartupError";
      code = "P5014";
      logs;
      constructor(e, r, n) {
        super(r, _(e, true)), this.logs = n;
      }
    };
    M(Ks, "EngineStartupError");
    var $s = class extends oe {
      name = "EngineVersionNotSupportedError";
      code = "P5012";
      constructor(e) {
        super("Engine version is not supported", _(e, false));
      }
    };
    M($s, "EngineVersionNotSupportedError");
    var Oh = "Request timed out";
    var zs = class extends oe {
      name = "GatewayTimeoutError";
      code = "P5009";
      constructor(e, r = Oh) {
        super(r, _(e, false));
      }
    };
    M(zs, "GatewayTimeoutError");
    var s_ = "Interactive transaction error";
    var eo = class extends oe {
      name = "InteractiveTransactionError";
      code = "P5015";
      constructor(e, r = s_) {
        super(r, _(e, false));
      }
    };
    M(eo, "InteractiveTransactionError");
    var o_ = "Request parameters are invalid";
    var to = class extends oe {
      name = "InvalidRequestError";
      code = "P5011";
      constructor(e, r = o_) {
        super(r, _(e, false));
      }
    };
    M(to, "InvalidRequestError");
    var Vh = "Requested resource does not exist";
    var ro = class extends oe {
      name = "NotFoundError";
      code = "P5003";
      constructor(e, r = Vh) {
        super(r, _(e, false));
      }
    };
    M(ro, "NotFoundError");
    var Hh = "Unknown server error";
    var ui = class extends oe {
      name = "ServerError";
      code = "P5006";
      logs;
      constructor(e, r, n) {
        super(r || Hh, _(e, true)), this.logs = n;
      }
    };
    M(ui, "ServerError");
    var qh = "Unauthorized, check your connection string";
    var no = class extends oe {
      name = "UnauthorizedError";
      code = "P5007";
      constructor(e, r = qh) {
        super(r, _(e, false));
      }
    };
    M(no, "UnauthorizedError");
    var Jh = "Usage exceeded, retry again later";
    var Ao = class extends oe {
      name = "UsageExceededError";
      code = "P5008";
      constructor(e, r = Jh) {
        super(r, _(e, true));
      }
    };
    M(Ao, "UsageExceededError");
    async function a_(t) {
      let e;
      try {
        e = await t.text();
      } catch {
        return { type: "EmptyError" };
      }
      try {
        let r = JSON.parse(e);
        if (typeof r == "string") switch (r) {
          case "InternalDataProxyError":
            return { type: "DataProxyError", body: r };
          default:
            return { type: "UnknownTextError", body: r };
        }
        if (typeof r == "object" && r !== null) {
          if ("is_panic" in r && "message" in r && "error_code" in r) return { type: "QueryEngineError", body: r };
          if ("EngineNotStarted" in r || "InteractiveTransactionMisrouted" in r || "InvalidRequestError" in r) {
            let n = Object.values(r)[0].reason;
            return typeof n == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n) ? { type: "UnknownJsonError", body: r } : { type: "DataProxyError", body: r };
          }
        }
        return { type: "UnknownJsonError", body: r };
      } catch {
        return e === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: e };
      }
    }
    async function io(t, e) {
      if (t.ok) return;
      let r = { clientVersion: e, response: t }, n = await a_(t);
      if (n.type === "QueryEngineError") throw new Ne(n.body.message, { code: n.body.error_code, clientVersion: e });
      if (n.type === "DataProxyError") {
        if (n.body === "InternalDataProxyError") throw new ui(r, "Internal Data Proxy error");
        if ("EngineNotStarted" in n.body) {
          if (n.body.EngineNotStarted.reason === "SchemaMissing") return new Vn(r);
          if (n.body.EngineNotStarted.reason === "EngineVersionNotSupported") throw new $s(r);
          if ("EngineStartupError" in n.body.EngineNotStarted.reason) {
            let { msg: A, logs: i } = n.body.EngineNotStarted.reason.EngineStartupError;
            throw new Ks(r, A, i);
          }
          if ("KnownEngineStartupError" in n.body.EngineNotStarted.reason) {
            let { msg: A, error_code: i } = n.body.EngineNotStarted.reason.KnownEngineStartupError;
            throw new Z(A, e, i);
          }
          if ("HealthcheckTimeout" in n.body.EngineNotStarted.reason) {
            let { logs: A } = n.body.EngineNotStarted.reason.HealthcheckTimeout;
            throw new Xs(r, A);
          }
        }
        if ("InteractiveTransactionMisrouted" in n.body) {
          let A = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
          throw new eo(r, A[n.body.InteractiveTransactionMisrouted.reason]);
        }
        if ("InvalidRequestError" in n.body) throw new to(r, n.body.InvalidRequestError.reason);
      }
      if (t.status === 401 || t.status === 403) throw new no(r, gi(qh, n));
      if (t.status === 404) return new ro(r, gi(Vh, n));
      if (t.status === 429) throw new Ao(r, gi(Jh, n));
      if (t.status === 504) throw new zs(r, gi(Oh, n));
      if (t.status >= 500) throw new ui(r, gi(Hh, n));
      if (t.status >= 400) throw new Zs(r, gi(Gh, n));
    }
    function gi(t, e) {
      return e.type === "EmptyError" ? t : `${t}: ${JSON.stringify(e)}`;
    }
    function kS(t) {
      let e = Math.pow(2, t) * 50, r = Math.ceil(Math.random() * e) - Math.ceil(e / 2), n = e + r;
      return new Promise((A) => setTimeout(() => A(n), n));
    }
    var Dr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    function MS(t) {
      let e = new TextEncoder().encode(t), r = "", n = e.byteLength, A = n % 3, i = n - A, s, o, a, c, l;
      for (let u = 0; u < i; u = u + 3) l = e[u] << 16 | e[u + 1] << 8 | e[u + 2], s = (l & 16515072) >> 18, o = (l & 258048) >> 12, a = (l & 4032) >> 6, c = l & 63, r += Dr[s] + Dr[o] + Dr[a] + Dr[c];
      return A == 1 ? (l = e[i], s = (l & 252) >> 2, o = (l & 3) << 4, r += Dr[s] + Dr[o] + "==") : A == 2 && (l = e[i] << 8 | e[i + 1], s = (l & 64512) >> 10, o = (l & 1008) >> 4, a = (l & 15) << 2, r += Dr[s] + Dr[o] + Dr[a] + "="), r;
    }
    function LS(t) {
      if (!!t.generator?.previewFeatures.some((r) => r.toLowerCase().includes("metrics"))) throw new Z("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", t.clientVersion);
    }
    var vS = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "6.14.0-25.717184b7b35ea05dfa71a3236b7af656013e1e49", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*" };
    var so = class extends ze {
      name = "RequestError";
      code = "P5010";
      constructor(e, r) {
        super(`Cannot fetch data from service:
${e}`, _(r, true));
      }
    };
    M(so, "RequestError");
    async function Hn(t, e, r = (n) => n) {
      let { clientVersion: n, ...A } = e, i = r(fetch);
      try {
        return await i(t, A);
      } catch (s) {
        let o = s.message ?? "Unknown error";
        throw new so(o, { clientVersion: n, cause: s });
      }
    }
    var l_ = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
    var PS = ce("prisma:client:dataproxyEngine");
    async function u_(t, e) {
      let r = vS["@prisma/engines-version"], n = e.clientVersion ?? "unknown";
      if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION || globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION) return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION || globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
      if (t.includes("accelerate") && n !== "0.0.0" && n !== "in-memory") return n;
      let [A, i] = n?.split("-") ?? [];
      if (i === void 0 && l_.test(A)) return A;
      if (i !== void 0 || n === "0.0.0" || n === "in-memory") {
        let [s] = r.split("-") ?? [], [o, a, c] = s.split("."), l = g_(`<=${o}.${a}.${c}`), u = await Hn(l, { clientVersion: n });
        if (!u.ok) throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${u.status} ${u.statusText}, response body: ${await u.text() || "<empty body>"}`);
        let g = await u.text();
        PS("length of body fetched from unpkg.com", g.length);
        let E;
        try {
          E = JSON.parse(g);
        } catch (h) {
          throw console.error("JSON.parse error: body fetched from unpkg.com: ", g), h;
        }
        return E.version;
      }
      throw new On("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n });
    }
    async function YS(t, e) {
      let r = await u_(t, e);
      return PS("version", r), r;
    }
    function g_(t) {
      return encodeURI(`https://unpkg.com/prisma@${t}/package.json`);
    }
    var GS = 3;
    var oo = ce("prisma:client:dataproxyEngine");
    var ao = class {
      name = "DataProxyEngine";
      inlineSchema;
      inlineSchemaHash;
      inlineDatasources;
      config;
      logEmitter;
      env;
      clientVersion;
      engineHash;
      tracingHelper;
      remoteClientVersion;
      host;
      headerBuilder;
      startPromise;
      protocol;
      constructor(e) {
        LS(e), this.config = e, this.env = e.env, this.inlineSchema = MS(e.inlineSchema), this.inlineDatasources = e.inlineDatasources, this.inlineSchemaHash = e.inlineSchemaHash, this.clientVersion = e.clientVersion, this.engineHash = e.engineVersion, this.logEmitter = e.logEmitter, this.tracingHelper = e.tracingHelper;
      }
      apiKey() {
        return this.headerBuilder.apiKey;
      }
      version() {
        return this.engineHash;
      }
      async start() {
        this.startPromise !== void 0 && await this.startPromise, this.startPromise = (async () => {
          let { apiKey: e, url: r } = this.getURLAndAPIKey();
          this.host = r.host, this.protocol = r.protocol, this.headerBuilder = new bl({ apiKey: e, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel ?? "error", logQueries: this.config.logQueries, engineHash: this.engineHash }), this.remoteClientVersion = await YS(this.host, this.config), oo("host", this.host), oo("protocol", this.protocol);
        })(), await this.startPromise;
      }
      async stop() {
      }
      propagateResponseExtensions(e) {
        e?.logs?.length && e.logs.forEach((r) => {
          switch (r.level) {
            case "debug":
            case "trace":
              oo(r);
              break;
            case "error":
            case "warn":
            case "info": {
              this.logEmitter.emit(r.level, { timestamp: Yh(r.timestamp), message: r.attributes.message ?? "", target: r.target });
              break;
            }
            case "query": {
              this.logEmitter.emit("query", { query: r.attributes.query ?? "", timestamp: Yh(r.timestamp), duration: r.attributes.duration_ms ?? 0, params: r.attributes.params ?? "", target: r.target });
              break;
            }
            default:
              r.level;
          }
        }), e?.traces?.length && this.tracingHelper.dispatchEngineSpans(e.traces);
      }
      onBeforeExit() {
        throw new Error('"beforeExit" hook is not applicable to the remote query engine');
      }
      async url(e) {
        return await this.start(), `${this.protocol}//${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${e}`;
      }
      async uploadSchema() {
        let e = { name: "schemaUpload", internal: true };
        return this.tracingHelper.runInChildSpan(e, async () => {
          let r = await Hn(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
          r.ok || oo("schema response status", r.status);
          let n = await io(r, this.clientVersion);
          if (n) throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${n.message}`, timestamp: /* @__PURE__ */ new Date(), target: "" }), n;
          this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})`, timestamp: /* @__PURE__ */ new Date(), target: "" });
        });
      }
      request(e, { traceparent: r, interactiveTransaction: n, customDataProxyFetch: A }) {
        return this.requestInternal({ body: e, traceparent: r, interactiveTransaction: n, customDataProxyFetch: A });
      }
      async requestBatch(e, { traceparent: r, transaction: n, customDataProxyFetch: A }) {
        let i = n?.kind === "itx" ? n.options : void 0, s = CA(e, n);
        return (await this.requestInternal({ body: s, customDataProxyFetch: A, interactiveTransaction: i, traceparent: r })).map((a) => (a.extensions && this.propagateResponseExtensions(a.extensions), "errors" in a ? this.convertProtocolErrorsToClientError(a.errors) : a));
      }
      requestInternal({ body: e, traceparent: r, customDataProxyFetch: n, interactiveTransaction: A }) {
        return this.withRetry({ actionGerund: "querying", callback: async ({ logHttpCall: i }) => {
          let s = A ? `${A.payload.endpoint}/graphql` : await this.url("graphql");
          i(s);
          let o = await Hn(s, { method: "POST", headers: this.headerBuilder.build({ traceparent: r, transactionId: A?.id }), body: JSON.stringify(e), clientVersion: this.clientVersion }, n);
          o.ok || oo("graphql response status", o.status), await this.handleError(await io(o, this.clientVersion));
          let a = await o.json();
          if (a.extensions && this.propagateResponseExtensions(a.extensions), "errors" in a) throw this.convertProtocolErrorsToClientError(a.errors);
          return "batchResult" in a ? a.batchResult : a;
        } });
      }
      async transaction(e, r, n) {
        let A = { start: "starting", commit: "committing", rollback: "rolling back" };
        return this.withRetry({ actionGerund: `${A[e]} transaction`, callback: async ({ logHttpCall: i }) => {
          if (e === "start") {
            let s = JSON.stringify({ max_wait: n.maxWait, timeout: n.timeout, isolation_level: n.isolationLevel }), o = await this.url("transaction/start");
            i(o);
            let a = await Hn(o, { method: "POST", headers: this.headerBuilder.build({ traceparent: r.traceparent }), body: s, clientVersion: this.clientVersion });
            await this.handleError(await io(a, this.clientVersion));
            let c = await a.json(), { extensions: l } = c;
            l && this.propagateResponseExtensions(l);
            let u = c.id, g = c["data-proxy"].endpoint;
            return { id: u, payload: { endpoint: g } };
          } else {
            let s = `${n.payload.endpoint}/${e}`;
            i(s);
            let o = await Hn(s, { method: "POST", headers: this.headerBuilder.build({ traceparent: r.traceparent }), clientVersion: this.clientVersion });
            await this.handleError(await io(o, this.clientVersion));
            let a = await o.json(), { extensions: c } = a;
            c && this.propagateResponseExtensions(c);
            return;
          }
        } });
      }
      getURLAndAPIKey() {
        return xS({ clientVersion: this.clientVersion, env: this.env, inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources });
      }
      metrics() {
        throw new On("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
      }
      async withRetry(e) {
        for (let r = 0; ; r++) {
          let n = (A) => {
            this.logEmitter.emit("info", { message: `Calling ${A} (n=${r})`, timestamp: /* @__PURE__ */ new Date(), target: "" });
          };
          try {
            return await e.callback({ logHttpCall: n });
          } catch (A) {
            if (!(A instanceof ze) || !A.isRetryable) throw A;
            if (r >= GS) throw A instanceof li ? A.cause : A;
            this.logEmitter.emit("warn", { message: `Attempt ${r + 1}/${GS} failed for ${e.actionGerund}: ${A.message ?? "(unknown)"}`, timestamp: /* @__PURE__ */ new Date(), target: "" });
            let i = await kS(r);
            this.logEmitter.emit("warn", { message: `Retrying after ${i}ms`, timestamp: /* @__PURE__ */ new Date(), target: "" });
          }
        }
      }
      async handleError(e) {
        if (e instanceof Vn) throw await this.uploadSchema(), new li({ clientVersion: this.clientVersion, cause: e });
        if (e) throw e;
      }
      convertProtocolErrorsToClientError(e) {
        return e.length === 1 ? Yr(e[0], this.config.clientVersion, this.config.activeProvider) : new Be(JSON.stringify(e), { clientVersion: this.config.clientVersion });
      }
      applyPendingMigrations() {
        throw new Error("Method not implemented.");
      }
    };
    function OS({ url: t, adapter: e, copyEngine: r, targetBuildType: n }) {
      let A = [], i = [], s = (f) => {
        A.push({ _tag: "warning", value: f });
      }, o = (f) => {
        let p = f.join(`
`);
        i.push({ _tag: "error", value: p });
      }, a = !!t?.startsWith("prisma://"), c = Yo(t), l = !!e, u = a || c;
      !l && r && u && s(["recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)"]);
      let g = u || !r;
      l && (g || n === "edge") && (n === "edge" ? o(["Prisma Client was configured to use the `adapter` option but it was imported via its `/edge` endpoint.", "Please either remove the `/edge` endpoint or remove the `adapter` from the Prisma Client constructor."]) : r ? a && o(["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.", "Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."]) : o(["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.", "Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."]));
      let E = { accelerate: g, ppg: c, driverAdapters: l };
      function h(f) {
        return f.length > 0;
      }
      return h(i) ? { ok: false, diagnostics: { warnings: A, errors: i }, isUsing: E } : { ok: true, diagnostics: { warnings: A }, isUsing: E };
    }
    function VS({ copyEngine: t = true }, e) {
      let r;
      try {
        r = ci({ inlineDatasources: e.inlineDatasources, overrideDatasources: e.overrideDatasources, env: { ...e.env, ...process.env }, clientVersion: e.clientVersion });
      } catch {
      }
      let { ok: n, isUsing: A, diagnostics: i } = OS({ url: r, adapter: e.adapter, copyEngine: t, targetBuildType: "binary" });
      for (let u of i.warnings) Fi(...u.value);
      if (!n) {
        let u = i.errors[0];
        throw new Ue(u.value, { clientVersion: e.clientVersion });
      }
      let s = tA(e.generator), o = s === "library", a = s === "binary", c = s === "client", l = (A.accelerate || A.ppg) && !A.driverAdapters;
      return A.accelerate ? new ao(e) : (A.driverAdapters, a ? new oi(e) : (A.accelerate, new oi(e)));
    }
    function Nl({ generator: t }) {
      return t?.previewFeatures ?? [];
    }
    var HS = (t) => ({ command: t });
    var qS = (t) => t.strings.reduce((e, r, n) => `${e}@P${n}${r}`);
    function Ei(t) {
      try {
        return JS(t, "fast");
      } catch {
        return JS(t, "slow");
      }
    }
    function JS(t, e) {
      return JSON.stringify(t.map((r) => _S(r, e)));
    }
    function _S(t, e) {
      if (Array.isArray(t)) return t.map((r) => _S(r, e));
      if (typeof t == "bigint") return { prisma__type: "bigint", prisma__value: t.toString() };
      if (nA(t)) return { prisma__type: "date", prisma__value: t.toJSON() };
      if (ar.isDecimal(t)) return { prisma__type: "decimal", prisma__value: t.toJSON() };
      if (Buffer.isBuffer(t)) return { prisma__type: "bytes", prisma__value: t.toString("base64") };
      if (E_(t)) return { prisma__type: "bytes", prisma__value: Buffer.from(t).toString("base64") };
      if (ArrayBuffer.isView(t)) {
        let { buffer: r, byteOffset: n, byteLength: A } = t;
        return { prisma__type: "bytes", prisma__value: Buffer.from(r, n, A).toString("base64") };
      }
      return typeof t == "object" && e === "slow" ? jS(t) : t;
    }
    function E_(t) {
      return t instanceof ArrayBuffer || t instanceof SharedArrayBuffer ? true : typeof t == "object" && t !== null ? t[Symbol.toStringTag] === "ArrayBuffer" || t[Symbol.toStringTag] === "SharedArrayBuffer" : false;
    }
    function jS(t) {
      if (typeof t != "object" || t === null) return t;
      if (typeof t.toJSON == "function") return t.toJSON();
      if (Array.isArray(t)) return t.map(WS);
      let e = {};
      for (let r of Object.keys(t)) e[r] = WS(t[r]);
      return e;
    }
    function WS(t) {
      return typeof t == "bigint" ? t.toString() : jS(t);
    }
    var d_ = /^(\s*alter\s)/i;
    var ZS = ce("prisma:client");
    function Wh(t, e, r, n) {
      if (!(t !== "postgresql" && t !== "cockroachdb") && r.length > 0 && d_.exec(e)) throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
    }
    var _h = ({ clientMethod: t, activeProvider: e }) => (r) => {
      let n = "", A;
      if (Ca(r)) n = r.sql, A = { values: Ei(r.values), __prismaRawParameters__: true };
      else if (Array.isArray(r)) {
        let [i, ...s] = r;
        n = i, A = { values: Ei(s || []), __prismaRawParameters__: true };
      } else switch (e) {
        case "sqlite":
        case "mysql": {
          n = r.sql, A = { values: Ei(r.values), __prismaRawParameters__: true };
          break;
        }
        case "cockroachdb":
        case "postgresql":
        case "postgres": {
          n = r.text, A = { values: Ei(r.values), __prismaRawParameters__: true };
          break;
        }
        case "sqlserver": {
          n = qS(r), A = { values: Ei(r.values), __prismaRawParameters__: true };
          break;
        }
        default:
          throw new Error(`The ${e} provider does not support ${t}`);
      }
      return A?.values ? ZS(`prisma.${t}(${n}, ${A.values})`) : ZS(`prisma.${t}(${n})`), { query: n, parameters: A };
    };
    var XS = { requestArgsToMiddlewareArgs(t) {
      return [t.strings, ...t.values];
    }, middlewareArgsToRequestArgs(t) {
      let [e, ...r] = t;
      return new _e(e, r);
    } };
    var KS = { requestArgsToMiddlewareArgs(t) {
      return [t];
    }, middlewareArgsToRequestArgs(t) {
      return t[0];
    } };
    function jh(t) {
      return function(r, n) {
        let A, i = (s = t) => {
          try {
            return s === void 0 || s?.kind === "itx" ? A ??= $S(r(s)) : $S(r(s));
          } catch (o) {
            return Promise.reject(o);
          }
        };
        return { get spec() {
          return n;
        }, then(s, o) {
          return i().then(s, o);
        }, catch(s) {
          return i().catch(s);
        }, finally(s) {
          return i().finally(s);
        }, requestTransaction(s) {
          let o = i(s);
          return o.requestTransaction ? o.requestTransaction(s) : o;
        }, [Symbol.toStringTag]: "PrismaPromise" };
      };
    }
    function $S(t) {
      return typeof t.then == "function" ? t : Promise.resolve(t);
    }
    var h_ = uu.split(".")[0];
    var f_ = { isEnabled() {
      return false;
    }, getTraceParent() {
      return "00-10-10-00";
    }, dispatchEngineSpans() {
    }, getActiveContext() {
    }, runInChildSpan(t, e) {
      return e();
    } };
    var Zh = class {
      isEnabled() {
        return this.getGlobalTracingHelper().isEnabled();
      }
      getTraceParent(e) {
        return this.getGlobalTracingHelper().getTraceParent(e);
      }
      dispatchEngineSpans(e) {
        return this.getGlobalTracingHelper().dispatchEngineSpans(e);
      }
      getActiveContext() {
        return this.getGlobalTracingHelper().getActiveContext();
      }
      runInChildSpan(e, r) {
        return this.getGlobalTracingHelper().runInChildSpan(e, r);
      }
      getGlobalTracingHelper() {
        let e = globalThis[`V${h_}_PRISMA_INSTRUMENTATION`], r = globalThis.PRISMA_INSTRUMENTATION;
        return e?.helper ?? r?.helper ?? f_;
      }
    };
    function zS() {
      return new Zh();
    }
    function eb(t, e = () => {
    }) {
      let r, n = new Promise((A) => r = A);
      return { then(A) {
        return --t === 0 && r(e()), A?.(n);
      } };
    }
    function tb(t) {
      return typeof t == "string" ? t : t.reduce((e, r) => {
        let n = typeof r == "string" ? r : r.level;
        return n === "query" ? e : e && (r === "info" || e === "info") ? "info" : n;
      }, void 0);
    }
    var nb = G(yu());
    function Fl(t) {
      return typeof t.batchRequestIdx == "number";
    }
    function rb(t) {
      if (t.action !== "findUnique" && t.action !== "findUniqueOrThrow") return;
      let e = [];
      return t.modelName && e.push(t.modelName), t.query.arguments && e.push(Xh(t.query.arguments)), e.push(Xh(t.query.selection)), e.join("");
    }
    function Xh(t) {
      return `(${Object.keys(t).sort().map((r) => {
        let n = t[r];
        return typeof n == "object" && n !== null ? `(${r} ${Xh(n)})` : r;
      }).join(" ")})`;
    }
    var Q_ = { aggregate: false, aggregateRaw: false, createMany: true, createManyAndReturn: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateManyAndReturn: true, updateOne: true, upsertOne: true };
    function Kh(t) {
      return Q_[t];
    }
    var Tl = class {
      constructor(e) {
        this.options = e;
        this.batches = {};
      }
      batches;
      tickActive = false;
      request(e) {
        let r = this.options.batchBy(e);
        return r ? (this.batches[r] || (this.batches[r] = [], this.tickActive || (this.tickActive = true, process.nextTick(() => {
          this.dispatchBatches(), this.tickActive = false;
        }))), new Promise((n, A) => {
          this.batches[r].push({ request: e, resolve: n, reject: A });
        })) : this.options.singleLoader(e);
      }
      dispatchBatches() {
        for (let e in this.batches) {
          let r = this.batches[e];
          delete this.batches[e], r.length === 1 ? this.options.singleLoader(r[0].request).then((n) => {
            n instanceof Error ? r[0].reject(n) : r[0].resolve(n);
          }).catch((n) => {
            r[0].reject(n);
          }) : (r.sort((n, A) => this.options.batchOrder(n.request, A.request)), this.options.batchLoader(r.map((n) => n.request)).then((n) => {
            if (n instanceof Error) for (let A = 0; A < r.length; A++) r[A].reject(n);
            else for (let A = 0; A < r.length; A++) {
              let i = n[A];
              i instanceof Error ? r[A].reject(i) : r[A].resolve(i);
            }
          }).catch((n) => {
            for (let A = 0; A < r.length; A++) r[A].reject(n);
          }));
        }
      }
      get [Symbol.toStringTag]() {
        return "DataLoader";
      }
    };
    function qn(t, e) {
      if (e === null) return e;
      switch (t) {
        case "bigint":
          return BigInt(e);
        case "bytes": {
          let { buffer: r, byteOffset: n, byteLength: A } = Buffer.from(e, "base64");
          return new Uint8Array(r, n, A);
        }
        case "decimal":
          return new ar(e);
        case "datetime":
        case "date":
          return new Date(e);
        case "time":
          return /* @__PURE__ */ new Date(`1970-01-01T${e}Z`);
        case "bigint-array":
          return e.map((r) => qn("bigint", r));
        case "bytes-array":
          return e.map((r) => qn("bytes", r));
        case "decimal-array":
          return e.map((r) => qn("decimal", r));
        case "datetime-array":
          return e.map((r) => qn("datetime", r));
        case "date-array":
          return e.map((r) => qn("date", r));
        case "time-array":
          return e.map((r) => qn("time", r));
        default:
          return e;
      }
    }
    function xl(t) {
      let e = [], r = C_(t);
      for (let n = 0; n < t.rows.length; n++) {
        let A = t.rows[n], i = { ...r };
        for (let s = 0; s < A.length; s++) i[t.columns[s]] = qn(t.types[s], A[s]);
        e.push(i);
      }
      return e;
    }
    function C_(t) {
      let e = {};
      for (let r = 0; r < t.columns.length; r++) e[t.columns[r]] = null;
      return e;
    }
    var I_ = ce("prisma:client:request_handler");
    var Ul = class {
      client;
      dataloader;
      logEmitter;
      constructor(e, r) {
        this.logEmitter = r, this.client = e, this.dataloader = new Tl({ batchLoader: Ap(async ({ requests: n, customDataProxyFetch: A }) => {
          let { transaction: i, otelParentCtx: s } = n[0], o = n.map((u) => u.protocolQuery), a = this.client._tracingHelper.getTraceParent(s), c = n.some((u) => Kh(u.protocolQuery.action));
          return (await this.client._engine.requestBatch(o, { traceparent: a, transaction: p_(i), containsWrite: c, customDataProxyFetch: A })).map((u, g) => {
            if (u instanceof Error) return u;
            try {
              return this.mapQueryEngineResult(n[g], u);
            } catch (E) {
              return E;
            }
          });
        }), singleLoader: async (n) => {
          let A = n.transaction?.kind === "itx" ? Ab(n.transaction) : void 0, i = await this.client._engine.request(n.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: A, isWrite: Kh(n.protocolQuery.action), customDataProxyFetch: n.customDataProxyFetch });
          return this.mapQueryEngineResult(n, i);
        }, batchBy: (n) => n.transaction?.id ? `transaction-${n.transaction.id}` : rb(n.protocolQuery), batchOrder(n, A) {
          return n.transaction?.kind === "batch" && A.transaction?.kind === "batch" ? n.transaction.index - A.transaction.index : 0;
        } });
      }
      async request(e) {
        try {
          return await this.dataloader.request(e);
        } catch (r) {
          let { clientMethod: n, callsite: A, transaction: i, args: s, modelName: o } = e;
          this.handleAndLogRequestError({ error: r, clientMethod: n, callsite: A, transaction: i, args: s, modelName: o, globalOmit: e.globalOmit });
        }
      }
      mapQueryEngineResult({ dataPath: e, unpacker: r }, n) {
        let A = n?.data, i = this.unpack(A, e, r);
        return process.env.PRISMA_CLIENT_GET_TIME ? { data: i } : i;
      }
      handleAndLogRequestError(e) {
        try {
          this.handleRequestError(e);
        } catch (r) {
          throw this.logEmitter && this.logEmitter.emit("error", { message: r.message, target: e.clientMethod, timestamp: /* @__PURE__ */ new Date() }), r;
        }
      }
      handleRequestError({ error: e, clientMethod: r, callsite: n, transaction: A, args: i, modelName: s, globalOmit: o }) {
        if (I_(e), B_(e, A)) throw e;
        if (e instanceof Ne && m_(e)) {
          let c = ib(e.meta);
          ga({ args: i, errors: [c], callsite: n, errorFormat: this.client._errorFormat, originalMethod: r, clientVersion: this.client._clientVersion, globalOmit: o });
        }
        let a = e.message;
        if (n && (a = ra({ callsite: n, originalMethod: r, isPanic: e.isPanic, showColors: this.client._errorFormat === "pretty", message: a })), a = this.sanitizeMessage(a), e.code) {
          let c = s ? { modelName: s, ...e.meta } : e.meta;
          throw new Ne(a, { code: e.code, clientVersion: this.client._clientVersion, meta: c, batchRequestIdx: e.batchRequestIdx });
        } else {
          if (e.isPanic) throw new ut(a, this.client._clientVersion);
          if (e instanceof Be) throw new Be(a, { clientVersion: this.client._clientVersion, batchRequestIdx: e.batchRequestIdx });
          if (e instanceof Z) throw new Z(a, this.client._clientVersion);
          if (e instanceof ut) throw new ut(a, this.client._clientVersion);
        }
        throw e.clientVersion = this.client._clientVersion, e;
      }
      sanitizeMessage(e) {
        return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, nb.default)(e) : e;
      }
      unpack(e, r, n) {
        if (!e || (e.data && (e = e.data), !e)) return e;
        let A = Object.keys(e)[0], i = Object.values(e)[0], s = r.filter((c) => c !== "select" && c !== "include"), o = Xu(i, s), a = A === "queryRaw" ? xl(o) : ai(o);
        return n ? n(a) : a;
      }
      get [Symbol.toStringTag]() {
        return "RequestHandler";
      }
    };
    function p_(t) {
      if (t) {
        if (t.kind === "batch") return { kind: "batch", options: { isolationLevel: t.isolationLevel } };
        if (t.kind === "itx") return { kind: "itx", options: Ab(t) };
        ln(t, "Unknown transaction kind");
      }
    }
    function Ab(t) {
      return { id: t.id, payload: t.payload };
    }
    function B_(t, e) {
      return Fl(t) && e?.kind === "batch" && t.batchRequestIdx !== e.index;
    }
    function m_(t) {
      return t.code === "P2009" || t.code === "P2012";
    }
    function ib(t) {
      if (t.kind === "Union") return { kind: "Union", errors: t.errors.map(ib) };
      if (Array.isArray(t.selectionPath)) {
        let [, ...e] = t.selectionPath;
        return { ...t, selectionPath: e };
      }
      return t;
    }
    var sb = TS;
    var ub = G(vu());
    var z2 = class extends Error {
      constructor(e) {
        super(e + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientConstructorValidationError";
      }
    };
    M(z2, "PrismaClientConstructorValidationError");
    var ob = ["datasources", "datasourceUrl", "errorFormat", "adapter", "log", "transactionOptions", "omit", "__internal"];
    var ab = ["pretty", "colorless", "minimal"];
    var cb = ["info", "query", "warn", "error"];
    var y_ = { datasources: (t, { datasourceNames: e }) => {
      if (t) {
        if (typeof t != "object" || Array.isArray(t)) throw new z2(`Invalid value ${JSON.stringify(t)} for "datasources" provided to PrismaClient constructor`);
        for (let [r, n] of Object.entries(t)) {
          if (!e.includes(r)) {
            let A = di(r, e) || ` Available datasources: ${e.join(", ")}`;
            throw new z2(`Unknown datasource ${r} provided to PrismaClient constructor.${A}`);
          }
          if (typeof n != "object" || Array.isArray(n)) throw new z2(`Invalid value ${JSON.stringify(t)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          if (n && typeof n == "object") for (let [A, i] of Object.entries(n)) {
            if (A !== "url") throw new z2(`Invalid value ${JSON.stringify(t)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            if (typeof i != "string") throw new z2(`Invalid value ${JSON.stringify(i)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
        }
      }
    }, adapter: (t, e) => {
      if (!t && tA(e.generator) === "client") throw new z2('Using engine type "client" requires a driver adapter to be provided to PrismaClient constructor.');
      if (t === null) return;
      if (t === void 0) throw new z2('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');
      if (!Nl(e).includes("driverAdapters")) throw new z2('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');
      if (tA(e.generator) === "binary") throw new z2('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.');
    }, datasourceUrl: (t) => {
      if (typeof t < "u" && typeof t != "string") throw new z2(`Invalid value ${JSON.stringify(t)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
    }, errorFormat: (t) => {
      if (t) {
        if (typeof t != "string") throw new z2(`Invalid value ${JSON.stringify(t)} for "errorFormat" provided to PrismaClient constructor.`);
        if (!ab.includes(t)) {
          let e = di(t, ab);
          throw new z2(`Invalid errorFormat ${t} provided to PrismaClient constructor.${e}`);
        }
      }
    }, log: (t) => {
      if (!t) return;
      if (!Array.isArray(t)) throw new z2(`Invalid value ${JSON.stringify(t)} for "log" provided to PrismaClient constructor.`);
      function e(r) {
        if (typeof r == "string" && !cb.includes(r)) {
          let n = di(r, cb);
          throw new z2(`Invalid log level "${r}" provided to PrismaClient constructor.${n}`);
        }
      }
      for (let r of t) {
        e(r);
        let n = { level: e, emit: (A) => {
          let i = ["stdout", "event"];
          if (!i.includes(A)) {
            let s = di(A, i);
            throw new z2(`Invalid value ${JSON.stringify(A)} for "emit" in logLevel provided to PrismaClient constructor.${s}`);
          }
        } };
        if (r && typeof r == "object") for (let [A, i] of Object.entries(r)) if (n[A]) n[A](i);
        else throw new z2(`Invalid property ${A} for "log" provided to PrismaClient constructor`);
      }
    }, transactionOptions: (t) => {
      if (!t) return;
      let e = t.maxWait;
      if (e != null && e <= 0) throw new z2(`Invalid value ${e} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);
      let r = t.timeout;
      if (r != null && r <= 0) throw new z2(`Invalid value ${r} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`);
    }, omit: (t, e) => {
      if (typeof t != "object") throw new z2('"omit" option is expected to be an object.');
      if (t === null) throw new z2('"omit" option can not be `null`');
      let r = [];
      for (let [n, A] of Object.entries(t)) {
        let i = D_(n, e.runtimeDataModel);
        if (!i) {
          r.push({ kind: "UnknownModel", modelKey: n });
          continue;
        }
        for (let [s, o] of Object.entries(A)) {
          let a = i.fields.find((c) => c.name === s);
          if (!a) {
            r.push({ kind: "UnknownField", modelKey: n, fieldName: s });
            continue;
          }
          if (a.relationName) {
            r.push({ kind: "RelationInOmit", modelKey: n, fieldName: s });
            continue;
          }
          typeof o != "boolean" && r.push({ kind: "InvalidFieldValue", modelKey: n, fieldName: s });
        }
      }
      if (r.length > 0) throw new z2(R_(t, r));
    }, __internal: (t) => {
      if (!t) return;
      let e = ["debug", "engine", "configOverride"];
      if (typeof t != "object") throw new z2(`Invalid value ${JSON.stringify(t)} for "__internal" to PrismaClient constructor`);
      for (let [r] of Object.entries(t)) if (!e.includes(r)) {
        let n = di(r, e);
        throw new z2(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n}`);
      }
    } };
    function gb(t, e) {
      for (let [r, n] of Object.entries(t)) {
        if (!ob.includes(r)) {
          let A = di(r, ob);
          throw new z2(`Unknown property ${r} provided to PrismaClient constructor.${A}`);
        }
        y_[r](n, e);
      }
      if (t.datasourceUrl && t.datasources) throw new z2('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
    }
    function di(t, e) {
      if (e.length === 0 || typeof t != "string") return "";
      let r = w_(t, e);
      return r ? ` Did you mean "${r}"?` : "";
    }
    function w_(t, e) {
      if (e.length === 0) return null;
      let r = e.map((A) => ({ value: A, distance: (0, ub.default)(t, A) }));
      r.sort((A, i) => A.distance < i.distance ? -1 : 1);
      let n = r[0];
      return n.distance < 3 ? n.value : null;
    }
    function D_(t, e) {
      return lb(e.models, t) ?? lb(e.types, t);
    }
    function lb(t, e) {
      let r = Object.keys(t).find((n) => Ur(n) === e);
      if (r) return t[r];
    }
    function R_(t, e) {
      let r = dA(t);
      for (let i of e) switch (i.kind) {
        case "UnknownModel":
          r.arguments.getField(i.modelKey)?.markAsError(), r.addErrorMessage(() => `Unknown model name: ${i.modelKey}.`);
          break;
        case "UnknownField":
          r.arguments.getDeepField([i.modelKey, i.fieldName])?.markAsError(), r.addErrorMessage(() => `Model "${i.modelKey}" does not have a field named "${i.fieldName}".`);
          break;
        case "RelationInOmit":
          r.arguments.getDeepField([i.modelKey, i.fieldName])?.markAsError(), r.addErrorMessage(() => 'Relations are already excluded by default and can not be specified in "omit".');
          break;
        case "InvalidFieldValue":
          r.arguments.getDeepFieldValue([i.modelKey, i.fieldName])?.markAsError(), r.addErrorMessage(() => "Omit field option value must be a boolean.");
          break;
      }
      let { message: n, args: A } = ua(r, "colorless");
      return `Error validating "omit" option:

${A}

${n}`;
    }
    function Eb(t) {
      return t.length === 0 ? Promise.resolve([]) : new Promise((e, r) => {
        let n = new Array(t.length), A = null, i = false, s = 0, o = () => {
          i || (s++, s === t.length && (i = true, A ? r(A) : e(n)));
        }, a = (c) => {
          i || (i = true, r(c));
        };
        for (let c = 0; c < t.length; c++) t[c].then((l) => {
          n[c] = l, o();
        }, (l) => {
          if (!Fl(l)) {
            a(l);
            return;
          }
          l.batchRequestIdx === c ? a(l) : (A || (A = l), o());
        });
      });
    }
    var tn = ce("prisma:client");
    typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
    var S_ = { requestArgsToMiddlewareArgs: (t) => t, middlewareArgsToRequestArgs: (t) => t };
    var b_ = /* @__PURE__ */ Symbol.for("prisma.client.transaction.id");
    var N_ = { id: 0, nextId() {
      return ++this.id;
    } };
    function Ib(t) {
      class e {
        _originalClient = this;
        _runtimeDataModel;
        _requestHandler;
        _connectionPromise;
        _disconnectionPromise;
        _engineConfig;
        _accelerateEngineConfig;
        _clientVersion;
        _errorFormat;
        _tracingHelper;
        _previewFeatures;
        _activeProvider;
        _globalOmit;
        _extensions;
        _engine;
        _appliedParent;
        _createPrismaPromise = jh();
        constructor(n) {
          t = n?.__internal?.configOverride?.(t) ?? t, cp(t), n && gb(n, t);
          let A = new Qb.EventEmitter().on("error", () => {
          });
          this._extensions = hA.empty(), this._previewFeatures = Nl(t), this._clientVersion = t.clientVersion ?? sb, this._activeProvider = t.activeProvider, this._globalOmit = n?.omit, this._tracingHelper = zS();
          let i = t.relativeEnvPaths && { rootEnvPath: t.relativeEnvPaths.rootEnvPath && kl.default.resolve(t.dirname, t.relativeEnvPaths.rootEnvPath), schemaEnvPath: t.relativeEnvPaths.schemaEnvPath && kl.default.resolve(t.dirname, t.relativeEnvPaths.schemaEnvPath) }, s;
          if (n?.adapter) {
            s = n.adapter;
            let a = t.activeProvider === "postgresql" || t.activeProvider === "cockroachdb" ? "postgres" : t.activeProvider;
            if (s.provider !== a) throw new Z(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${a}\` specified in the Prisma schema.`, this._clientVersion);
            if (n.datasources || n.datasourceUrl !== void 0) throw new Z("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.", this._clientVersion);
          }
          let o = !s && i && Ni(i, { conflictCheck: "none" }) || t.injectableEdgeEnv?.();
          try {
            let a = n ?? {}, c = a.__internal ?? {}, l = c.debug === true;
            l && ce.enable("prisma:client");
            let u = kl.default.resolve(t.dirname, t.relativePath);
            Cb.default.existsSync(u) || (u = t.dirname), tn("dirname", t.dirname), tn("relativePath", t.relativePath), tn("cwd", u);
            let g = c.engine || {};
            if (a.errorFormat ? this._errorFormat = a.errorFormat : process.env.NODE_ENV === "production" ? this._errorFormat = "minimal" : process.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = t.runtimeDataModel, this._engineConfig = { cwd: u, dirname: t.dirname, enableDebugLogs: l, allowTriggerPanic: g.allowTriggerPanic, prismaPath: g.binaryPath ?? void 0, engineEndpoint: g.endpoint, generator: t.generator, showColors: this._errorFormat === "pretty", logLevel: a.log && tb(a.log), logQueries: a.log && !!(typeof a.log == "string" ? a.log === "query" : a.log.find((E) => typeof E == "string" ? E === "query" : E.level === "query")), env: o?.parsed ?? {}, flags: [], engineWasm: t.engineWasm, compilerWasm: t.compilerWasm, clientVersion: t.clientVersion, engineVersion: t.engineVersion, previewFeatures: this._previewFeatures, activeProvider: t.activeProvider, inlineSchema: t.inlineSchema, overrideDatasources: lp(a, t.datasourceNames), inlineDatasources: t.inlineDatasources, inlineSchemaHash: t.inlineSchemaHash, tracingHelper: this._tracingHelper, transactionOptions: { maxWait: a.transactionOptions?.maxWait ?? 2e3, timeout: a.transactionOptions?.timeout ?? 5e3, isolationLevel: a.transactionOptions?.isolationLevel }, logEmitter: A, isBundled: t.isBundled, adapter: s }, this._accelerateEngineConfig = { ...this._engineConfig, accelerateUtils: { resolveDatasourceUrl: ci, getBatchRequestPayload: CA, prismaGraphQLToJSError: Yr, PrismaClientUnknownRequestError: Be, PrismaClientInitializationError: Z, PrismaClientKnownRequestError: Ne, debug: ce("prisma:client:accelerateEngine"), engineVersion: hb.version, clientVersion: t.clientVersion } }, tn("clientVersion", t.clientVersion), this._engine = VS(t, this._engineConfig), this._requestHandler = new Ul(this, A), a.log) for (let E of a.log) {
              let h = typeof E == "string" ? E : E.emit === "stdout" ? E.level : null;
              h && this.$on(h, (f) => {
                Di.log(`${Di.tags[h] ?? ""}`, f.message || f.query);
              });
            }
          } catch (a) {
            throw a.clientVersion = this._clientVersion, a;
          }
          return this._appliedParent = Wi(this);
        }
        get [Symbol.toStringTag]() {
          return "PrismaClient";
        }
        $on(n, A) {
          return n === "beforeExit" ? this._engine.onBeforeExit(A) : n && this._engineConfig.logEmitter.on(n, A), this;
        }
        $connect() {
          try {
            return this._engine.start();
          } catch (n) {
            throw n.clientVersion = this._clientVersion, n;
          }
        }
        async $disconnect() {
          try {
            await this._engine.stop();
          } catch (n) {
            throw n.clientVersion = this._clientVersion, n;
          } finally {
            gf();
          }
        }
        $executeRawInternal(n, A, i, s) {
          let o = this._activeProvider;
          return this._request({ action: "executeRaw", args: i, transaction: n, clientMethod: A, argsMapper: _h({ clientMethod: A, activeProvider: o }), callsite: Gr(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
        }
        $executeRaw(n, ...A) {
          return this._createPrismaPromise((i) => {
            if (n.raw !== void 0 || n.sql !== void 0) {
              let [s, o] = db(n, A);
              return Wh(this._activeProvider, s.text, s.values, Array.isArray(n) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(i, "$executeRaw", s, o);
            }
            throw new Ue("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
          });
        }
        $executeRawUnsafe(n, ...A) {
          return this._createPrismaPromise((i) => (Wh(this._activeProvider, n, A, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(i, "$executeRawUnsafe", [n, ...A])));
        }
        $runCommandRaw(n) {
          if (t.activeProvider !== "mongodb") throw new Ue(`The ${t.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
          return this._createPrismaPromise((A) => this._request({ args: n, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: HS, callsite: Gr(this._errorFormat), transaction: A }));
        }
        async $queryRawInternal(n, A, i, s) {
          let o = this._activeProvider;
          return this._request({ action: "queryRaw", args: i, transaction: n, clientMethod: A, argsMapper: _h({ clientMethod: A, activeProvider: o }), callsite: Gr(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
        }
        $queryRaw(n, ...A) {
          return this._createPrismaPromise((i) => {
            if (n.raw !== void 0 || n.sql !== void 0) return this.$queryRawInternal(i, "$queryRaw", ...db(n, A));
            throw new Ue("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
          });
        }
        $queryRawTyped(n) {
          return this._createPrismaPromise((A) => {
            if (!this._hasPreviewFlag("typedSql")) throw new Ue("`typedSql` preview feature must be enabled in order to access $queryRawTyped API", { clientVersion: this._clientVersion });
            return this.$queryRawInternal(A, "$queryRawTyped", n);
          });
        }
        $queryRawUnsafe(n, ...A) {
          return this._createPrismaPromise((i) => this.$queryRawInternal(i, "$queryRawUnsafe", [n, ...A]));
        }
        _transactionWithArray({ promises: n, options: A }) {
          let i = N_.nextId(), s = eb(n.length), o = n.map((a, c) => {
            if (a?.[Symbol.toStringTag] !== "PrismaPromise") throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
            let l = A?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel, u = { kind: "batch", id: i, index: c, isolationLevel: l, lock: s };
            return a.requestTransaction?.(u) ?? a;
          });
          return Eb(o);
        }
        async _transactionWithCallback({ callback: n, options: A }) {
          let i = { traceparent: this._tracingHelper.getTraceParent() }, s = { maxWait: A?.maxWait ?? this._engineConfig.transactionOptions.maxWait, timeout: A?.timeout ?? this._engineConfig.transactionOptions.timeout, isolationLevel: A?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel }, o = await this._engine.transaction("start", i, s), a;
          try {
            let c = { kind: "itx", ...o };
            a = await n(this._createItxClient(c)), await this._engine.transaction("commit", i, o);
          } catch (c) {
            throw await this._engine.transaction("rollback", i, o).catch(() => {
            }), c;
          }
          return a;
        }
        _createItxClient(n) {
          return mt(Wi(mt(jI(this), [Oe("_appliedParent", () => this._appliedParent._createItxClient(n)), Oe("_createPrismaPromise", () => jh(n)), Oe(b_, () => n.id)])), [QA(zI)]);
        }
        $transaction(n, A) {
          let i;
          typeof n == "function" ? this._engineConfig.adapter?.adapterName === "@prisma/adapter-d1" ? i = () => {
            throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.");
          } : i = () => this._transactionWithCallback({ callback: n, options: A }) : i = () => this._transactionWithArray({ promises: n, options: A });
          let s = { name: "transaction", attributes: { method: "$transaction" } };
          return this._tracingHelper.runInChildSpan(s, i);
        }
        _request(n) {
          n.otelParentCtx = this._tracingHelper.getActiveContext();
          let A = n.middlewareArgsMapper ?? S_, i = { args: A.requestArgsToMiddlewareArgs(n.args), dataPath: n.dataPath, runInTransaction: !!n.transaction, action: n.action, model: n.model }, s = { operation: { name: "operation", attributes: { method: i.action, model: i.model, name: i.model ? `${i.model}.${i.action}` : i.action } } }, o = async (a) => {
            let { runInTransaction: c, args: l, ...u } = a, g = { ...n, ...u };
            l && (g.args = A.middlewareArgsToRequestArgs(l)), n.transaction !== void 0 && c === false && delete g.transaction;
            let E = await np(this, g);
            return g.model ? $I({ result: E, modelName: g.model, args: g.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel, globalOmit: this._globalOmit }) : E;
          };
          return this._tracingHelper.runInChildSpan(s.operation, () => new fb.AsyncResource("prisma-client-request").runInAsyncScope(() => o(i)));
        }
        async _executeRequest({ args: n, clientMethod: A, dataPath: i, callsite: s, action: o, model: a, argsMapper: c, transaction: l, unpacker: u, otelParentCtx: g, customDataProxyFetch: E }) {
          try {
            n = c ? c(n) : n;
            let h = { name: "serialize" }, f = this._tracingHelper.runInChildSpan(h, () => fa({ modelName: a, runtimeDataModel: this._runtimeDataModel, action: o, args: n, clientMethod: A, callsite: s, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion, previewFeatures: this._previewFeatures, globalOmit: this._globalOmit }));
            return ce.enabled("prisma:client") && (tn("Prisma Client call:"), tn(`prisma.${A}(${vI(n)})`), tn("Generated request:"), tn(JSON.stringify(f, null, 2) + `
`)), l?.kind === "batch" && await l.lock, this._requestHandler.request({ protocolQuery: f, modelName: a, action: o, clientMethod: A, dataPath: i, callsite: s, args: n, extensions: this._extensions, transaction: l, unpacker: u, otelParentCtx: g, otelChildCtx: this._tracingHelper.getActiveContext(), globalOmit: this._globalOmit, customDataProxyFetch: E });
          } catch (h) {
            throw h.clientVersion = this._clientVersion, h;
          }
        }
        $metrics = new fA(this);
        _hasPreviewFlag(n) {
          return !!this._engineConfig.previewFeatures?.includes(n);
        }
        $applyPendingMigrations() {
          return this._engine.applyPendingMigrations();
        }
        $extends = ZI;
      }
      return e;
    }
    function db(t, e) {
      return F_(t) ? [new _e(t, e), XS] : [t, KS];
    }
    function F_(t) {
      return Array.isArray(t) && Array.isArray(t.raw);
    }
    var T_ = /* @__PURE__ */ new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
    function pb(t) {
      return new Proxy(t, { get(e, r) {
        if (r in e) return e[r];
        if (!T_.has(r)) throw new TypeError(`Invalid enum value: ${String(r)}`);
      } });
    }
    function Bb(t) {
      Ni(t, { conflictCheck: "warn" });
    }
  }
});

// node_modules/.prisma/client/index.js
var require_client = __commonJS({
  "node_modules/.prisma/client/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var {
      PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
      PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
      PrismaClientRustPanicError: PrismaClientRustPanicError2,
      PrismaClientInitializationError: PrismaClientInitializationError2,
      PrismaClientValidationError: PrismaClientValidationError2,
      getPrismaClient: getPrismaClient2,
      sqltag: sqltag2,
      empty: empty2,
      join: join2,
      raw: raw2,
      skip: skip2,
      Decimal: Decimal2,
      Debug: Debug2,
      objectEnumValues: objectEnumValues2,
      makeStrictEnum: makeStrictEnum2,
      Extensions: Extensions2,
      warnOnce: warnOnce2,
      defineDmmfProperty: defineDmmfProperty2,
      Public: Public2,
      getRuntime: getRuntime2,
      createParam: createParam2
    } = require_binary();
    var Prisma = {};
    exports2.Prisma = Prisma;
    exports2.$Enums = {};
    Prisma.prismaVersion = {
      client: "6.14.0",
      engine: "717184b7b35ea05dfa71a3236b7af656013e1e49"
    };
    Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
    Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
    Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
    Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
    Prisma.PrismaClientValidationError = PrismaClientValidationError2;
    Prisma.Decimal = Decimal2;
    Prisma.sql = sqltag2;
    Prisma.empty = empty2;
    Prisma.join = join2;
    Prisma.raw = raw2;
    Prisma.validator = Public2.validator;
    Prisma.getExtensionContext = Extensions2.getExtensionContext;
    Prisma.defineExtension = Extensions2.defineExtension;
    Prisma.DbNull = objectEnumValues2.instances.DbNull;
    Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
    Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
    Prisma.NullTypes = {
      DbNull: objectEnumValues2.classes.DbNull,
      JsonNull: objectEnumValues2.classes.JsonNull,
      AnyNull: objectEnumValues2.classes.AnyNull
    };
    var path = require("path");
    exports2.Prisma.TransactionIsolationLevel = makeStrictEnum2({
      ReadUncommitted: "ReadUncommitted",
      ReadCommitted: "ReadCommitted",
      RepeatableRead: "RepeatableRead",
      Serializable: "Serializable"
    });
    exports2.Prisma.Auth_userScalarFieldEnum = {
      id: "id",
      email: "email",
      password: "password",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      is_active: "is_active",
      name: "name",
      permissions: "permissions",
      role: "role"
    };
    exports2.Prisma.Core_workersScalarFieldEnum = {
      id: "id",
      name: "name",
      description: "description",
      status: "status",
      is_active: "is_active",
      type: "type",
      last_checkin_at: "last_checkin_at",
      created_at: "created_at",
      updated_at: "updated_at"
    };
    exports2.Prisma.Core_customersScalarFieldEnum = {
      id: "id",
      type: "type",
      name: "name",
      email: "email",
      whatsapp: "whatsapp",
      is_active: "is_active",
      created_at: "created_at",
      updated_at: "updated_at"
    };
    exports2.Prisma.Core_pix_keysScalarFieldEnum = {
      id: "id",
      customer_id: "customer_id",
      key_type: "key_type",
      key_value: "key_value",
      label: "label",
      active: "active",
      created_at: "created_at"
    };
    exports2.Prisma.Core_bank_accountsScalarFieldEnum = {
      id: "id",
      bank_code: "bank_code",
      bank_name: "bank_name",
      account_number: "account_number",
      agency_number: "agency_number",
      ispb: "ispb",
      cnpj: "cnpj",
      pix_keys: "pix_keys",
      daily_limit: "daily_limit",
      nightly_limit: "nightly_limit",
      per_operation_limit: "per_operation_limit",
      integration_status: "integration_status",
      active: "active",
      created_at: "created_at",
      updated_at: "updated_at",
      account_name: "account_name",
      link_code: "link_code",
      auto_credit_customer_id: "auto_credit_customer_id",
      confirm_auto_credit: "confirm_auto_credit",
      integration_id: "integration_id",
      provider: "provider",
      purpose: "purpose"
    };
    exports2.Prisma.Core_balancesScalarFieldEnum = {
      id: "id",
      customer_id: "customer_id",
      available_amount: "available_amount",
      locked_amount: "locked_amount",
      updated_at: "updated_at",
      credit_limit: "credit_limit"
    };
    exports2.Prisma.Core_bank_account_integrationsScalarFieldEnum = {
      id: "id",
      provider: "provider",
      auth_type: "auth_type",
      secret_ref: "secret_ref",
      config: "config",
      status: "status",
      created_at: "created_at",
      updated_at: "updated_at"
    };
    exports2.Prisma.Core_beneficiariesScalarFieldEnum = {
      id: "id",
      customer_id: "customer_id",
      name: "name",
      document: "document",
      created_at: "created_at"
    };
    exports2.Prisma.Core_beneficiary_pix_keysScalarFieldEnum = {
      id: "id",
      beneficiary_id: "beneficiary_id",
      key_type: "key_type",
      key_value: "key_value",
      label: "label",
      active: "active",
      created_at: "created_at"
    };
    exports2.Prisma.Core_incoming_pixScalarFieldEnum = {
      id: "id",
      origin: "origin",
      document: "document",
      amount: "amount",
      status: "status",
      raw_payload: "raw_payload",
      created_at: "created_at",
      customer_id: "customer_id"
    };
    exports2.Prisma.Core_order_destinationsScalarFieldEnum = {
      id: "id",
      order_id: "order_id",
      destination: "destination",
      destination_pix_key: "destination_pix_key",
      label: "label",
      beneficiary_id: "beneficiary_id",
      amount: "amount",
      destination_type: "destination_type",
      created_at: "created_at",
      beneficiary_document: "beneficiary_document",
      beneficiary_name: "beneficiary_name"
    };
    exports2.Prisma.Core_order_subtransactionsScalarFieldEnum = {
      id: "id",
      order_id: "order_id",
      status: "status",
      amount: "amount",
      index: "index",
      created_at: "created_at",
      executed_at: "executed_at",
      attempts: "attempts",
      bank_account_id: "bank_account_id",
      destination_pix_key: "destination_pix_key",
      idempotency_key: "idempotency_key",
      last_error: "last_error",
      provider_ref: "provider_ref",
      destination: "destination",
      destination_id: "destination_id",
      execution_metadata: "execution_metadata",
      next_retry_at: "next_retry_at",
      updated_at: "updated_at",
      beneficiary_document: "beneficiary_document",
      beneficiary_name: "beneficiary_name",
      end_to_end_id: "end_to_end_id",
      provider_status: "provider_status",
      settled_at: "settled_at",
      settlement_status: "settlement_status"
    };
    exports2.Prisma.Core_ordersScalarFieldEnum = {
      id: "id",
      customer_id: "customer_id",
      customer_type: "customer_type",
      bank_name: "bank_name",
      total_amount: "total_amount",
      sub_amount: "sub_amount",
      status: "status",
      created_at: "created_at",
      updated_at: "updated_at",
      base_amount: "base_amount",
      base_currency: "base_currency",
      completed_at: "completed_at",
      fees_amount: "fees_amount",
      idempotency_key: "idempotency_key",
      last_error: "last_error",
      locked_amount_snapshot: "locked_amount_snapshot",
      metadata: "metadata",
      rate: "rate",
      settlement_currency: "settlement_currency",
      started_at: "started_at",
      type: "type",
      kind: "kind",
      supplier_id: "supplier_id"
    };
    exports2.Prisma.Core_transactionsScalarFieldEnum = {
      id: "id",
      customer_id: "customer_id",
      type: "type",
      amount: "amount",
      description: "description",
      metadata: "metadata",
      created_at: "created_at",
      reason_code: "reason_code"
    };
    exports2.Prisma.Whats_customer_groupsScalarFieldEnum = {
      id: "id",
      customer_id: "customer_id",
      group_id: "group_id",
      group_name: "group_name",
      is_active: "is_active",
      created_at: "created_at",
      updated_at: "updated_at",
      type: "type"
    };
    exports2.Prisma.Whats_outbox_messagesScalarFieldEnum = {
      id: "id",
      provider: "provider",
      customer_id: "customer_id",
      destination: "destination",
      message: "message",
      reference_type: "reference_type",
      reference_id: "reference_id",
      idempotency_key: "idempotency_key",
      status: "status",
      attempts: "attempts",
      provider_response: "provider_response",
      last_error: "last_error",
      created_at: "created_at",
      updated_at: "updated_at"
    };
    exports2.Prisma.Core_bank_account_balancesScalarFieldEnum = {
      id: "id",
      bank_account_id: "bank_account_id",
      available_amount: "available_amount",
      total_amount: "total_amount",
      as_of: "as_of",
      status: "status",
      last_error: "last_error",
      raw_payload: "raw_payload",
      created_at: "created_at",
      updated_at: "updated_at"
    };
    exports2.Prisma.Core_payment_receiptsScalarFieldEnum = {
      id: "id",
      provider: "provider",
      webhook_type: "webhook_type",
      provider_payment_id: "provider_payment_id",
      provider_status: "provider_status",
      status: "status",
      idempotency_key: "idempotency_key",
      end_to_end_id: "end_to_end_id",
      remittance_information: "remittance_information",
      pix_key: "pix_key",
      amount: "amount",
      currency: "currency",
      debtor_document: "debtor_document",
      debtor_name: "debtor_name",
      creditor_document: "creditor_document",
      creditor_name: "creditor_name",
      subtransaction_id: "subtransaction_id",
      raw_payload: "raw_payload",
      received_at: "received_at",
      created_at: "created_at",
      updated_at: "updated_at"
    };
    exports2.Prisma.Core_suppliersScalarFieldEnum = {
      id: "id",
      name: "name",
      document: "document",
      email: "email",
      whatsapp: "whatsapp",
      is_active: "is_active",
      metadata: "metadata",
      created_at: "created_at",
      updated_at: "updated_at"
    };
    exports2.Prisma.Core_transaction_reasonsScalarFieldEnum = {
      id: "id",
      code: "code",
      name: "name",
      active: "active",
      description: "description",
      created_at: "created_at",
      updated_at: "updated_at",
      type: "type",
      is_internal: "is_internal"
    };
    exports2.Prisma.SortOrder = {
      asc: "asc",
      desc: "desc"
    };
    exports2.Prisma.NullableJsonNullValueInput = {
      DbNull: Prisma.DbNull,
      JsonNull: Prisma.JsonNull
    };
    exports2.Prisma.JsonNullValueInput = {
      JsonNull: Prisma.JsonNull
    };
    exports2.Prisma.QueryMode = {
      default: "default",
      insensitive: "insensitive"
    };
    exports2.Prisma.JsonNullValueFilter = {
      DbNull: Prisma.DbNull,
      JsonNull: Prisma.JsonNull,
      AnyNull: Prisma.AnyNull
    };
    exports2.Prisma.NullsOrder = {
      first: "first",
      last: "last"
    };
    exports2.CustomerType = exports2.$Enums.CustomerType = {
      pf: "pf",
      pj: "pj"
    };
    exports2.PixKeyType = exports2.$Enums.PixKeyType = {
      cpf: "cpf",
      cnpj: "cnpj",
      email: "email",
      phone: "phone",
      random: "random"
    };
    exports2.BankAccountPurpose = exports2.$Enums.BankAccountPurpose = {
      DEPOSIT: "DEPOSIT",
      PAYOUT: "PAYOUT"
    };
    exports2.BankProvider = exports2.$Enums.BankProvider = {
      ONLYUP: "ONLYUP"
    };
    exports2.DestinationType = exports2.$Enums.DestinationType = {
      AUTO: "AUTO",
      PIX: "PIX",
      WALLET: "WALLET",
      IBAN: "IBAN",
      ACCOUNT: "ACCOUNT"
    };
    exports2.OrderStatus = exports2.$Enums.OrderStatus = {
      PENDING: "PENDING",
      IN_PROGRESS: "IN_PROGRESS",
      PAUSED: "PAUSED",
      COMPLETED: "COMPLETED",
      FAILED: "FAILED"
    };
    exports2.OrderType = exports2.$Enums.OrderType = {
      TRX: "TRX",
      WIRE: "WIRE",
      USDT: "USDT",
      EFETIVO: "EFETIVO",
      TRANSFERENCIA: "TRANSFERENCIA",
      AJUSTE_SALDO: "AJUSTE_SALDO",
      ACERTO_IMPOSTO: "ACERTO_IMPOSTO"
    };
    exports2.PixStatus = exports2.$Enums.PixStatus = {
      pending: "pending",
      matched: "matched",
      credited: "credited",
      pending_auto: "pending_auto"
    };
    exports2.SubStatus = exports2.$Enums.SubStatus = {
      PENDING: "PENDING",
      PROCESSING: "PROCESSING",
      SUCCESS: "SUCCESS",
      FAILED: "FAILED"
    };
    exports2.TransactionType = exports2.$Enums.TransactionType = {
      credit: "credit",
      debit: "debit",
      lock: "lock",
      unlock: "unlock"
    };
    exports2.WhatsGroupType = exports2.$Enums.WhatsGroupType = {
      outgoing: "outgoing",
      incoming: "incoming"
    };
    exports2.OrderKind = exports2.$Enums.OrderKind = {
      OTC: "OTC",
      SUPPLIER: "SUPPLIER",
      BULK: "BULK"
    };
    exports2.ReceiptStatus = exports2.$Enums.ReceiptStatus = {
      RECEIVED: "RECEIVED",
      PROCESSING: "PROCESSING",
      LIQUIDATED: "LIQUIDATED",
      FAILED: "FAILED",
      CANCELED: "CANCELED",
      UNKNOWN: "UNKNOWN"
    };
    exports2.TransactionReasonType = exports2.$Enums.TransactionReasonType = {
      credit: "credit",
      debit: "debit",
      both: "both"
    };
    exports2.Prisma.ModelName = {
      auth_user: "auth_user",
      core_workers: "core_workers",
      core_customers: "core_customers",
      core_pix_keys: "core_pix_keys",
      core_bank_accounts: "core_bank_accounts",
      core_balances: "core_balances",
      core_bank_account_integrations: "core_bank_account_integrations",
      core_beneficiaries: "core_beneficiaries",
      core_beneficiary_pix_keys: "core_beneficiary_pix_keys",
      core_incoming_pix: "core_incoming_pix",
      core_order_destinations: "core_order_destinations",
      core_order_subtransactions: "core_order_subtransactions",
      core_orders: "core_orders",
      core_transactions: "core_transactions",
      whats_customer_groups: "whats_customer_groups",
      whats_outbox_messages: "whats_outbox_messages",
      core_bank_account_balances: "core_bank_account_balances",
      core_payment_receipts: "core_payment_receipts",
      core_suppliers: "core_suppliers",
      core_transaction_reasons: "core_transaction_reasons"
    };
    var config2 = {
      "generator": {
        "name": "client",
        "provider": {
          "fromEnvVar": null,
          "value": "prisma-client-js"
        },
        "output": {
          "value": "/Users/tecnologia01/sttartpay/order-service/node_modules/@prisma/client",
          "fromEnvVar": null
        },
        "config": {
          "engineType": "binary"
        },
        "binaryTargets": [
          {
            "fromEnvVar": null,
            "value": "darwin-arm64",
            "native": true
          },
          {
            "fromEnvVar": null,
            "value": "rhel-openssl-1.0.x"
          }
        ],
        "previewFeatures": [],
        "sourceFilePath": "/Users/tecnologia01/sttartpay/order-service/prisma/schema.prisma"
      },
      "relativeEnvPaths": {
        "rootEnvPath": null,
        "schemaEnvPath": "../../../.env"
      },
      "relativePath": "../../../prisma",
      "clientVersion": "6.14.0",
      "engineVersion": "717184b7b35ea05dfa71a3236b7af656013e1e49",
      "datasourceNames": [
        "db"
      ],
      "activeProvider": "postgresql",
      "postinstall": false,
      "inlineDatasources": {
        "db": {
          "url": {
            "fromEnvVar": "DATABASE_URL",
            "value": null
          }
        }
      },
      "inlineSchema": 'generator client {\n  provider      = "prisma-client-js"\n  binaryTargets = ["native", "rhel-openssl-1.0.x"]\n  engineType    = "binary"\n}\n\ndatasource db {\n  provider = "postgresql"\n  url      = env("DATABASE_URL")\n}\n\nmodel auth_user {\n  id          String   @id @default(uuid())\n  email       String   @unique\n  password    String\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n  is_active   Boolean  @default(true)\n  name        String?\n  permissions Json?\n  role        String?\n}\n\nmodel core_workers {\n  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid\n  name            String\n  description     String?\n  status          String    @default("online")\n  is_active       Boolean   @default(true)\n  type            String\n  last_checkin_at DateTime? @db.Timestamp(6)\n  created_at      DateTime? @default(now()) @db.Timestamp(6)\n  updated_at      DateTime? @default(now()) @db.Timestamp(6)\n}\n\nmodel core_customers {\n  id                 String               @id @default(uuid())\n  type               CustomerType\n  name               String\n  email              String?\n  whatsapp           String?\n  is_active          Boolean              @default(true)\n  created_at         DateTime             @default(now())\n  updated_at         DateTime             @updatedAt\n  core_balances      core_balances?\n  core_bank_accounts core_bank_accounts[]\n  core_beneficiaries core_beneficiaries[]\n  core_incoming_pix  core_incoming_pix[]\n  core_orders        core_orders[]\n  pix_keys           core_pix_keys[]      @relation("customerPixKeys")\n  core_transactions  core_transactions[]\n}\n\nmodel core_pix_keys {\n  id          String         @id @default(uuid())\n  customer_id String\n  key_type    PixKeyType\n  key_value   String\n  label       String?\n  active      Boolean        @default(true)\n  created_at  DateTime       @default(now())\n  customer    core_customers @relation("customerPixKeys", fields: [customer_id], references: [id], onDelete: Cascade, map: "fk_pix_customer_id")\n\n  @@index([customer_id])\n  @@index([key_value])\n}\n\nmodel core_bank_accounts {\n  id                             String                          @id @default(uuid())\n  bank_code                      String\n  bank_name                      String\n  account_number                 String\n  agency_number                  String\n  ispb                           String\n  cnpj                           String\n  pix_keys                       String[]                        @default([])\n  daily_limit                    Int\n  nightly_limit                  Int\n  per_operation_limit            Int\n  integration_status             String\n  active                         Boolean                         @default(true)\n  created_at                     DateTime                        @default(now())\n  updated_at                     DateTime                        @updatedAt\n  account_name                   String?\n  link_code                      String?\n  auto_credit_customer_id        String?\n  confirm_auto_credit            Boolean                         @default(false)\n  integration_id                 String?\n  provider                       BankProvider?\n  purpose                        BankAccountPurpose              @default(DEPOSIT)\n  core_bank_account_balances     core_bank_account_balances?\n  core_customers                 core_customers?                 @relation(fields: [auto_credit_customer_id], references: [id])\n  core_bank_account_integrations core_bank_account_integrations? @relation(fields: [integration_id], references: [id])\n  core_order_subtransactions     core_order_subtransactions[]\n\n  @@index([integration_id])\n  @@index([provider, active])\n  @@index([purpose, active])\n}\n\nmodel core_balances {\n  id               String         @id\n  customer_id      String         @unique\n  available_amount Decimal        @default(0) @db.Decimal(14, 2)\n  locked_amount    Decimal        @default(0) @db.Decimal(14, 2)\n  updated_at       DateTime\n  credit_limit     Decimal        @default(0) @db.Decimal(14, 2)\n  core_customers   core_customers @relation(fields: [customer_id], references: [id], onDelete: Cascade)\n}\n\nmodel core_bank_account_integrations {\n  id                 String               @id @default(uuid())\n  provider           BankProvider\n  auth_type          String\n  secret_ref         String\n  config             Json?\n  status             String               @default("active")\n  created_at         DateTime             @default(now())\n  updated_at         DateTime\n  core_bank_accounts core_bank_accounts[]\n\n  @@index([provider, status])\n}\n\nmodel core_beneficiaries {\n  id                        String                      @id @default(uuid())\n  customer_id               String\n  name                      String\n  document                  String\n  created_at                DateTime                    @default(now())\n  core_customers            core_customers              @relation(fields: [customer_id], references: [id], onDelete: Cascade)\n  core_beneficiary_pix_keys core_beneficiary_pix_keys[]\n  core_order_destinations   core_order_destinations[]   @relation("BeneficiaryOrders")\n\n  @@index([customer_id])\n  @@index([document])\n}\n\nmodel core_beneficiary_pix_keys {\n  id                 String             @id @default(uuid())\n  beneficiary_id     String\n  key_type           PixKeyType\n  key_value          String\n  label              String?\n  active             Boolean            @default(true)\n  created_at         DateTime           @default(now())\n  core_beneficiaries core_beneficiaries @relation(fields: [beneficiary_id], references: [id], onDelete: Cascade)\n\n  @@index([beneficiary_id])\n  @@index([key_value])\n}\n\nmodel core_incoming_pix {\n  id             String          @id\n  origin         String\n  document       String?\n  amount         Decimal         @db.Decimal(14, 2)\n  status         PixStatus       @default(pending)\n  raw_payload    Json\n  created_at     DateTime        @default(now())\n  customer_id    String?\n  core_customers core_customers? @relation(fields: [customer_id], references: [id])\n\n  @@index([customer_id])\n  @@index([status, created_at])\n}\n\nmodel core_order_destinations {\n  id                         String                       @id @default(uuid())\n  order_id                   String\n  destination                String\n  destination_pix_key        String?\n  label                      String?\n  beneficiary_id             String?\n  amount                     Decimal?                     @db.Decimal(14, 2)\n  destination_type           DestinationType              @default(AUTO)\n  created_at                 DateTime                     @default(now())\n  beneficiary_document       String?\n  beneficiary_name           String?\n  core_beneficiaries         core_beneficiaries?          @relation("BeneficiaryOrders", fields: [beneficiary_id], references: [id])\n  core_orders                core_orders                  @relation(fields: [order_id], references: [id], onDelete: Cascade)\n  core_order_subtransactions core_order_subtransactions[]\n\n  @@index([destination])\n  @@index([destination_pix_key])\n  @@index([order_id])\n  @@index([beneficiary_id])\n  @@index([beneficiary_document])\n}\n\nmodel core_order_subtransactions {\n  id                      String                   @id @default(uuid())\n  order_id                String\n  status                  SubStatus                @default(PENDING)\n  amount                  Decimal                  @db.Decimal(14, 2)\n  index                   Int\n  created_at              DateTime                 @default(now())\n  executed_at             DateTime?\n  attempts                Int                      @default(0)\n  bank_account_id         String?\n  destination_pix_key     String?\n  idempotency_key         String?                  @unique\n  last_error              String?\n  provider_ref            String?\n  destination             String?\n  destination_id          String?\n  execution_metadata      Json?\n  next_retry_at           DateTime?\n  updated_at              DateTime                 @default(now()) @db.Timestamp(6)\n  beneficiary_document    String?\n  beneficiary_name        String?\n  end_to_end_id           String?\n  provider_status         String?\n  settled_at              DateTime?\n  settlement_status       String?\n  core_bank_accounts      core_bank_accounts?      @relation(fields: [bank_account_id], references: [id])\n  core_order_destinations core_order_destinations? @relation(fields: [destination_id], references: [id])\n  core_orders             core_orders              @relation(fields: [order_id], references: [id], onDelete: Cascade)\n  core_payment_receipts   core_payment_receipts[]\n\n  @@index([bank_account_id, status])\n  @@index([order_id])\n  @@index([status, created_at])\n  @@index([status, next_retry_at])\n  @@index([beneficiary_document])\n  @@index([end_to_end_id])\n  @@index([settlement_status, settled_at])\n}\n\nmodel core_orders {\n  id                         String                       @id\n  customer_id                String\n  customer_type              String\n  bank_name                  String\n  total_amount               Decimal                      @db.Decimal(14, 2)\n  sub_amount                 Decimal                      @db.Decimal(14, 2)\n  status                     OrderStatus                  @default(PENDING)\n  created_at                 DateTime                     @default(now())\n  updated_at                 DateTime                     @updatedAt\n  base_amount                Decimal                      @default(0) @db.Decimal(14, 2)\n  base_currency              String                       @default("USD")\n  completed_at               DateTime?\n  fees_amount                Decimal                      @default(0) @db.Decimal(14, 2)\n  idempotency_key            String?                      @unique\n  last_error                 String?\n  locked_amount_snapshot     Decimal?                     @db.Decimal(14, 2)\n  metadata                   Json?\n  rate                       Decimal                      @default(1) @db.Decimal(14, 6)\n  settlement_currency        String                       @default("BRL")\n  started_at                 DateTime?\n  type                       OrderType                    @default(TRANSFERENCIA)\n  kind                       OrderKind                    @default(OTC)\n  supplier_id                String?\n  core_order_destinations    core_order_destinations[]\n  core_order_subtransactions core_order_subtransactions[]\n  core_customers             core_customers               @relation(fields: [customer_id], references: [id])\n  core_suppliers             core_suppliers?              @relation(fields: [supplier_id], references: [id])\n\n  @@index([customer_id, idempotency_key])\n  @@index([customer_id])\n  @@index([status, created_at])\n  @@index([type, status, created_at])\n  @@index([kind, status, created_at])\n  @@index([supplier_id])\n}\n\nmodel core_transactions {\n  id             String          @id\n  customer_id    String\n  type           TransactionType\n  amount         Decimal         @db.Decimal(14, 2)\n  description    String?\n  metadata       Json?\n  created_at     DateTime        @default(now())\n  reason_code    String?\n  core_customers core_customers  @relation(fields: [customer_id], references: [id], onDelete: Cascade)\n\n  @@index([customer_id])\n  @@index([type, created_at])\n  @@index([reason_code, created_at])\n}\n\nmodel whats_customer_groups {\n  id          String         @id\n  customer_id String\n  group_id    String\n  group_name  String?\n  is_active   Boolean        @default(true)\n  created_at  DateTime       @default(now())\n  updated_at  DateTime\n  type        WhatsGroupType @default(outgoing)\n\n  @@unique([customer_id, type])\n  @@index([customer_id, type])\n  @@index([is_active])\n}\n\nmodel whats_outbox_messages {\n  id                String   @id\n  provider          String   @default("zapi")\n  customer_id       String?\n  destination       String\n  message           String\n  reference_type    String\n  reference_id      String\n  idempotency_key   String   @unique\n  status            String   @default("pending")\n  attempts          Int      @default(0)\n  provider_response Json?\n  last_error        String?\n  created_at        DateTime @default(now())\n  updated_at        DateTime\n\n  @@index([reference_type, reference_id])\n  @@index([status])\n}\n\nmodel core_bank_account_balances {\n  id                 String             @id @default(uuid())\n  bank_account_id    String             @unique\n  available_amount   Decimal            @default(0) @db.Decimal(14, 2)\n  total_amount       Decimal?           @db.Decimal(14, 2)\n  as_of              DateTime           @default(now())\n  status             String             @default("ok")\n  last_error         String?\n  raw_payload        Json?\n  created_at         DateTime           @default(now())\n  updated_at         DateTime\n  core_bank_accounts core_bank_accounts @relation(fields: [bank_account_id], references: [id], onDelete: Cascade)\n\n  @@index([as_of])\n  @@index([status, as_of])\n}\n\nmodel core_payment_receipts {\n  id                         String                      @id @default(dbgenerated("gen_random_uuid()"))\n  provider                   BankProvider\n  webhook_type               String?\n  provider_payment_id        String?\n  provider_status            String?\n  status                     ReceiptStatus               @default(RECEIVED)\n  idempotency_key            String?\n  end_to_end_id              String?\n  remittance_information     String?\n  pix_key                    String?\n  amount                     Decimal?                    @db.Decimal(14, 2)\n  currency                   String?\n  debtor_document            String?\n  debtor_name                String?\n  creditor_document          String?\n  creditor_name              String?\n  subtransaction_id          String?\n  raw_payload                Json?\n  received_at                DateTime                    @default(now())\n  created_at                 DateTime                    @default(now())\n  updated_at                 DateTime\n  core_order_subtransactions core_order_subtransactions? @relation(fields: [subtransaction_id], references: [id])\n\n  @@unique([provider, provider_payment_id])\n  @@index([end_to_end_id])\n  @@index([idempotency_key])\n  @@index([status, received_at])\n  @@index([subtransaction_id])\n}\n\nmodel core_suppliers {\n  id          String        @id\n  name        String\n  document    String?\n  email       String?\n  whatsapp    String?\n  is_active   Boolean       @default(true)\n  metadata    Json?\n  created_at  DateTime      @default(now())\n  updated_at  DateTime\n  core_orders core_orders[]\n}\n\nmodel core_transaction_reasons {\n  id          String                @id\n  code        String                @unique\n  name        String\n  active      Boolean               @default(true)\n  description String?\n  created_at  DateTime              @default(now())\n  updated_at  DateTime\n  type        TransactionReasonType @default(both)\n  is_internal Boolean               @default(false)\n\n  @@index([active])\n  @@index([is_internal, active])\n  @@index([type, active])\n  @@index([type, is_internal, active])\n}\n\nenum CustomerType {\n  pf\n  pj\n}\n\nenum PixKeyType {\n  cpf\n  cnpj\n  email\n  phone\n  random\n}\n\nenum BankAccountPurpose {\n  DEPOSIT\n  PAYOUT\n}\n\nenum BankProvider {\n  ONLYUP\n}\n\nenum DestinationType {\n  AUTO\n  PIX\n  WALLET\n  IBAN\n  ACCOUNT\n}\n\nenum OrderStatus {\n  PENDING\n  IN_PROGRESS\n  PAUSED\n  COMPLETED\n  FAILED\n}\n\nenum OrderType {\n  TRX\n  WIRE\n  USDT\n  EFETIVO\n  TRANSFERENCIA\n  AJUSTE_SALDO\n  ACERTO_IMPOSTO\n}\n\nenum PixStatus {\n  pending\n  matched\n  credited\n  pending_auto\n}\n\nenum SubStatus {\n  PENDING\n  PROCESSING\n  SUCCESS\n  FAILED\n}\n\nenum TransactionType {\n  credit\n  debit\n  lock\n  unlock\n}\n\nenum WhatsGroupType {\n  outgoing\n  incoming\n}\n\nenum OrderKind {\n  OTC\n  SUPPLIER\n  BULK\n}\n\nenum ReceiptStatus {\n  RECEIVED\n  PROCESSING\n  LIQUIDATED\n  FAILED\n  CANCELED\n  UNKNOWN\n}\n\nenum TransactionReasonType {\n  credit\n  debit\n  both\n}\n',
      "inlineSchemaHash": "4f86496c21a388ad99212327fa28ceea3f6f56714a7dfe99bc0cbfce35ae2595",
      "copyEngine": true
    };
    var fs = require("fs");
    config2.dirname = __dirname;
    if (!fs.existsSync(path.join(__dirname, "schema.prisma"))) {
      const alternativePaths = [
        "node_modules/.prisma/client",
        ".prisma/client"
      ];
      const alternativePath = alternativePaths.find((altPath) => {
        return fs.existsSync(path.join(process.cwd(), altPath, "schema.prisma"));
      }) ?? alternativePaths[0];
      config2.dirname = path.join(process.cwd(), alternativePath);
      config2.isBundled = true;
    }
    config2.runtimeDataModel = JSON.parse('{"models":{"auth_user":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"password","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"is_active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"permissions","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"role","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"core_workers":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":["Uuid",[]],"default":{"name":"dbgenerated","args":["gen_random_uuid()"]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"online","isGenerated":false,"isUpdatedAt":false},{"name":"is_active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"last_checkin_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":["Timestamp",["6"]],"isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":["Timestamp",["6"]],"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":["Timestamp",["6"]],"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"core_customers":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CustomerType","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"whatsapp","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"is_active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"core_balances","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_balances","nativeType":null,"relationName":"core_balancesTocore_customers","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"core_bank_accounts","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_bank_accounts","nativeType":null,"relationName":"core_bank_accountsTocore_customers","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"core_beneficiaries","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_beneficiaries","nativeType":null,"relationName":"core_beneficiariesTocore_customers","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"core_incoming_pix","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_incoming_pix","nativeType":null,"relationName":"core_customersTocore_incoming_pix","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"core_orders","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_orders","nativeType":null,"relationName":"core_customersTocore_orders","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"pix_keys","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_pix_keys","nativeType":null,"relationName":"customerPixKeys","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"core_transactions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_transactions","nativeType":null,"relationName":"core_customersTocore_transactions","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"core_pix_keys":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"customer_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"key_type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PixKeyType","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"key_value","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"label","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"customer","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_customers","nativeType":null,"relationName":"customerPixKeys","relationFromFields":["customer_id"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"core_bank_accounts":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"bank_code","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"bank_name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"account_number","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"agency_number","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"ispb","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cnpj","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"pix_keys","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":[],"isGenerated":false,"isUpdatedAt":false},{"name":"daily_limit","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"nightly_limit","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"per_operation_limit","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"integration_status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"account_name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"link_code","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"auto_credit_customer_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"confirm_auto_credit","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"integration_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"BankProvider","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"purpose","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"BankAccountPurpose","nativeType":null,"default":"DEPOSIT","isGenerated":false,"isUpdatedAt":false},{"name":"core_bank_account_balances","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_bank_account_balances","nativeType":null,"relationName":"core_bank_account_balancesTocore_bank_accounts","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"core_customers","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_customers","nativeType":null,"relationName":"core_bank_accountsTocore_customers","relationFromFields":["auto_credit_customer_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"core_bank_account_integrations","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_bank_account_integrations","nativeType":null,"relationName":"core_bank_account_integrationsTocore_bank_accounts","relationFromFields":["integration_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"core_order_subtransactions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_order_subtransactions","nativeType":null,"relationName":"core_bank_accountsTocore_order_subtransactions","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"core_balances":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"customer_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"available_amount","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Decimal","nativeType":["Decimal",["14","2"]],"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"locked_amount","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Decimal","nativeType":["Decimal",["14","2"]],"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"credit_limit","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Decimal","nativeType":["Decimal",["14","2"]],"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"core_customers","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_customers","nativeType":null,"relationName":"core_balancesTocore_customers","relationFromFields":["customer_id"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"core_bank_account_integrations":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"BankProvider","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"auth_type","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"secret_ref","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"config","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"active","isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"core_bank_accounts","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_bank_accounts","nativeType":null,"relationName":"core_bank_account_integrationsTocore_bank_accounts","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"core_beneficiaries":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"customer_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"document","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"core_customers","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_customers","nativeType":null,"relationName":"core_beneficiariesTocore_customers","relationFromFields":["customer_id"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"core_beneficiary_pix_keys","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_beneficiary_pix_keys","nativeType":null,"relationName":"core_beneficiariesTocore_beneficiary_pix_keys","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"core_order_destinations","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_order_destinations","nativeType":null,"relationName":"BeneficiaryOrders","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"core_beneficiary_pix_keys":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"beneficiary_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"key_type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PixKeyType","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"key_value","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"label","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"core_beneficiaries","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_beneficiaries","nativeType":null,"relationName":"core_beneficiariesTocore_beneficiary_pix_keys","relationFromFields":["beneficiary_id"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"core_incoming_pix":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"origin","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"document","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"amount","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["14","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"PixStatus","nativeType":null,"default":"pending","isGenerated":false,"isUpdatedAt":false},{"name":"raw_payload","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"customer_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"core_customers","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_customers","nativeType":null,"relationName":"core_customersTocore_incoming_pix","relationFromFields":["customer_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"core_order_destinations":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"order_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"destination","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"destination_pix_key","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"label","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"beneficiary_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"amount","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["14","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"destination_type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DestinationType","nativeType":null,"default":"AUTO","isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"beneficiary_document","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"beneficiary_name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"core_beneficiaries","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_beneficiaries","nativeType":null,"relationName":"BeneficiaryOrders","relationFromFields":["beneficiary_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"core_orders","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_orders","nativeType":null,"relationName":"core_order_destinationsTocore_orders","relationFromFields":["order_id"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"core_order_subtransactions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_order_subtransactions","nativeType":null,"relationName":"core_order_destinationsTocore_order_subtransactions","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"core_order_subtransactions":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"order_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"SubStatus","nativeType":null,"default":"PENDING","isGenerated":false,"isUpdatedAt":false},{"name":"amount","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["14","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"index","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"executed_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"attempts","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"bank_account_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"destination_pix_key","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"idempotency_key","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"last_error","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider_ref","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"destination","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"destination_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"execution_metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"next_retry_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":["Timestamp",["6"]],"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"beneficiary_document","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"beneficiary_name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"end_to_end_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider_status","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"settled_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"settlement_status","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"core_bank_accounts","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_bank_accounts","nativeType":null,"relationName":"core_bank_accountsTocore_order_subtransactions","relationFromFields":["bank_account_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"core_order_destinations","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_order_destinations","nativeType":null,"relationName":"core_order_destinationsTocore_order_subtransactions","relationFromFields":["destination_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"core_orders","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_orders","nativeType":null,"relationName":"core_order_subtransactionsTocore_orders","relationFromFields":["order_id"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"core_payment_receipts","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_payment_receipts","nativeType":null,"relationName":"core_order_subtransactionsTocore_payment_receipts","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"core_orders":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"customer_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"customer_type","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"bank_name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"total_amount","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["14","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"sub_amount","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["14","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"OrderStatus","nativeType":null,"default":"PENDING","isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"base_amount","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Decimal","nativeType":["Decimal",["14","2"]],"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"base_currency","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"USD","isGenerated":false,"isUpdatedAt":false},{"name":"completed_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"fees_amount","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Decimal","nativeType":["Decimal",["14","2"]],"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"idempotency_key","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"last_error","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"locked_amount_snapshot","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["14","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"rate","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Decimal","nativeType":["Decimal",["14","6"]],"default":1,"isGenerated":false,"isUpdatedAt":false},{"name":"settlement_currency","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"BRL","isGenerated":false,"isUpdatedAt":false},{"name":"started_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"OrderType","nativeType":null,"default":"TRANSFERENCIA","isGenerated":false,"isUpdatedAt":false},{"name":"kind","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"OrderKind","nativeType":null,"default":"OTC","isGenerated":false,"isUpdatedAt":false},{"name":"supplier_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"core_order_destinations","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_order_destinations","nativeType":null,"relationName":"core_order_destinationsTocore_orders","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"core_order_subtransactions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_order_subtransactions","nativeType":null,"relationName":"core_order_subtransactionsTocore_orders","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"core_customers","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_customers","nativeType":null,"relationName":"core_customersTocore_orders","relationFromFields":["customer_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"core_suppliers","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_suppliers","nativeType":null,"relationName":"core_ordersTocore_suppliers","relationFromFields":["supplier_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"core_transactions":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"customer_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"TransactionType","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"amount","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["14","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"reason_code","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"core_customers","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_customers","nativeType":null,"relationName":"core_customersTocore_transactions","relationFromFields":["customer_id"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"whats_customer_groups":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"customer_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"group_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"group_name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"is_active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"WhatsGroupType","nativeType":null,"default":"outgoing","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["customer_id","type"]],"uniqueIndexes":[{"name":null,"fields":["customer_id","type"]}],"isGenerated":false},"whats_outbox_messages":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"zapi","isGenerated":false,"isUpdatedAt":false},{"name":"customer_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"destination","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"message","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"reference_type","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"reference_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"idempotency_key","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"pending","isGenerated":false,"isUpdatedAt":false},{"name":"attempts","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"provider_response","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"last_error","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"core_bank_account_balances":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"bank_account_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"available_amount","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Decimal","nativeType":["Decimal",["14","2"]],"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"total_amount","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["14","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"as_of","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"ok","isGenerated":false,"isUpdatedAt":false},{"name":"last_error","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"raw_payload","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"core_bank_accounts","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_bank_accounts","nativeType":null,"relationName":"core_bank_account_balancesTocore_bank_accounts","relationFromFields":["bank_account_id"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"core_payment_receipts":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"dbgenerated","args":["gen_random_uuid()"]},"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"BankProvider","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"webhook_type","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider_payment_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"provider_status","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"ReceiptStatus","nativeType":null,"default":"RECEIVED","isGenerated":false,"isUpdatedAt":false},{"name":"idempotency_key","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"end_to_end_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"remittance_information","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"pix_key","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"amount","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["14","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"currency","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"debtor_document","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"debtor_name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"creditor_document","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"creditor_name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"subtransaction_id","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"raw_payload","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"received_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"core_order_subtransactions","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_order_subtransactions","nativeType":null,"relationName":"core_order_subtransactionsTocore_payment_receipts","relationFromFields":["subtransaction_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["provider","provider_payment_id"]],"uniqueIndexes":[{"name":null,"fields":["provider","provider_payment_id"]}],"isGenerated":false},"core_suppliers":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"document","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"whatsapp","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"is_active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"core_orders","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"core_orders","nativeType":null,"relationName":"core_ordersTocore_suppliers","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"core_transaction_reasons":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"code","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updated_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"TransactionReasonType","nativeType":null,"default":"both","isGenerated":false,"isUpdatedAt":false},{"name":"is_internal","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false}},"enums":{"CustomerType":{"values":[{"name":"pf","dbName":null},{"name":"pj","dbName":null}],"dbName":null},"PixKeyType":{"values":[{"name":"cpf","dbName":null},{"name":"cnpj","dbName":null},{"name":"email","dbName":null},{"name":"phone","dbName":null},{"name":"random","dbName":null}],"dbName":null},"BankAccountPurpose":{"values":[{"name":"DEPOSIT","dbName":null},{"name":"PAYOUT","dbName":null}],"dbName":null},"BankProvider":{"values":[{"name":"ONLYUP","dbName":null}],"dbName":null},"DestinationType":{"values":[{"name":"AUTO","dbName":null},{"name":"PIX","dbName":null},{"name":"WALLET","dbName":null},{"name":"IBAN","dbName":null},{"name":"ACCOUNT","dbName":null}],"dbName":null},"OrderStatus":{"values":[{"name":"PENDING","dbName":null},{"name":"IN_PROGRESS","dbName":null},{"name":"PAUSED","dbName":null},{"name":"COMPLETED","dbName":null},{"name":"FAILED","dbName":null}],"dbName":null},"OrderType":{"values":[{"name":"TRX","dbName":null},{"name":"WIRE","dbName":null},{"name":"USDT","dbName":null},{"name":"EFETIVO","dbName":null},{"name":"TRANSFERENCIA","dbName":null},{"name":"AJUSTE_SALDO","dbName":null},{"name":"ACERTO_IMPOSTO","dbName":null}],"dbName":null},"PixStatus":{"values":[{"name":"pending","dbName":null},{"name":"matched","dbName":null},{"name":"credited","dbName":null},{"name":"pending_auto","dbName":null}],"dbName":null},"SubStatus":{"values":[{"name":"PENDING","dbName":null},{"name":"PROCESSING","dbName":null},{"name":"SUCCESS","dbName":null},{"name":"FAILED","dbName":null}],"dbName":null},"TransactionType":{"values":[{"name":"credit","dbName":null},{"name":"debit","dbName":null},{"name":"lock","dbName":null},{"name":"unlock","dbName":null}],"dbName":null},"WhatsGroupType":{"values":[{"name":"outgoing","dbName":null},{"name":"incoming","dbName":null}],"dbName":null},"OrderKind":{"values":[{"name":"OTC","dbName":null},{"name":"SUPPLIER","dbName":null},{"name":"BULK","dbName":null}],"dbName":null},"ReceiptStatus":{"values":[{"name":"RECEIVED","dbName":null},{"name":"PROCESSING","dbName":null},{"name":"LIQUIDATED","dbName":null},{"name":"FAILED","dbName":null},{"name":"CANCELED","dbName":null},{"name":"UNKNOWN","dbName":null}],"dbName":null},"TransactionReasonType":{"values":[{"name":"credit","dbName":null},{"name":"debit","dbName":null},{"name":"both","dbName":null}],"dbName":null}},"types":{}}');
    defineDmmfProperty2(exports2.Prisma, config2.runtimeDataModel);
    config2.engineWasm = void 0;
    config2.compilerWasm = void 0;
    var { warnEnvConflicts: warnEnvConflicts2 } = require_binary();
    warnEnvConflicts2({
      rootEnvPath: config2.relativeEnvPaths.rootEnvPath && path.resolve(config2.dirname, config2.relativeEnvPaths.rootEnvPath),
      schemaEnvPath: config2.relativeEnvPaths.schemaEnvPath && path.resolve(config2.dirname, config2.relativeEnvPaths.schemaEnvPath)
    });
    var PrismaClient2 = getPrismaClient2(config2);
    exports2.PrismaClient = PrismaClient2;
    Object.assign(exports2, Prisma);
    path.join(__dirname, "query-engine-darwin-arm64");
    path.join(process.cwd(), "node_modules/.prisma/client/query-engine-darwin-arm64");
    path.join(__dirname, "query-engine-rhel-openssl-1.0.x");
    path.join(process.cwd(), "node_modules/.prisma/client/query-engine-rhel-openssl-1.0.x");
    path.join(__dirname, "schema.prisma");
    path.join(process.cwd(), "node_modules/.prisma/client/schema.prisma");
  }
});

// node_modules/.prisma/client/default.js
var require_default = __commonJS({
  "node_modules/.prisma/client/default.js"(exports2, module2) {
    module2.exports = { ...require_client() };
  }
});

// node_modules/@prisma/client/default.js
var require_default2 = __commonJS({
  "node_modules/@prisma/client/default.js"(exports2, module2) {
    module2.exports = {
      ...require_default()
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "node_modules/jws/lib/data-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream = require("stream");
    var util = require("util");
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util.inherits(DataStream, Stream);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module2.exports = DataStream;
  }
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports2, module2) {
    "use strict";
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module2.exports = getParamBytesForAlg;
  }
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base643) {
      return base643.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer2.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer2.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module2.exports = {
      derToJose,
      joseToDer
    };
  }
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "node_modules/buffer-equal-constant-time/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require("buffer").Buffer;
    var SlowBuffer = require("buffer").SlowBuffer;
    module2.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        c |= a[i] ^ b[i];
      }
      return c === 0;
    }
    bufferEq.install = function() {
      Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer2.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer2.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// node_modules/jwa/index.js
var require_jwa = __commonJS({
  "node_modules/jwa/index.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto3 = require("crypto");
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = require("util");
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto3.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base643) {
      return base643.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url3) {
      base64url3 = base64url3.toString();
      var padding = 4 - base64url3.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url3 += "=";
        }
      }
      return base64url3.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto3.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    var bufferEqual;
    var timingSafeEqual = "timingSafeEqual" in crypto3 ? function timingSafeEqual2(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      return crypto3.timingSafeEqual(a, b);
    } : function timingSafeEqual2(a, b) {
      if (!bufferEqual) {
        bufferEqual = require_buffer_equal_constant_time();
      }
      return bufferEqual(a, b);
    };
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return timingSafeEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto3.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto3.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto3.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto3.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto3.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto3.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto3.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto3.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module2.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "node_modules/jws/lib/tostring.js"(exports2, module2) {
    var Buffer2 = require("buffer").Buffer;
    module2.exports = function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer2.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    };
  }
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "node_modules/jws/lib/sign-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString = require_tostring();
    var util = require("util");
    function base64url3(string4, encoding) {
      return Buffer2.from(string4, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url3(toString(header), "binary");
      var encodedPayload = base64url3(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret;
      secret = secret == null ? opts.privateKey : secret;
      secret = secret == null ? opts.key : secret;
      if (/^hs/i.test(opts.header.alg) === true && secret == null) {
        throw new TypeError("secret must be a string or buffer or a KeyObject");
      }
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    util.inherits(SignStream, Stream);
    SignStream.prototype.sign = function sign() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module2.exports = SignStream;
  }
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "node_modules/jws/lib/verify-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString = require_tostring();
    var util = require("util");
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject2(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject2(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding);
    }
    function isValidJws(string4) {
      return JWS_REGEX.test(string4) && !!headerFromJWS(string4);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret;
      secretOrKey = secretOrKey == null ? opts.publicKey : secretOrKey;
      secretOrKey = secretOrKey == null ? opts.key : secretOrKey;
      if (/^hs/i.test(opts.algorithm) === true && secretOrKey == null) {
        throw new TypeError("secret must be a string or buffer or a KeyObject");
      }
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    util.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module2.exports = VerifyStream;
  }
});

// node_modules/jws/index.js
var require_jws = __commonJS({
  "node_modules/jws/index.js"(exports2) {
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports2.ALGORITHMS = ALGORITHMS;
    exports2.sign = SignStream.sign;
    exports2.verify = VerifyStream.verify;
    exports2.decode = VerifyStream.decode;
    exports2.isValid = VerifyStream.isValid;
    exports2.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports2.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  "node_modules/jsonwebtoken/decode.js"(exports2, module2) {
    var jws = require_jws();
    module2.exports = function(jwt3, options) {
      options = options || {};
      var decoded = jws.decode(jwt3, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === "object") {
            payload = obj;
          }
        } catch (e) {
        }
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports2, module2) {
    var JsonWebTokenError = function(message, error48) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error48) this.inner = error48;
    };
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module2.exports = JsonWebTokenError;
  }
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = function(message, date5) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date5;
    };
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module2.exports = NotBeforeError;
  }
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    };
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module2.exports = TokenExpiredError;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse3(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "node_modules/jsonwebtoken/lib/timespan.js"(exports2, module2) {
    var ms = require_ms();
    module2.exports = function(time3, iat) {
      var timestamp = iat || Math.floor(Date.now() / 1e3);
      if (typeof time3 === "string") {
        var milliseconds = ms(time3);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp + milliseconds / 1e3);
      } else if (typeof time3 === "number") {
        return timestamp + time3;
      } else {
        return;
      }
    };
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var safeSrc = exports2.safeSrc = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      if (typeof a === "number" && typeof b === "number") {
        return a === b ? 0 : a < b ? -1 : 1;
      }
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof _SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.major < other.major) {
          return -1;
        }
        if (this.major > other.major) {
          return 1;
        }
        if (this.minor < other.minor) {
          return -1;
        }
        if (this.minor > other.minor) {
          return 1;
        }
        if (this.patch < other.patch) {
          return -1;
        }
        if (this.patch > other.patch) {
          return 1;
        }
        return 0;
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse3 = (version2, options, throwErrors = false) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse3;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    "use strict";
    var parse3 = require_parse();
    var valid = (version2, options) => {
      const v = parse3(version2, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    "use strict";
    var parse3 = require_parse();
    var clean = (version2, options) => {
      const s = parse3(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version2, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version2 instanceof SemVer ? version2.version : version2,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    "use strict";
    var parse3 = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse3(version1, null, true);
      const v2 = parse3(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    "use strict";
    var parse3 = require_parse();
    var prerelease = (version2, options) => {
      const parsed = parse3(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse3 = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version2.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse3(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports2, module2) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached2 = cache.get(memoKey);
        if (cached2) {
          return cached2;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      comp = comp.replace(re[t.BUILD], "");
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z2 = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z2} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z2} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z2} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set2, version2, options) => {
      for (let i = 0; i < set2.length; i++) {
        if (!set2[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set2.length; i++) {
          debug(set2[i].semver);
          if (set2[i].semver === Comparator.ANY) {
            continue;
          }
          if (set2[i].semver.prerelease.length > 0) {
            const allowed = set2[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    "use strict";
    var ANY = /* @__PURE__ */ Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var satisfies = (version2, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range, hilo, options) => {
      version2 = new SemVer(version2, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version2, range, options) => outside(version2, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version2, range, options) => outside(version2, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set2 = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version2 of v) {
        const included = satisfies(version2, range, options);
        if (included) {
          prev = version2;
          if (!first) {
            first = version2;
          }
        } else {
          if (prev) {
            set2.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set2.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set2) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse3 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse: parse3,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js"(exports2, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, ">=15.7.0");
  }
});

// node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js"(exports2, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, ">=16.9.0");
  }
});

// node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS({
  "node_modules/jsonwebtoken/lib/validateAsymmetricKey.js"(exports2, module2) {
    var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
    var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
    var allowedAlgorithmsForKeys = {
      "ec": ["ES256", "ES384", "ES512"],
      "rsa": ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
      "rsa-pss": ["PS256", "PS384", "PS512"]
    };
    var allowedCurves = {
      ES256: "prime256v1",
      ES384: "secp384r1",
      ES512: "secp521r1"
    };
    module2.exports = function(algorithm, key) {
      if (!algorithm || !key) return;
      const keyType = key.asymmetricKeyType;
      if (!keyType) return;
      const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
      if (!allowedAlgorithms) {
        throw new Error(`Unknown key type "${keyType}".`);
      }
      if (!allowedAlgorithms.includes(algorithm)) {
        throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
      }
      if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
        switch (keyType) {
          case "ec":
            const keyCurve = key.asymmetricKeyDetails.namedCurve;
            const allowedCurve = allowedCurves[algorithm];
            if (keyCurve !== allowedCurve) {
              throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
            }
            break;
          case "rsa-pss":
            if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
              const length = parseInt(algorithm.slice(-3), 10);
              const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
              if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
              }
              if (saltLength !== void 0 && saltLength > length >> 3) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
              }
            }
            break;
        }
      }
    };
  }
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/psSupported.js"(exports2, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS({
  "node_modules/jsonwebtoken/verify.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode3 = require_decode();
    var timespan = require_timespan();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var { KeyObject, createSecretKey, createPublicKey } = require("crypto");
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    }
    module2.exports = function(jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      options = Object.assign({}, options);
      let done;
      if (callback) {
        done = callback;
      } else {
        done = function(err, data) {
          if (err) throw err;
          return data;
        };
      }
      if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      if (options.allowInvalidAsymmetricKeyTypes !== void 0 && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
        return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
      }
      const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
      }
      const parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      let decodedToken;
      try {
        decodedToken = decode3(jwtString, { complete: true });
      } catch (err) {
        return done(err);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      const header = decodedToken.header;
      let getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        };
      }
      return getSecret(header, function(err, secretOrPublicKey2) {
        if (err) {
          return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        const hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options.algorithms) {
          return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
        }
        if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
          try {
            secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
          } catch (_) {
            try {
              secretOrPublicKey2 = createSecretKey(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
            } catch (_2) {
              return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
            }
          }
        }
        if (!options.algorithms) {
          if (secretOrPublicKey2.type === "secret") {
            options.algorithms = HS_ALGS;
          } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
            options.algorithms = RSA_KEY_ALGS;
          } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
            options.algorithms = EC_KEY_ALGS;
          } else {
            options.algorithms = PUB_KEY_ALGS;
          }
        }
        if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
          return done(new JsonWebTokenError("invalid algorithm"));
        }
        if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
        } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInvalidAsymmetricKeyTypes) {
          try {
            validateAsymmetricKey(header.alg, secretOrPublicKey2);
          } catch (e) {
            return done(e);
          }
        }
        let valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
        if (!valid) {
          return done(new JsonWebTokenError("invalid signature"));
        }
        const payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
            return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options.audience) {
          const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
          const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          const match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options.issuer) {
          const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
          }
        }
        if (options.subject) {
          if (payload.sub !== options.subject) {
            return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
          }
        }
        if (options.jwtid) {
          if (payload.jti !== options.jwtid) {
            return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
          }
        }
        if (options.nonce) {
          if (payload.nonce !== options.nonce) {
            return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
          }
        }
        if (options.maxAge) {
          if (typeof payload.iat !== "number") {
            return done(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options.complete === true) {
          const signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature
          });
        }
        return done(null, payload);
      });
    };
  }
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.includes/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array2, iteratee) {
      var index = -1, length = array2 ? array2.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array2[index], index, array2);
      }
      return result;
    }
    function baseFindIndex(array2, predicate, fromIndex, fromRight) {
      var length = array2.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array2[index], index, array2)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array2, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array2, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array2.length;
      while (++index < length) {
        if (array2[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseValues(object2, props) {
      return arrayMap(props, function(key) {
        return object2[key];
      });
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function keys(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function values(object2) {
      return object2 ? baseValues(object2, keys(object2)) : [];
    }
    module2.exports = includes;
  }
});

// node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.isboolean/index.js"(exports2, module2) {
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = isBoolean;
  }
});

// node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.isinteger/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = isInteger;
  }
});

// node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.isnumber/index.js"(exports2, module2) {
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isNumber(value) {
      return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
    }
    module2.exports = isNumber;
  }
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS({
  "node_modules/lodash.isplainobject/index.js"(exports2, module2) {
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject2(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject2;
  }
});

// node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS({
  "node_modules/lodash.isstring/index.js"(exports2, module2) {
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    module2.exports = isString;
  }
});

// node_modules/lodash.once/index.js
var require_lodash7 = __commonJS({
  "node_modules/lodash.once/index.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function once(func) {
      return before(2, func);
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = once;
  }
});

// node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS({
  "node_modules/jsonwebtoken/sign.js"(exports2, module2) {
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var jws = require_jws();
    var includes = require_lodash();
    var isBoolean = require_lodash2();
    var isInteger = require_lodash3();
    var isNumber = require_lodash4();
    var isPlainObject2 = require_lodash5();
    var isString = require_lodash6();
    var once = require_lodash7();
    var { KeyObject, createSecretKey, createPrivateKey } = require("crypto");
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: function(value) {
        return isString(value) || Array.isArray(value);
      }, message: '"audience" must be a string or array' },
      algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject2, message: '"header" must be an object' },
      encoding: { isValid: isString, message: '"encoding" must be a string' },
      issuer: { isValid: isString, message: '"issuer" must be a string' },
      subject: { isValid: isString, message: '"subject" must be a string' },
      jwtid: { isValid: isString, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
      allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean' },
      allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
    };
    function validate(schema, allowUnknown, object2, parameterName) {
      if (!isPlainObject2(object2)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object2).forEach(function(key) {
        const validator = schema[key];
        if (!validator) {
          if (!allowUnknown) {
            throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator.isValid(object2[key])) {
          throw new Error(validator.message);
        }
      });
    }
    function validateOptions(options) {
      return validate(sign_options_schema, false, options, "options");
    }
    function validatePayload(payload) {
      return validate(registered_claims_schema, true, payload, "payload");
    }
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module2.exports = function(payload, secretOrPrivateKey, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
      const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
      const header = Object.assign({
        alg: options.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options.keyid
      }, options.header);
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      if (!secretOrPrivateKey && options.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
        try {
          secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
        } catch (_) {
          try {
            secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
          } catch (_2) {
            return failure(new Error("secretOrPrivateKey is not valid key material"));
          }
        }
      }
      if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
        return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
        if (secretOrPrivateKey.type !== "private") {
          return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
        secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
          return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error48) {
          return failure(error48);
        }
        if (!options.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        const invalid_options = options_for_objects.filter(function(opt) {
          return typeof options[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions(options);
      } catch (error48) {
        return failure(error48);
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPrivateKey);
        } catch (error48) {
          return failure(error48);
        }
      }
      const timestamp = payload.iat || Math.floor(Date.now() / 1e3);
      if (options.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp;
      }
      if (typeof options.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options.notBefore, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options.expiresIn, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key) {
        const claim = options_to_payload[key];
        if (typeof options[key] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options[key];
        }
      });
      const encoding = options.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding
        }).once("error", callback).once("done", function(signature) {
          if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
            return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
          }
          callback(null, signature);
        });
      } else {
        let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
        }
        return signature;
      }
    };
  }
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "node_modules/jsonwebtoken/index.js"(exports2, module2) {
    module2.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});

// src/handlers/orders/createSupplier.ts
var createSupplier_exports = {};
__export(createSupplier_exports, {
  createSupplier: () => createSupplier
});
module.exports = __toCommonJS(createSupplier_exports);

// src/lib/prisma.ts
var import_client = __toESM(require_default2());
var globalForPrisma = globalThis;
var prisma = globalForPrisma.prisma ?? new import_client.PrismaClient({
  log: ["error", "warn"]
  // pode remover ou ajustar
});
if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;

// node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  codec: () => codec,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  decode: () => decode2,
  decodeAsync: () => decodeAsync2,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode2,
  encodeAsync: () => encodeAsync2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  fromJSONSchema: () => fromJSONSchema,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  mac: () => mac2,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  meta: () => meta2,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse2,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeEncode: () => safeEncode2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  util: () => util_exports,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});

// node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodExactOptional: () => $ZodExactOptional,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMAC: () => $ZodMAC,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $ZodXor: () => $ZodXor,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _check: () => _check,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _mac: () => _mac,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _slugify: () => _slugify,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  _xor: () => _xor,
  clone: () => clone,
  config: () => config,
  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
  createToJSONSchemaMethod: () => createToJSONSchemaMethod,
  decode: () => decode,
  decodeAsync: () => decodeAsync,
  describe: () => describe,
  encode: () => encode,
  encodeAsync: () => encodeAsync,
  extractDefs: () => extractDefs,
  finalize: () => finalize,
  flattenError: () => flattenError,
  formatError: () => formatError,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  initializeContext: () => initializeContext,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  meta: () => meta,
  parse: () => parse,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  process: () => process2,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version
});

// node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer3(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand = /* @__PURE__ */ Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var $ZodEncodeError = class extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}

// node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  parsedType: () => parsedType,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = /* @__PURE__ */ Symbol("evaluating");
function defineLazy(object2, key, getter) {
  let value = void 0;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class2, schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    }
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function parsedType(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base643) {
  const binaryString = atob(base643);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url3) {
  const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array(base643 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var Class = class {
  constructor(..._args) {
  }
};

// node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error48, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error48.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error48, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error49) => {
    for (const issue2 of error49.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error48);
  return fieldErrors;
}
function treeifyError(error48, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error49, path = []) => {
    var _a2, _b;
    for (const issue2 of error49.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error48);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error48) {
  const lines = [];
  const issues = [...error48.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
var _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var encode = /* @__PURE__ */ _encode($ZodRealError);
var _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
var decode = /* @__PURE__ */ _decode($ZodRealError);
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
var _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);

// node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  mac: () => mac,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var mac = (delimiter) => {
  const escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
};
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+[1-9]\d{6,14}$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^-?\d+n?$/;
var integer = /^-?\d+$/;
var number = /^-?\d+(?:\.\d+)?$/;
var boolean = /^(?:true|false)$/i;
var _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 3,
  patch: 6
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy(inst, "~standard", () => ({
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url2 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url2.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv4`;
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv6`;
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac(def.delimiter));
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `mac`;
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64";
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64url";
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject2 = isObject;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const isOptionalOut = el._zod.optout === "optional";
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
      } else {
        handlePropertyResult(r, payload, key, input, isOptionalOut);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc(key);
      const schema = shape[key];
      const isOptionalOut = schema?._zod?.optout === "optional";
      doc.write(`const ${id} = ${parseStr(key)};`);
      if (isOptionalOut) {
        doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      } else {
        doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
  const successes = results.filter((r) => r.issues.length === 0);
  if (successes.length === 1) {
    final.value = successes[0].value;
    return final;
  }
  if (successes.length === 0) {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
  } else {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: false
    });
  }
  return final;
}
var $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
  $ZodUnion.init(inst, def);
  def.inclusive = false;
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        results.push(result);
      }
    }
    if (!async)
      return handleExclusiveUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleExclusiveUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  def.inclusive = false;
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map2 = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map2.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map2.set(v, o);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  const unrecKeys = /* @__PURE__ */ new Map();
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
    const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    const values = def.keyType._zod.values;
    if (values) {
      payload.value = {};
      const recordKeys = /* @__PURE__ */ new Set();
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          recordKeys.add(typeof key === "number" ? key.toString() : key);
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!recordKeys.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        const checkNumericKey = typeof key === "string" && number.test(key) && keyResult.issues.length;
        if (checkNumericKey) {
          const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
          if (retryResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          if (retryResult.issues.length === 0) {
            keyResult = retryResult;
          }
        }
        if (keyResult.issues.length) {
          if (def.mode === "loose") {
            payload.value[key] = input[key];
          } else {
            payload.issues.push({
              code: "invalid_key",
              origin: "record",
              issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
              input: key,
              path: [key],
              inst
            });
          }
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  const values = new Set(def.values);
  inst._zod.values = values;
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
  inst._zod.parse = (payload, ctx) => {
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
  defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "string",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}

// node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  bg: () => bg_default,
  ca: () => ca_default,
  cs: () => cs_default,
  da: () => da_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  hy: () => hy_default,
  id: () => id_default,
  is: () => is_default,
  it: () => it_default,
  ja: () => ja_default,
  ka: () => ka_default,
  kh: () => kh_default,
  km: () => km_default,
  ko: () => ko_default,
  lt: () => lt_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  uk: () => uk_default,
  ur: () => ur_default,
  uz: () => uz_default,
  vi: () => vi_default,
  yo: () => yo_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});

// node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 instanceof ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
        }
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}

// node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n instanceof ${issue2.expected}, daxil olan ${received}`;
        }
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${expected}, daxil olan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}

// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u043B\u0456\u043A",
    array: "\u043C\u0430\u0441\u0456\u045E"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F instanceof ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
        }
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}

// node_modules/zod/v4/locales/bg.js
var error4 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0445\u043E\u0434",
    email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    json_string: "JSON \u043D\u0438\u0437",
    e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
        }
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
        let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
        if (_issue.format === "emoji")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "datetime")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "date")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        if (_issue.format === "time")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "duration")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
    }
  };
};
function bg_default() {
  return {
    localeError: error4()
  };
}

// node_modules/zod/v4/locales/ca.js
var error5 = () => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipus inv\xE0lid: s'esperava instanceof ${issue2.expected}, s'ha rebut ${received}`;
        }
        return `Tipus inv\xE0lid: s'esperava ${expected}, s'ha rebut ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
      case "invalid_element":
        return `Element inv\xE0lid a ${issue2.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error5()
  };
}

// node_modules/zod/v4/locales/cs.js
var error6 = () => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u010D\xEDslo",
    string: "\u0159et\u011Bzec",
    function: "funkce",
    array: "pole"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no instanceof ${issue2.expected}, obdr\u017Eeno ${received}`;
        }
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${expected}, obdr\u017Eeno ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue2.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error6()
  };
}

// node_modules/zod/v4/locales/da.js
var error7 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;
        }
        return `Ugyldigt input: forventede ${expected}, fik ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default() {
  return {
    localeError: error7()
  };
}

// node_modules/zod/v4/locales/de.js
var error8 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "Zahl",
    array: "Array"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ung\xFCltige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;
        }
        return `Ung\xFCltige Eingabe: erwartet ${expected}, erhalten ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue2.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error8()
  };
}

// node_modules/zod/v4/locales/en.js
var error9 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    // Compatibility: "nan" -> "NaN" for display
    nan: "NaN"
    // All other type names omitted - they fall back to raw values via ?? operator
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error9()
  };
}

// node_modules/zod/v4/locales/eo.js
var error10 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombro",
    array: "tabelo",
    null: "senvalora"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nevalida enigo: atendi\u011Dis instanceof ${issue2.expected}, ricevi\u011Dis ${received}`;
        }
        return `Nevalida enigo: atendi\u011Dis ${expected}, ricevi\u011Dis ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error10()
  };
}

// node_modules/zod/v4/locales/es.js
var error11 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entrada inv\xE1lida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;
        }
        return `Entrada inv\xE1lida: se esperaba ${expected}, recibido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
};
function es_default() {
  return {
    localeError: error11()
  };
}

// node_modules/zod/v4/locales/fa.js
var error12 = () => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0622\u0631\u0627\u06CC\u0647"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A instanceof ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
        }
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
};
function fa_default() {
  return {
    localeError: error12()
  };
}

// node_modules/zod/v4/locales/fi.js
var error13 = () => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;
        }
        return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
};
function fi_default() {
  return {
    localeError: error13()
  };
}

// node_modules/zod/v4/locales/fr.js
var error14 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombre",
    array: "tableau"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entr\xE9e invalide : instanceof ${issue2.expected} attendu, ${received} re\xE7u`;
        }
        return `Entr\xE9e invalide : ${expected} attendu, ${received} re\xE7u`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error14()
  };
}

// node_modules/zod/v4/locales/fr-CA.js
var error15 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entr\xE9e invalide : attendu instanceof ${issue2.expected}, re\xE7u ${received}`;
        }
        return `Entr\xE9e invalide : attendu ${expected}, re\xE7u ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error15()
  };
}

// node_modules/zod/v4/locales/he.js
var error16 = () => {
  const TypeNames = {
    string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
    number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
    boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
    array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
    object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
    null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
    undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
    symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
    function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
    map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
    set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
    file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
    value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
  };
  const Sizable = {
    string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
    // no unit
  };
  const typeEntry = (t) => t ? TypeNames[t] : void 0;
  const typeLabel = (t) => {
    const e = typeEntry(t);
    if (e)
      return e.label;
    return t ?? TypeNames.unknown.label;
  };
  const withDefinite = (t) => `\u05D4${typeLabel(t)}`;
  const verbFor = (t) => {
    const e = typeEntry(t);
    const gender = e?.gender ?? "m";
    return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
  };
  const getSizing = (origin) => {
    if (!origin)
      return null;
    return Sizable[origin] ?? null;
  };
  const FormatDictionary = {
    regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
    url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
    time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
    duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
    ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
    ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
    cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
    cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
    base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
    base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
    e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expectedKey = issue2.expected;
        const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA instanceof ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
        }
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
      }
      case "invalid_value": {
        if (issue2.values.length === 1) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive(issue2.values[0])}`;
        }
        const stringified = issue2.values.map((v) => stringifyPrimitive(v));
        if (issue2.values.length === 2) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
        }
        const lastValue = stringified[stringified.length - 1];
        const restValues = stringified.slice(0, -1).join(", ");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
      }
      case "too_big": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue2.maximum}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue2.maximum} ${sizing?.unit ?? ""}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? "<=" : "<";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue2.minimum}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          if (issue2.minimum === 1 && issue2.inclusive) {
            const singularPhrase = issue2.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
          }
          const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue2.minimum} ${sizing?.unit ?? ""}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? ">=" : ">";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        const nounEntry = FormatDictionary[_issue.format];
        const noun = nounEntry?.label ?? _issue.format;
        const gender = nounEntry?.gender ?? "m";
        const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
        return `${noun} \u05DC\u05D0 ${adjective}`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key": {
        return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
      }
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element": {
        const place = withDefinite(issue2.origin ?? "array");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
      }
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
};
function he_default() {
  return {
    localeError: error16()
  };
}

// node_modules/zod/v4/locales/hu.js
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "sz\xE1m",
    array: "t\xF6mb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k instanceof ${issue2.expected}, a kapott \xE9rt\xE9k ${received}`;
        }
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${expected}, a kapott \xE9rt\xE9k ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error17()
  };
}

// node_modules/zod/v4/locales/hy.js
function getArmenianPlural(count, one, many) {
  return Math.abs(count) === 1 ? one : many;
}
function withDefiniteArticle(word) {
  if (!word)
    return "";
  const vowels = ["\u0561", "\u0565", "\u0568", "\u056B", "\u0578", "\u0578\u0582", "\u0585"];
  const lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "\u0576" : "\u0568");
}
var error18 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0576\u0577\u0561\u0576",
        many: "\u0576\u0577\u0561\u0576\u0576\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    file: {
      unit: {
        one: "\u0562\u0561\u0575\u0569",
        many: "\u0562\u0561\u0575\u0569\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    array: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    set: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0574\u0578\u0582\u057F\u0584",
    email: "\u0567\u056C. \u0570\u0561\u057D\u0581\u0565",
    url: "URL",
    emoji: "\u0567\u0574\u0578\u057B\u056B",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E \u0587 \u056A\u0561\u0574",
    date: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E",
    time: "ISO \u056A\u0561\u0574",
    duration: "ISO \u057F\u0587\u0578\u0572\u0578\u0582\u0569\u0575\u0578\u0582\u0576",
    ipv4: "IPv4 \u0570\u0561\u057D\u0581\u0565",
    ipv6: "IPv6 \u0570\u0561\u057D\u0581\u0565",
    cidrv4: "IPv4 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    cidrv6: "IPv6 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    base64: "base64 \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    base64url: "base64url \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    json_string: "JSON \u057F\u0578\u0572",
    e164: "E.164 \u0570\u0561\u0574\u0561\u0580",
    jwt: "JWT",
    template_literal: "\u0574\u0578\u0582\u057F\u0584"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0569\u056B\u057E",
    array: "\u0566\u0561\u0576\u0563\u057E\u0561\u056E"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 instanceof ${issue2.expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
        }
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${stringifyPrimitive(issue2.values[1])}`;
        return `\u054D\u056D\u0561\u056C \u057F\u0561\u0580\u0562\u0565\u0580\u0561\u056F\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 \u0570\u0565\u057F\u0587\u0575\u0561\u056C\u0576\u0565\u0580\u056B\u0581 \u0574\u0565\u056F\u0568\u055D ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056C\u056B\u0576\u056B ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056C\u056B\u0576\u056B ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057D\u056F\u057D\u057E\u056B "${_issue.prefix}"-\u0578\u057E`;
        if (_issue.format === "ends_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0561\u057E\u0561\u0580\u057F\u057E\u056B "${_issue.suffix}"-\u0578\u057E`;
        if (_issue.format === "includes")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057A\u0561\u0580\u0578\u0582\u0576\u0561\u056F\u056B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0570\u0561\u0574\u0561\u057A\u0561\u057F\u0561\u057D\u056D\u0561\u0576\u056B ${_issue.pattern} \u0571\u0587\u0561\u0579\u0561\u0583\u056B\u0576`;
        return `\u054D\u056D\u0561\u056C ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u054D\u056D\u0561\u056C \u0569\u056B\u057E\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0562\u0561\u0566\u0574\u0561\u057A\u0561\u057F\u056B\u056F \u056C\u056B\u0576\u056B ${issue2.divisor}-\u056B`;
      case "unrecognized_keys":
        return `\u0549\u0573\u0561\u0576\u0561\u0579\u057E\u0561\u056E \u0562\u0561\u0576\u0561\u056C\u056B${issue2.keys.length > 1 ? "\u0576\u0565\u0580" : ""}. ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u054D\u056D\u0561\u056C \u0562\u0561\u0576\u0561\u056C\u056B ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
      case "invalid_union":
        return "\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574";
      case "invalid_element":
        return `\u054D\u056D\u0561\u056C \u0561\u0580\u056A\u0565\u0584 ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
      default:
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574`;
    }
  };
};
function hy_default() {
  return {
    localeError: error18()
  };
}

// node_modules/zod/v4/locales/id.js
var error19 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error19()
  };
}

// node_modules/zod/v4/locales/is.js
var error20 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a\xF0 hafa" },
    file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
    array: { unit: "hluti", verb: "a\xF0 hafa" },
    set: { unit: "hluti", verb: "a\xF0 hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmer",
    array: "fylki"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera instanceof ${issue2.expected}`;
        }
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default() {
  return {
    localeError: error20()
  };
}

// node_modules/zod/v4/locales/it.js
var error21 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numero",
    array: "vettore"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;
        }
        return `Input non valido: atteso ${expected}, ricevuto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error21()
  };
}

// node_modules/zod/v4/locales/ja.js
var error22 = () => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5024",
    array: "\u914D\u5217"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u7121\u52B9\u306A\u5165\u529B: instanceof ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
        }
        return `\u7121\u52B9\u306A\u5165\u529B: ${expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
};
function ja_default() {
  return {
    localeError: error22()
  };
}

// node_modules/zod/v4/locales/ka.js
var error23 = () => {
  const Sizable = {
    string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8",
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0",
    array: "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 instanceof ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
        }
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
};
function ka_default() {
  return {
    localeError: error23()
  };
}

// node_modules/zod/v4/locales/km.js
var error24 = () => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u179B\u17C1\u1781",
    array: "\u17A2\u17B6\u179A\u17C1 (Array)",
    null: "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A instanceof ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
        }
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
};
function km_default() {
  return {
    localeError: error24()
  };
}

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}

// node_modules/zod/v4/locales/ko.js
var error25 = () => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 instanceof ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
        }
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
};
function ko_default() {
  return {
    localeError: error25()
  };
}

// node_modules/zod/v4/locales/lt.js
var capitalizeFirstCharacter = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber(number4) {
  const abs = Math.abs(number4);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
var error26 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const FormatDictionary = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "skai\u010Dius",
    bigint: "sveikasis skai\u010Dius",
    string: "eilut\u0117",
    boolean: "login\u0117 reik\u0161m\u0117",
    undefined: "neapibr\u0117\u017Eta reik\u0161m\u0117",
    function: "funkcija",
    symbol: "simbolis",
    array: "masyvas",
    object: "objektas",
    null: "nulin\u0117 reik\u0161m\u0117"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Gautas tipas ${received}, o tik\u0117tasi - instanceof ${issue2.expected}`;
        }
        return `Gautas tipas ${received}, o tik\u0117tasi - ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
};
function lt_default() {
  return {
    localeError: error26()
  };
}

// node_modules/zod/v4/locales/mk.js
var error27 = () => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0431\u0440\u043E\u0458",
    array: "\u043D\u0438\u0437\u0430"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 instanceof ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
        }
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
};
function mk_default() {
  return {
    localeError: error27()
  };
}

// node_modules/zod/v4/locales/ms.js
var error28 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombor"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error28()
  };
}

// node_modules/zod/v4/locales/nl.js
var error29 = () => {
  const Sizable = {
    string: { unit: "tekens", verb: "heeft" },
    file: { unit: "bytes", verb: "heeft" },
    array: { unit: "elementen", verb: "heeft" },
    set: { unit: "elementen", verb: "heeft" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "getal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;
        }
        return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";
        if (sizing)
          return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
        return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";
        if (sizing) {
          return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error29()
  };
}

// node_modules/zod/v4/locales/no.js
var error30 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "tall",
    array: "liste"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;
        }
        return `Ugyldig input: forventet ${expected}, fikk ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error30()
  };
}

// node_modules/zod/v4/locales/ota.js
var error31 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numara",
    array: "saf",
    null: "gayb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `F\xE2sit giren: umulan instanceof ${issue2.expected}, al\u0131nan ${received}`;
        }
        return `F\xE2sit giren: umulan ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error31()
  };
}

// node_modules/zod/v4/locales/ps.js
var error32 = () => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0627\u0631\u06D0"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F instanceof ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
        }
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
};
function ps_default() {
  return {
    localeError: error32()
  };
}

// node_modules/zod/v4/locales/pl.js
var error33 = () => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "liczba",
    array: "tablica"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;
        }
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${expected}, otrzymano ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error33()
  };
}

// node_modules/zod/v4/locales/pt.js
var error34 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmero",
    null: "nulo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipo inv\xE1lido: esperado instanceof ${issue2.expected}, recebido ${received}`;
        }
        return `Tipo inv\xE1lido: esperado ${expected}, recebido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue2.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error34()
  };
}

// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error35 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
};
function ru_default() {
  return {
    localeError: error35()
  };
}

// node_modules/zod/v4/locales/sl.js
var error36 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0161tevilo",
    array: "tabela"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neveljaven vnos: pri\u010Dakovano instanceof ${issue2.expected}, prejeto ${received}`;
        }
        return `Neveljaven vnos: pri\u010Dakovano ${expected}, prejeto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error36()
  };
}

// node_modules/zod/v4/locales/sv.js
var error37 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "antal",
    array: "lista"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ogiltig inmatning: f\xF6rv\xE4ntat instanceof ${issue2.expected}, fick ${received}`;
        }
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${expected}, fick ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error37()
  };
}

// node_modules/zod/v4/locales/ta.js
var error38 = () => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0B8E\u0BA3\u0BCD",
    array: "\u0B85\u0BA3\u0BBF",
    null: "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 instanceof ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
        }
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
};
function ta_default() {
  return {
    localeError: error38()
  };
}

// node_modules/zod/v4/locales/th.js
var error39 = () => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
    array: "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)",
    null: "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 instanceof ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
        }
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
};
function th_default() {
  return {
    localeError: error39()
  };
}

// node_modules/zod/v4/locales/tr.js
var error40 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ge\xE7ersiz de\u011Fer: beklenen instanceof ${issue2.expected}, al\u0131nan ${received}`;
        }
        return `Ge\xE7ersiz de\u011Fer: beklenen ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error40()
  };
}

// node_modules/zod/v4/locales/uk.js
var error41 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F instanceof ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
};
function uk_default() {
  return {
    localeError: error41()
  };
}

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}

// node_modules/zod/v4/locales/ur.js
var error42 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0646\u0645\u0628\u0631",
    array: "\u0622\u0631\u06D2",
    null: "\u0646\u0644"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: instanceof ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
        }
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
};
function ur_default() {
  return {
    localeError: error42()
  };
}

// node_modules/zod/v4/locales/uz.js
var error43 = () => {
  const Sizable = {
    string: { unit: "belgi", verb: "bo\u2018lishi kerak" },
    file: { unit: "bayt", verb: "bo\u2018lishi kerak" },
    array: { unit: "element", verb: "bo\u2018lishi kerak" },
    set: { unit: "element", verb: "bo\u2018lishi kerak" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "kirish",
    email: "elektron pochta manzili",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO sana va vaqti",
    date: "ISO sana",
    time: "ISO vaqt",
    duration: "ISO davomiylik",
    ipv4: "IPv4 manzil",
    ipv6: "IPv6 manzil",
    mac: "MAC manzil",
    cidrv4: "IPv4 diapazon",
    cidrv6: "IPv6 diapazon",
    base64: "base64 kodlangan satr",
    base64url: "base64url kodlangan satr",
    json_string: "JSON satr",
    e164: "E.164 raqam",
    jwt: "JWT",
    template_literal: "kirish"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "raqam",
    array: "massiv"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Noto\u2018g\u2018ri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;
        }
        return `Noto\u2018g\u2018ri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Noto\u2018g\u2018ri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;
        return `Noto\u2018g\u2018ri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
        return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
        if (_issue.format === "ends_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.suffix}" bilan tugashi kerak`;
        if (_issue.format === "includes")
          return `Noto\u2018g\u2018ri satr: "${_issue.includes}" ni o\u2018z ichiga olishi kerak`;
        if (_issue.format === "regex")
          return `Noto\u2018g\u2018ri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
        return `Noto\u2018g\u2018ri ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Noto\u2018g\u2018ri raqam: ${issue2.divisor} ning karralisi bo\u2018lishi kerak`;
      case "unrecognized_keys":
        return `Noma\u2019lum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} dagi kalit noto\u2018g\u2018ri`;
      case "invalid_union":
        return "Noto\u2018g\u2018ri kirish";
      case "invalid_element":
        return `${issue2.origin} da noto\u2018g\u2018ri qiymat`;
      default:
        return `Noto\u2018g\u2018ri kirish`;
    }
  };
};
function uz_default() {
  return {
    localeError: error43()
  };
}

// node_modules/zod/v4/locales/vi.js
var error44 = () => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "s\u1ED1",
    array: "m\u1EA3ng"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i instanceof ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
        }
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
};
function vi_default() {
  return {
    localeError: error44()
  };
}

// node_modules/zod/v4/locales/zh-CN.js
var error45 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5B57",
    array: "\u6570\u7EC4",
    null: "\u7A7A\u503C(null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B instanceof ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
        }
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error45()
  };
}

// node_modules/zod/v4/locales/zh-TW.js
var error46 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA instanceof ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
        }
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error46()
  };
}

// node_modules/zod/v4/locales/yo.js
var error47 = () => {
  const Sizable = {
    string: { unit: "\xE0mi", verb: "n\xED" },
    file: { unit: "bytes", verb: "n\xED" },
    array: { unit: "nkan", verb: "n\xED" },
    set: { unit: "nkan", verb: "n\xED" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\u1ECD\u0301mb\xE0",
    array: "akop\u1ECD"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi instanceof ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
        }
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
};
function yo_default() {
  return {
    localeError: error47()
  };
}

// node_modules/zod/v4/core/registries.js
var _a;
var $output = /* @__PURE__ */ Symbol("ZodOutput");
var $input = /* @__PURE__ */ Symbol("ZodInput");
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta3 = _meta[0];
    this._map.set(schema, meta3);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.set(meta3.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta3 = this._map.get(schema);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.delete(meta3.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
var globalRegistry = globalThis.__zod_globalRegistry;

// node_modules/zod/v4/core/api.js
// @__NO_SIDE_EFFECTS__
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
// @__NO_SIDE_EFFECTS__
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
// @__NO_SIDE_EFFECTS__
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _positive(params) {
  return /* @__PURE__ */ _gt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _negative(params) {
  return /* @__PURE__ */ _lt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonpositive(params) {
  return /* @__PURE__ */ _lte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonnegative(params) {
  return /* @__PURE__ */ _gte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
// @__NO_SIDE_EFFECTS__
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
// @__NO_SIDE_EFFECTS__
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
// @__NO_SIDE_EFFECTS__
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
// @__NO_SIDE_EFFECTS__
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
// @__NO_SIDE_EFFECTS__
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
// @__NO_SIDE_EFFECTS__
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
// @__NO_SIDE_EFFECTS__
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
// @__NO_SIDE_EFFECTS__
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
// @__NO_SIDE_EFFECTS__
function _normalize(form) {
  return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
// @__NO_SIDE_EFFECTS__
function _trim() {
  return /* @__PURE__ */ _overwrite((input) => input.trim());
}
// @__NO_SIDE_EFFECTS__
function _toLowerCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function _toUpperCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function _slugify() {
  return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
// @__NO_SIDE_EFFECTS__
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _xor(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    inclusive: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
// @__NO_SIDE_EFFECTS__
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
// @__NO_SIDE_EFFECTS__
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
// @__NO_SIDE_EFFECTS__
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
// @__NO_SIDE_EFFECTS__
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
// @__NO_SIDE_EFFECTS__
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
// @__NO_SIDE_EFFECTS__
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
// @__NO_SIDE_EFFECTS__
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
// @__NO_SIDE_EFFECTS__
function _superRefine(fn) {
  const ch = /* @__PURE__ */ _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
// @__NO_SIDE_EFFECTS__
function describe(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function meta(metadata) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: ((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    }),
    reverseTransform: ((input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }),
    error: params.error
  });
  return codec2;
}
// @__NO_SIDE_EFFECTS__
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}

// node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {
    }),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a2;
  const def = schema._zod.def;
  const seen = ctx.seen.get(schema);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema, result);
  const overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema) {
      schema._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema, ctx, _json, params);
    }
    const parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process2(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta3 = ctx.metadataRegistry.get(schema);
  if (meta3)
    Object.assign(result.schema, meta3);
  if (ctx.io === "input" && isTransforming(schema)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema);
  return _result.schema;
}
function extractDefs(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = /* @__PURE__ */ new Map();
  for (const entry of ctx.seen.entries()) {
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      const existing = idToSchema.get(id);
      if (existing && existing !== entry[0]) {
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id, entry[0]);
    }
  }
  const makeURI = (entry) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      entry[1].defId = id;
      return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry[1] === root) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  };
  const extractToDef = (entry) => {
    if (entry[1].schema.$ref) {
      return;
    }
    const seen = entry[1];
    const { ref, defId } = makeURI(entry);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema2 = seen.schema;
    for (const key in schema2) {
      delete schema2[key];
    }
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw") {
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.cycle) {
        throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    }
  }
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry);
        continue;
      }
    }
  }
}
function finalize(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = (zodSchema) => {
    const seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    const schema2 = seen.def ?? seen.schema;
    const _cached = { ...schema2 };
    const ref = seen.ref;
    seen.ref = null;
    if (ref) {
      flattenRef(ref);
      const refSeen = ctx.seen.get(ref);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema2.allOf = schema2.allOf ?? [];
        schema2.allOf.push(refSchema);
      } else {
        Object.assign(schema2, refSchema);
      }
      Object.assign(schema2, _cached);
      const isParentRef = zodSchema._zod.parent === ref;
      if (isParentRef) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema2[key];
          }
        }
      }
      if (refSchema.$ref && refSeen.def) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema2[key];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema2.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (const entry of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") {
  } else {
  }
  if (ctx.external?.uri) {
    const id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) {
  } else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  const ctx = initializeContext({ ...params, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
var createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
  const { libraryOptions, target } = params ?? {};
  const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};

// node_modules/zod/v4/core/json-schema-processors.js
var formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
};
var stringProcessor = (schema, ctx, _json, _params) => {
  const json2 = _json;
  json2.type = "string";
  const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum === "number")
    json2.minLength = minimum;
  if (typeof maximum === "number")
    json2.maxLength = maximum;
  if (format) {
    json2.format = formatMap[format] ?? format;
    if (json2.format === "")
      delete json2.format;
    if (format === "time") {
      delete json2.format;
    }
  }
  if (contentEncoding)
    json2.contentEncoding = contentEncoding;
  if (patterns && patterns.size > 0) {
    const regexes = [...patterns];
    if (regexes.length === 1)
      json2.pattern = regexes[0].source;
    else if (regexes.length > 1) {
      json2.allOf = [
        ...regexes.map((regex) => ({
          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
          pattern: regex.source
        }))
      ];
    }
  }
};
var numberProcessor = (schema, ctx, _json, _params) => {
  const json2 = _json;
  const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  if (typeof format === "string" && format.includes("int"))
    json2.type = "integer";
  else
    json2.type = "number";
  if (typeof exclusiveMinimum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json2.minimum = exclusiveMinimum;
      json2.exclusiveMinimum = true;
    } else {
      json2.exclusiveMinimum = exclusiveMinimum;
    }
  }
  if (typeof minimum === "number") {
    json2.minimum = minimum;
    if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMinimum >= minimum)
        delete json2.minimum;
      else
        delete json2.exclusiveMinimum;
    }
  }
  if (typeof exclusiveMaximum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json2.maximum = exclusiveMaximum;
      json2.exclusiveMaximum = true;
    } else {
      json2.exclusiveMaximum = exclusiveMaximum;
    }
  }
  if (typeof maximum === "number") {
    json2.maximum = maximum;
    if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMaximum <= maximum)
        delete json2.maximum;
      else
        delete json2.exclusiveMaximum;
    }
  }
  if (typeof multipleOf === "number")
    json2.multipleOf = multipleOf;
};
var booleanProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
};
var bigintProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("BigInt cannot be represented in JSON Schema");
  }
};
var symbolProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Symbols cannot be represented in JSON Schema");
  }
};
var nullProcessor = (_schema, ctx, json2, _params) => {
  if (ctx.target === "openapi-3.0") {
    json2.type = "string";
    json2.nullable = true;
    json2.enum = [null];
  } else {
    json2.type = "null";
  }
};
var undefinedProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Undefined cannot be represented in JSON Schema");
  }
};
var voidProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Void cannot be represented in JSON Schema");
  }
};
var neverProcessor = (_schema, _ctx, json2, _params) => {
  json2.not = {};
};
var anyProcessor = (_schema, _ctx, _json, _params) => {
};
var unknownProcessor = (_schema, _ctx, _json, _params) => {
};
var dateProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Date cannot be represented in JSON Schema");
  }
};
var enumProcessor = (schema, _ctx, json2, _params) => {
  const def = schema._zod.def;
  const values = getEnumValues(def.entries);
  if (values.every((v) => typeof v === "number"))
    json2.type = "number";
  if (values.every((v) => typeof v === "string"))
    json2.type = "string";
  json2.enum = values;
};
var literalProcessor = (schema, ctx, json2, _params) => {
  const def = schema._zod.def;
  const vals = [];
  for (const val of def.values) {
    if (val === void 0) {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
      } else {
      }
    } else if (typeof val === "bigint") {
      if (ctx.unrepresentable === "throw") {
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      } else {
        vals.push(Number(val));
      }
    } else {
      vals.push(val);
    }
  }
  if (vals.length === 0) {
  } else if (vals.length === 1) {
    const val = vals[0];
    json2.type = val === null ? "null" : typeof val;
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json2.enum = [val];
    } else {
      json2.const = val;
    }
  } else {
    if (vals.every((v) => typeof v === "number"))
      json2.type = "number";
    if (vals.every((v) => typeof v === "string"))
      json2.type = "string";
    if (vals.every((v) => typeof v === "boolean"))
      json2.type = "boolean";
    if (vals.every((v) => v === null))
      json2.type = "null";
    json2.enum = vals;
  }
};
var nanProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("NaN cannot be represented in JSON Schema");
  }
};
var templateLiteralProcessor = (schema, _ctx, json2, _params) => {
  const _json = json2;
  const pattern = schema._zod.pattern;
  if (!pattern)
    throw new Error("Pattern not found in template literal");
  _json.type = "string";
  _json.pattern = pattern.source;
};
var fileProcessor = (schema, _ctx, json2, _params) => {
  const _json = json2;
  const file2 = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  };
  const { minimum, maximum, mime } = schema._zod.bag;
  if (minimum !== void 0)
    file2.minLength = minimum;
  if (maximum !== void 0)
    file2.maxLength = maximum;
  if (mime) {
    if (mime.length === 1) {
      file2.contentMediaType = mime[0];
      Object.assign(_json, file2);
    } else {
      Object.assign(_json, file2);
      _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
    }
  } else {
    Object.assign(_json, file2);
  }
};
var successProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
};
var customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Custom types cannot be represented in JSON Schema");
  }
};
var functionProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Function types cannot be represented in JSON Schema");
  }
};
var transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Transforms cannot be represented in JSON Schema");
  }
};
var mapProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Map cannot be represented in JSON Schema");
  }
};
var setProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Set cannot be represented in JSON Schema");
  }
};
var arrayProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json2.minItems = minimum;
  if (typeof maximum === "number")
    json2.maxItems = maximum;
  json2.type = "array";
  json2.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
};
var objectProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  json2.type = "object";
  json2.properties = {};
  const shape = def.shape;
  for (const key in shape) {
    json2.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  }
  const allKeys = new Set(Object.keys(shape));
  const requiredKeys = new Set([...allKeys].filter((key) => {
    const v = def.shape[key]._zod;
    if (ctx.io === "input") {
      return v.optin === void 0;
    } else {
      return v.optout === void 0;
    }
  }));
  if (requiredKeys.size > 0) {
    json2.required = Array.from(requiredKeys);
  }
  if (def.catchall?._zod.def.type === "never") {
    json2.additionalProperties = false;
  } else if (!def.catchall) {
    if (ctx.io === "output")
      json2.additionalProperties = false;
  } else if (def.catchall) {
    json2.additionalProperties = process2(def.catchall, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
};
var unionProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  const isExclusive = def.inclusive === false;
  const options = def.options.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  if (isExclusive) {
    json2.oneOf = options;
  } else {
    json2.anyOf = options;
  }
};
var intersectionProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  const a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  });
  const b = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  });
  const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
  const allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json2.allOf = allOf;
};
var tupleProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  json2.type = "array";
  const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
  const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
  const prefixItems = def.items.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, prefixPath, i]
  }));
  const rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  if (ctx.target === "draft-2020-12") {
    json2.prefixItems = prefixItems;
    if (rest) {
      json2.items = rest;
    }
  } else if (ctx.target === "openapi-3.0") {
    json2.items = {
      anyOf: prefixItems
    };
    if (rest) {
      json2.items.anyOf.push(rest);
    }
    json2.minItems = prefixItems.length;
    if (!rest) {
      json2.maxItems = prefixItems.length;
    }
  } else {
    json2.items = prefixItems;
    if (rest) {
      json2.additionalItems = rest;
    }
  }
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json2.minItems = minimum;
  if (typeof maximum === "number")
    json2.maxItems = maximum;
};
var recordProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  json2.type = "object";
  const keyType = def.keyType;
  const keyBag = keyType._zod.bag;
  const patterns = keyBag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    const valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json2.patternProperties = {};
    for (const pattern of patterns) {
      json2.patternProperties[pattern.source] = valueSchema;
    }
  } else {
    if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
      json2.propertyNames = process2(def.keyType, ctx, {
        ...params,
        path: [...params.path, "propertyNames"]
      });
    }
    json2.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
  const keyValues = keyType._zod.values;
  if (keyValues) {
    const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
    if (validKeyValues.length > 0) {
      json2.required = validKeyValues;
    }
  }
};
var nullableProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  const inner = process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  if (ctx.target === "openapi-3.0") {
    seen.ref = def.innerType;
    json2.nullable = true;
  } else {
    json2.anyOf = [inner, { type: "null" }];
  }
};
var nonoptionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var defaultProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json2.default = JSON.parse(JSON.stringify(def.defaultValue));
};
var prefaultProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  if (ctx.io === "input")
    json2._prefault = JSON.parse(JSON.stringify(def.defaultValue));
};
var catchProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json2.default = catchValue;
};
var pipeProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
var readonlyProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json2.readOnly = true;
};
var promiseProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var optionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var lazyProcessor = (schema, ctx, _json, params) => {
  const innerType = schema._zod.innerType;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
var allProcessors = {
  string: stringProcessor,
  number: numberProcessor,
  boolean: booleanProcessor,
  bigint: bigintProcessor,
  symbol: symbolProcessor,
  null: nullProcessor,
  undefined: undefinedProcessor,
  void: voidProcessor,
  never: neverProcessor,
  any: anyProcessor,
  unknown: unknownProcessor,
  date: dateProcessor,
  enum: enumProcessor,
  literal: literalProcessor,
  nan: nanProcessor,
  template_literal: templateLiteralProcessor,
  file: fileProcessor,
  success: successProcessor,
  custom: customProcessor,
  function: functionProcessor,
  transform: transformProcessor,
  map: mapProcessor,
  set: setProcessor,
  array: arrayProcessor,
  object: objectProcessor,
  union: unionProcessor,
  intersection: intersectionProcessor,
  tuple: tupleProcessor,
  record: recordProcessor,
  nullable: nullableProcessor,
  nonoptional: nonoptionalProcessor,
  default: defaultProcessor,
  prefault: prefaultProcessor,
  catch: catchProcessor,
  pipe: pipeProcessor,
  readonly: readonlyProcessor,
  promise: promiseProcessor,
  optional: optionalProcessor,
  lazy: lazyProcessor
};
function toJSONSchema(input, params) {
  if ("_idmap" in input) {
    const registry2 = input;
    const ctx2 = initializeContext({ ...params, processors: allProcessors });
    const defs = {};
    for (const entry of registry2._idmap.entries()) {
      const [_, schema] = entry;
      process2(schema, ctx2);
    }
    const schemas = {};
    const external = {
      registry: registry2,
      uri: params?.uri,
      defs
    };
    ctx2.external = external;
    for (const entry of registry2._idmap.entries()) {
      const [key, schema] = entry;
      extractDefs(ctx2, schema);
      schemas[key] = finalize(ctx2, schema);
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const ctx = initializeContext({ ...params, processors: allProcessors });
  process2(input, ctx);
  extractDefs(ctx, input);
  return finalize(ctx, input);
}

// node_modules/zod/v4/core/json-schema-generator.js
var JSONSchemaGenerator = class {
  /** @deprecated Access via ctx instead */
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  /** @deprecated Access via ctx instead */
  get target() {
    return this.ctx.target;
  }
  /** @deprecated Access via ctx instead */
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  /** @deprecated Access via ctx instead */
  get override() {
    return this.ctx.override;
  }
  /** @deprecated Access via ctx instead */
  get io() {
    return this.ctx.io;
  }
  /** @deprecated Access via ctx instead */
  get counter() {
    return this.ctx.counter;
  }
  set counter(value) {
    this.ctx.counter = value;
  }
  /** @deprecated Access via ctx instead */
  get seen() {
    return this.ctx.seen;
  }
  constructor(params) {
    let normalizedTarget = params?.target ?? "draft-2020-12";
    if (normalizedTarget === "draft-4")
      normalizedTarget = "draft-04";
    if (normalizedTarget === "draft-7")
      normalizedTarget = "draft-07";
    this.ctx = initializeContext({
      processors: allProcessors,
      target: normalizedTarget,
      ...params?.metadata && { metadata: params.metadata },
      ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
      ...params?.override && { override: params.override },
      ...params?.io && { io: params.io }
    });
  }
  /**
   * Process a schema to prepare it for JSON Schema generation.
   * This must be called before emit().
   */
  process(schema, _params = { path: [], schemaPath: [] }) {
    return process2(schema, this.ctx, _params);
  }
  /**
   * Emit the final JSON Schema after processing.
   * Must call process() first.
   */
  emit(schema, _params) {
    if (_params) {
      if (_params.cycles)
        this.ctx.cycles = _params.cycles;
      if (_params.reused)
        this.ctx.reused = _params.reused;
      if (_params.external)
        this.ctx.external = _params.external;
    }
    extractDefs(this.ctx, schema);
    const result = finalize(this.ctx, schema);
    const { "~standard": _, ...plainResult } = result;
    return plainResult;
  }
};

// node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};

// node_modules/zod/v4/classic/schemas.js
var schemas_exports2 = {};
__export(schemas_exports2, {
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodIntersection: () => ZodIntersection,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  codec: () => codec,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  float32: () => float32,
  float64: () => float64,
  function: () => _function,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  literal: () => literal,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  mac: () => mac2,
  map: () => map,
  meta: () => meta2,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  never: () => never,
  nonoptional: () => nonoptional,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  prefault: () => prefault,
  preprocess: () => preprocess,
  promise: () => promise,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  set: () => set,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  transform: () => transform,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});

// node_modules/zod/v4/classic/checks.js
var checks_exports2 = {};
__export(checks_exports2, {
  endsWith: () => _endsWith,
  gt: () => _gt,
  gte: () => _gte,
  includes: () => _includes,
  length: () => _length,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  negative: () => _negative,
  nonnegative: () => _nonnegative,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  overwrite: () => _overwrite,
  positive: () => _positive,
  property: () => _property,
  regex: () => _regex,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  trim: () => _trim,
  uppercase: () => _uppercase
});

// node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse2 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
var encode2 = /* @__PURE__ */ _encode(ZodRealError);
var decode2 = /* @__PURE__ */ _decode(ZodRealError);
var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  Object.assign(inst["~standard"], {
    jsonSchema: {
      input: createStandardJSONSchemaMethod(inst, "input"),
      output: createStandardJSONSchemaMethod(inst, "output")
    }
  });
  inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(util_exports.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }), {
      parent: true
    });
  };
  inst.with = inst.check;
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta3) => {
    reg.add(inst, meta3);
    return inst;
  });
  inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode2(inst, data, params);
  inst.decode = (data, params) => decode2(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.exactOptional = () => exactOptional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  inst.apply = (fn) => fn(inst);
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => stringProcessor(inst, ctx, json2, params);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
  inst.slugify = () => inst.check(_slugify());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
  $ZodMAC.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function mac2(params) {
  return _mac(ZodMAC, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes_exports[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => numberProcessor(inst, ctx, json2, params);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => booleanProcessor(inst, ctx, json2, params);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => bigintProcessor(inst, ctx, json2, params);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => symbolProcessor(inst, ctx, json2, params);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => undefinedProcessor(inst, ctx, json2, params);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nullProcessor(inst, ctx, json2, params);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => anyProcessor(inst, ctx, json2, params);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => unknownProcessor(inst, ctx, json2, params);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => neverProcessor(inst, ctx, json2, params);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => voidProcessor(inst, ctx, json2, params);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => dateProcessor(inst, ctx, json2, params);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => arrayProcessor(inst, ctx, json2, params);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => objectProcessor(inst, ctx, json2, params);
  util_exports.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return util_exports.safeExtend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
var ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodXor.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params);
  inst.options = def.options;
});
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: false,
    ...util_exports.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => intersectionProcessor(inst, ctx, json2, params);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => tupleProcessor(inst, ctx, json2, params);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => recordProcessor(inst, ctx, json2, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = void 0;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...util_exports.normalizeParams(params)
  });
}
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => mapProcessor(inst, ctx, json2, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => setProcessor(inst, ctx, json2, params);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => enumProcessor(inst, ctx, json2, params);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => literalProcessor(inst, ctx, json2, params);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => fileProcessor(inst, ctx, json2, params);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => transformProcessor(inst, ctx, json2, params);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nullableProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => defaultProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => prefaultProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nonoptionalProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => successProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => catchProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nanProcessor(inst, ctx, json2, params);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => pipeProcessor(inst, ctx, json2, params);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => readonlyProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => templateLiteralProcessor(inst, ctx, json2, params);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => lazyProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => promiseProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => functionProcessor(inst, ctx, json2, params);
});
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => customProcessor(inst, ctx, json2, params);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
var describe2 = describe;
var meta2 = meta;
function _instanceof(cls, params = {}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls)) {
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
    }
  };
  return inst;
}
var stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args);
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}

// node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
/* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

// node_modules/zod/v4/classic/from-json-schema.js
var z = {
  ...schemas_exports2,
  ...checks_exports2,
  iso: iso_exports
};
var RECOGNIZED_KEYS = /* @__PURE__ */ new Set([
  // Schema identification
  "$schema",
  "$ref",
  "$defs",
  "definitions",
  // Core schema keywords
  "$id",
  "id",
  "$comment",
  "$anchor",
  "$vocabulary",
  "$dynamicRef",
  "$dynamicAnchor",
  // Type
  "type",
  "enum",
  "const",
  // Composition
  "anyOf",
  "oneOf",
  "allOf",
  "not",
  // Object
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "propertyNames",
  "minProperties",
  "maxProperties",
  // Array
  "items",
  "prefixItems",
  "additionalItems",
  "minItems",
  "maxItems",
  "uniqueItems",
  "contains",
  "minContains",
  "maxContains",
  // String
  "minLength",
  "maxLength",
  "pattern",
  "format",
  // Number
  "minimum",
  "maximum",
  "exclusiveMinimum",
  "exclusiveMaximum",
  "multipleOf",
  // Already handled metadata
  "description",
  "default",
  // Content
  "contentEncoding",
  "contentMediaType",
  "contentSchema",
  // Unsupported (error-throwing)
  "unevaluatedItems",
  "unevaluatedProperties",
  "if",
  "then",
  "else",
  "dependentSchemas",
  "dependentRequired",
  // OpenAPI
  "nullable",
  "readOnly"
]);
function detectVersion(schema, defaultTarget) {
  const $schema = schema.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema") {
    return "draft-2020-12";
  }
  if ($schema === "http://json-schema.org/draft-07/schema#") {
    return "draft-7";
  }
  if ($schema === "http://json-schema.org/draft-04/schema#") {
    return "draft-4";
  }
  return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref, ctx) {
  if (!ref.startsWith("#")) {
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  }
  const path = ref.slice(1).split("/").filter(Boolean);
  if (path.length === 0) {
    return ctx.rootSchema;
  }
  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path[0] === defsKey) {
    const key = path[1];
    if (!key || !ctx.defs[key]) {
      throw new Error(`Reference not found: ${ref}`);
    }
    return ctx.defs[key];
  }
  throw new Error(`Reference not found: ${ref}`);
}
function convertBaseSchema(schema, ctx) {
  if (schema.not !== void 0) {
    if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
      return z.never();
    }
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema.unevaluatedItems !== void 0) {
    throw new Error("unevaluatedItems is not supported");
  }
  if (schema.unevaluatedProperties !== void 0) {
    throw new Error("unevaluatedProperties is not supported");
  }
  if (schema.if !== void 0 || schema.then !== void 0 || schema.else !== void 0) {
    throw new Error("Conditional schemas (if/then/else) are not supported");
  }
  if (schema.dependentSchemas !== void 0 || schema.dependentRequired !== void 0) {
    throw new Error("dependentSchemas and dependentRequired are not supported");
  }
  if (schema.$ref) {
    const refPath = schema.$ref;
    if (ctx.refs.has(refPath)) {
      return ctx.refs.get(refPath);
    }
    if (ctx.processing.has(refPath)) {
      return z.lazy(() => {
        if (!ctx.refs.has(refPath)) {
          throw new Error(`Circular reference not resolved: ${refPath}`);
        }
        return ctx.refs.get(refPath);
      });
    }
    ctx.processing.add(refPath);
    const resolved = resolveRef(refPath, ctx);
    const zodSchema2 = convertSchema(resolved, ctx);
    ctx.refs.set(refPath, zodSchema2);
    ctx.processing.delete(refPath);
    return zodSchema2;
  }
  if (schema.enum !== void 0) {
    const enumValues = schema.enum;
    if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
      return z.null();
    }
    if (enumValues.length === 0) {
      return z.never();
    }
    if (enumValues.length === 1) {
      return z.literal(enumValues[0]);
    }
    if (enumValues.every((v) => typeof v === "string")) {
      return z.enum(enumValues);
    }
    const literalSchemas = enumValues.map((v) => z.literal(v));
    if (literalSchemas.length < 2) {
      return literalSchemas[0];
    }
    return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema.const !== void 0) {
    return z.literal(schema.const);
  }
  const type = schema.type;
  if (Array.isArray(type)) {
    const typeSchemas = type.map((t) => {
      const typeSchema = { ...schema, type: t };
      return convertBaseSchema(typeSchema, ctx);
    });
    if (typeSchemas.length === 0) {
      return z.never();
    }
    if (typeSchemas.length === 1) {
      return typeSchemas[0];
    }
    return z.union(typeSchemas);
  }
  if (!type) {
    return z.any();
  }
  let zodSchema;
  switch (type) {
    case "string": {
      let stringSchema = z.string();
      if (schema.format) {
        const format = schema.format;
        if (format === "email") {
          stringSchema = stringSchema.check(z.email());
        } else if (format === "uri" || format === "uri-reference") {
          stringSchema = stringSchema.check(z.url());
        } else if (format === "uuid" || format === "guid") {
          stringSchema = stringSchema.check(z.uuid());
        } else if (format === "date-time") {
          stringSchema = stringSchema.check(z.iso.datetime());
        } else if (format === "date") {
          stringSchema = stringSchema.check(z.iso.date());
        } else if (format === "time") {
          stringSchema = stringSchema.check(z.iso.time());
        } else if (format === "duration") {
          stringSchema = stringSchema.check(z.iso.duration());
        } else if (format === "ipv4") {
          stringSchema = stringSchema.check(z.ipv4());
        } else if (format === "ipv6") {
          stringSchema = stringSchema.check(z.ipv6());
        } else if (format === "mac") {
          stringSchema = stringSchema.check(z.mac());
        } else if (format === "cidr") {
          stringSchema = stringSchema.check(z.cidrv4());
        } else if (format === "cidr-v6") {
          stringSchema = stringSchema.check(z.cidrv6());
        } else if (format === "base64") {
          stringSchema = stringSchema.check(z.base64());
        } else if (format === "base64url") {
          stringSchema = stringSchema.check(z.base64url());
        } else if (format === "e164") {
          stringSchema = stringSchema.check(z.e164());
        } else if (format === "jwt") {
          stringSchema = stringSchema.check(z.jwt());
        } else if (format === "emoji") {
          stringSchema = stringSchema.check(z.emoji());
        } else if (format === "nanoid") {
          stringSchema = stringSchema.check(z.nanoid());
        } else if (format === "cuid") {
          stringSchema = stringSchema.check(z.cuid());
        } else if (format === "cuid2") {
          stringSchema = stringSchema.check(z.cuid2());
        } else if (format === "ulid") {
          stringSchema = stringSchema.check(z.ulid());
        } else if (format === "xid") {
          stringSchema = stringSchema.check(z.xid());
        } else if (format === "ksuid") {
          stringSchema = stringSchema.check(z.ksuid());
        }
      }
      if (typeof schema.minLength === "number") {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (typeof schema.maxLength === "number") {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      if (schema.pattern) {
        stringSchema = stringSchema.regex(new RegExp(schema.pattern));
      }
      zodSchema = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type === "integer" ? z.number().int() : z.number();
      if (typeof schema.minimum === "number") {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === "number") {
        numberSchema = numberSchema.max(schema.maximum);
      }
      if (typeof schema.exclusiveMinimum === "number") {
        numberSchema = numberSchema.gt(schema.exclusiveMinimum);
      } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
        numberSchema = numberSchema.gt(schema.minimum);
      }
      if (typeof schema.exclusiveMaximum === "number") {
        numberSchema = numberSchema.lt(schema.exclusiveMaximum);
      } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
        numberSchema = numberSchema.lt(schema.maximum);
      }
      if (typeof schema.multipleOf === "number") {
        numberSchema = numberSchema.multipleOf(schema.multipleOf);
      }
      zodSchema = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema = z.boolean();
      break;
    }
    case "null": {
      zodSchema = z.null();
      break;
    }
    case "object": {
      const shape = {};
      const properties = schema.properties || {};
      const requiredSet = new Set(schema.required || []);
      for (const [key, propSchema] of Object.entries(properties)) {
        const propZodSchema = convertSchema(propSchema, ctx);
        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
      }
      if (schema.propertyNames) {
        const keySchema = convertSchema(schema.propertyNames, ctx);
        const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
        if (Object.keys(shape).length === 0) {
          zodSchema = z.record(keySchema, valueSchema);
          break;
        }
        const objectSchema2 = z.object(shape).passthrough();
        const recordSchema = z.looseRecord(keySchema, valueSchema);
        zodSchema = z.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema.patternProperties) {
        const patternProps = schema.patternProperties;
        const patternKeys = Object.keys(patternProps);
        const looseRecords = [];
        for (const pattern of patternKeys) {
          const patternValue = convertSchema(patternProps[pattern], ctx);
          const keySchema = z.string().regex(new RegExp(pattern));
          looseRecords.push(z.looseRecord(keySchema, patternValue));
        }
        const schemasToIntersect = [];
        if (Object.keys(shape).length > 0) {
          schemasToIntersect.push(z.object(shape).passthrough());
        }
        schemasToIntersect.push(...looseRecords);
        if (schemasToIntersect.length === 0) {
          zodSchema = z.object({}).passthrough();
        } else if (schemasToIntersect.length === 1) {
          zodSchema = schemasToIntersect[0];
        } else {
          let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i = 2; i < schemasToIntersect.length; i++) {
            result = z.intersection(result, schemasToIntersect[i]);
          }
          zodSchema = result;
        }
        break;
      }
      const objectSchema = z.object(shape);
      if (schema.additionalProperties === false) {
        zodSchema = objectSchema.strict();
      } else if (typeof schema.additionalProperties === "object") {
        zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
      } else {
        zodSchema = objectSchema.passthrough();
      }
      break;
    }
    case "array": {
      const prefixItems = schema.prefixItems;
      const items = schema.items;
      if (prefixItems && Array.isArray(prefixItems)) {
        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (Array.isArray(items)) {
        const tupleItems = items.map((item) => convertSchema(item, ctx));
        const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (items !== void 0) {
        const element = convertSchema(items, ctx);
        let arraySchema = z.array(element);
        if (typeof schema.minItems === "number") {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (typeof schema.maxItems === "number") {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        zodSchema = arraySchema;
      } else {
        zodSchema = z.array(z.any());
      }
      break;
    }
    default:
      throw new Error(`Unsupported type: ${type}`);
  }
  if (schema.description) {
    zodSchema = zodSchema.describe(schema.description);
  }
  if (schema.default !== void 0) {
    zodSchema = zodSchema.default(schema.default);
  }
  return zodSchema;
}
function convertSchema(schema, ctx) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  let baseSchema = convertBaseSchema(schema, ctx);
  const hasExplicitType = schema.type || schema.enum !== void 0 || schema.const !== void 0;
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const options = schema.anyOf.map((s) => convertSchema(s, ctx));
    const anyOfUnion = z.union(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const options = schema.oneOf.map((s) => convertSchema(s, ctx));
    const oneOfUnion = z.xor(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema.allOf && Array.isArray(schema.allOf)) {
    if (schema.allOf.length === 0) {
      baseSchema = hasExplicitType ? baseSchema : z.any();
    } else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
      const startIdx = hasExplicitType ? 0 : 1;
      for (let i = startIdx; i < schema.allOf.length; i++) {
        result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
      }
      baseSchema = result;
    }
  }
  if (schema.nullable === true && ctx.version === "openapi-3.0") {
    baseSchema = z.nullable(baseSchema);
  }
  if (schema.readOnly === true) {
    baseSchema = z.readonly(baseSchema);
  }
  const extraMeta = {};
  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (const key of coreMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (const key of contentMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  for (const key of Object.keys(schema)) {
    if (!RECOGNIZED_KEYS.has(key)) {
      extraMeta[key] = schema[key];
    }
  }
  if (Object.keys(extraMeta).length > 0) {
    ctx.registry.add(baseSchema, extraMeta);
  }
  return baseSchema;
}
function fromJSONSchema(schema, params) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  const version2 = detectVersion(schema, params?.defaultTarget);
  const defs = schema.$defs || schema.definitions || {};
  const ctx = {
    version: version2,
    defs,
    refs: /* @__PURE__ */ new Map(),
    processing: /* @__PURE__ */ new Set(),
    rootSchema: schema,
    registry: params?.registry ?? globalRegistry
  };
  return convertSchema(schema, ctx);
}

// node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/zod/v4/classic/external.js
config(en_default());

// src/handlers/orders/createSupplier.ts
var import_crypto = __toESM(require("crypto"));

// src/middleware/authMiddleware.ts
var import_jsonwebtoken = __toESM(require_jsonwebtoken());
var JWT_SECRET = process.env.JWT_SECRET || "secret-jwt-sttart";
function verifyToken(event) {
  const authHeader = event.headers.Authorization || event.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    throw new Error("Token ausente ou malformado");
  }
  const token = authHeader.split(" ")[1];
  try {
    const decoded = import_jsonwebtoken.default.verify(token, JWT_SECRET);
    return decoded;
  } catch (error48) {
    throw new Error("Token inv\xE1lido");
  }
}

// src/handlers/orders/createSupplier.ts
var orderTypeSchema = external_exports.enum([
  "TRX",
  "WIRE",
  "USDT",
  "EFETIVO",
  "TRANSFERENCIA",
  "AJUSTE_SALDO",
  "ACERTO_IMPOSTO"
]);
var destinationTypeSchema = external_exports.enum(["AUTO", "PIX", "WALLET", "IBAN", "ACCOUNT"]).optional();
var pixKeyTypeSchema = external_exports.enum(["cpf", "cnpj", "email", "phone", "random"]).optional();
var beneficiaryInlineSchema = external_exports.object({
  name: external_exports.string().min(2),
  document: external_exports.string().min(11),
  pix_key: external_exports.string().min(3),
  key_type: pixKeyTypeSchema,
  label: external_exports.string().optional()
});
var createSupplierOrderSchema = external_exports.object({
  id: external_exports.string().min(6),
  customer_id: external_exports.string().min(6),
  customer_type: external_exports.string().min(1),
  bank_name: external_exports.string().min(1),
  // supplier  PIX
  type: orderTypeSchema.default("TRANSFERENCIA"),
  total_amount: external_exports.number().positive(),
  sub_amount: external_exports.number().positive(),
  bank_account_id: external_exports.string().min(6),
  // opcional: mas voc j suporta
  base_amount: external_exports.number().nonnegative().optional(),
  rate: external_exports.number().positive().optional(),
  fees_amount: external_exports.number().nonnegative().optional(),
  base_currency: external_exports.string().optional(),
  settlement_currency: external_exports.string().optional(),
  idempotency_key: external_exports.string().optional(),
  metadata: external_exports.any().optional(),
  destinations: external_exports.array(
    external_exports.object({
      destination: external_exports.string().optional(),
      destination_pix_key: external_exports.string().optional(),
      label: external_exports.string().optional(),
      beneficiary_id: external_exports.string().optional(),
      beneficiary: beneficiaryInlineSchema.optional(),
      amount: external_exports.number().positive().optional(),
      // proibido aqui
      destination_type: destinationTypeSchema
    })
  ).length(1)
});
function chunkAmount(total, chunk) {
  const res = [];
  let remaining = Number(total.toFixed(2));
  const c = Number(chunk.toFixed(2));
  while (remaining > 0) {
    const part = remaining >= c ? c : remaining;
    res.push(Number(part.toFixed(2)));
    remaining = Number((remaining - part).toFixed(2));
  }
  return res;
}
function digitsOnly(v) {
  return (v || "").replace(/\D/g, "");
}
function ensureCpfCnpjDigits(doc) {
  const d = digitsOnly(doc);
  if (!(d.length === 11 || d.length === 14)) {
    throw new Error(`beneficiary.document deve ser CPF(11) ou CNPJ(14). Recebido: ${doc}`);
  }
  return d;
}
var createSupplier = async (event) => {
  try {
    verifyToken(event);
    const body = JSON.parse(event.body || "{}");
    const parsed = createSupplierOrderSchema.safeParse(body);
    if (!parsed.success) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: "Invalid payload", details: parsed.error.flatten() })
      };
    }
    const data = parsed.data;
    const isPix = data.type === "TRANSFERENCIA";
    if (!isPix) {
      return { statusCode: 400, body: JSON.stringify({ error: "SUPPLIER deve ser type TRANSFERENCIA (PIX)." }) };
    }
    const base_amount = data.base_amount ?? data.total_amount;
    const rate = data.rate ?? 1;
    const fees_amount = data.fees_amount ?? 0;
    const base_currency = data.base_currency ?? "BRL";
    const settlement_currency = data.settlement_currency ?? "BRL";
    const payer = await prisma.core_bank_accounts.findUnique({
      where: { id: data.bank_account_id },
      select: { id: true, active: true, purpose: true, provider: true }
    });
    if (!payer) return { statusCode: 404, body: JSON.stringify({ error: "bank_account_id n\xE3o encontrado" }) };
    if (!payer.active) return { statusCode: 400, body: JSON.stringify({ error: "Conta pagadora est\xE1 inativa" }) };
    if (payer.purpose !== "PAYOUT") {
      return { statusCode: 400, body: JSON.stringify({ error: "bank_account_id precisa ser uma conta PAYOUT" }) };
    }
    const d0 = data.destinations[0];
    if (d0.amount != null) {
      return {
        statusCode: 400,
        body: JSON.stringify({
          error: "Nesta vers\xE3o n\xE3o use amount em destinations. Use total_amount + sub_amount (fracionamento autom\xE1tico)."
        })
      };
    }
    const hasPix = !!d0.destination_pix_key || !!d0.beneficiary?.pix_key;
    const hasGeneric = !!d0.destination;
    if (hasPix && hasGeneric) {
      return { statusCode: 400, body: JSON.stringify({ error: "Use destination_pix_key OU destination (n\xE3o ambos)." }) };
    }
    if (!hasPix) {
      return { statusCode: 400, body: JSON.stringify({ error: "TRANSFERENCIA exige destination_pix_key (ou beneficiary.pix_key)." }) };
    }
    if (!d0.beneficiary_id && !d0.beneficiary) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: "TRANSFERENCIA exige beneficiary_id OU beneficiary {name, document, pix_key}." })
      };
    }
    const orderIdempotency = data.idempotency_key ?? `order_${data.id}`;
    const existing = await prisma.core_orders.findFirst({
      where: { OR: [{ id: data.id }, { idempotency_key: orderIdempotency }] },
      include: { core_order_destinations: true, core_order_subtransactions: true }
    });
    if (existing) {
      return { statusCode: 200, body: JSON.stringify({ ok: true, order: existing, idempotent: true }) };
    }
    const created = await prisma.$transaction(async (tx) => {
      let beneficiaryId = d0.beneficiary_id ?? null;
      let beneficiaryName = null;
      let beneficiaryDocument = null;
      if (!beneficiaryId && d0.beneficiary) {
        const docDigits = ensureCpfCnpjDigits(d0.beneficiary.document);
        const newBenefId = import_crypto.default.randomUUID();
        await tx.core_beneficiaries.create({
          data: { id: newBenefId, customer_id: data.customer_id, name: d0.beneficiary.name, document: docDigits }
        });
        await tx.core_beneficiary_pix_keys.create({
          data: {
            id: import_crypto.default.randomUUID(),
            beneficiary_id: newBenefId,
            key_type: d0.beneficiary.key_type ?? "random",
            key_value: d0.beneficiary.pix_key,
            label: d0.beneficiary.label ?? d0.label ?? null,
            active: true
          }
        });
        beneficiaryId = newBenefId;
      }
      if (beneficiaryId) {
        const b = await tx.core_beneficiaries.findFirst({
          where: { id: beneficiaryId, customer_id: data.customer_id },
          select: { id: true, name: true, document: true }
        });
        if (!b) throw new Error(`beneficiary_id inv\xE1lido (n\xE3o encontrado ou n\xE3o pertence ao customer): ${beneficiaryId}`);
        beneficiaryName = b.name;
        beneficiaryDocument = ensureCpfCnpjDigits(b.document);
      }
      let destinationPixKey = d0.destination_pix_key ?? null;
      if (!destinationPixKey && d0.beneficiary?.pix_key) destinationPixKey = d0.beneficiary.pix_key;
      if (!destinationPixKey && beneficiaryId) {
        const k = await tx.core_beneficiary_pix_keys.findFirst({
          where: { beneficiary_id: beneficiaryId, active: true },
          orderBy: { created_at: "desc" },
          select: { key_value: true }
        });
        destinationPixKey = k?.key_value ?? null;
      }
      if (!destinationPixKey) throw new Error("N\xE3o foi poss\xEDvel resolver destination_pix_key para o benefici\xE1rio.");
      const order = await tx.core_orders.create({
        data: {
          id: data.id,
          customer_id: data.customer_id,
          customer_type: data.customer_type,
          bank_name: data.bank_name,
          type: "TRANSFERENCIA",
          kind: "SUPPLIER",
          total_amount: data.total_amount,
          sub_amount: data.sub_amount,
          base_amount,
          rate,
          fees_amount,
          base_currency,
          settlement_currency,
          status: "PENDING",
          idempotency_key: orderIdempotency,
          metadata: data.metadata ?? null,
          locked_amount_snapshot: null,
          started_at: null,
          completed_at: null,
          last_error: null,
          updated_at: /* @__PURE__ */ new Date()
        }
      });
      const destination = await tx.core_order_destinations.create({
        data: {
          id: import_crypto.default.randomUUID(),
          order_id: order.id,
          destination: d0.destination ?? "",
          destination_pix_key: destinationPixKey,
          label: d0.label ?? null,
          beneficiary_id: beneficiaryId,
          beneficiary_name: beneficiaryName,
          beneficiary_document: beneficiaryDocument,
          amount: null,
          destination_type: d0.destination_type ?? "AUTO"
        }
      });
      const parts = chunkAmount(data.total_amount, data.sub_amount);
      await Promise.all(
        parts.map(
          (part, i) => tx.core_order_subtransactions.create({
            data: {
              id: import_crypto.default.randomUUID(),
              order_id: order.id,
              status: "PENDING",
              amount: part,
              index: i + 1,
              bank_account_id: data.bank_account_id,
              destination_id: destination.id,
              destination_pix_key: destination.destination_pix_key ?? null,
              destination: destination.destination ?? null,
              beneficiary_name: beneficiaryName,
              beneficiary_document: beneficiaryDocument,
              idempotency_key: import_crypto.default.randomUUID(),
              attempts: 0,
              next_retry_at: null,
              execution_metadata: null,
              last_error: null,
              provider_ref: null,
              executed_at: null,
              updated_at: /* @__PURE__ */ new Date()
            }
          })
        )
      );
      const full = await tx.core_orders.findUnique({
        where: { id: order.id },
        include: {
          core_order_destinations: true,
          core_order_subtransactions: { orderBy: { index: "asc" } }
        }
      });
      return full;
    });
    return { statusCode: 201, body: JSON.stringify({ ok: true, order: created }) };
  } catch (err) {
    console.error("createSupplierOrder error:", err);
    return { statusCode: 500, body: JSON.stringify({ error: "Internal error", details: err?.message || String(err) }) };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createSupplier
});
/*! Bundled license information:

@prisma/client/runtime/binary.js:
  (*! Bundled license information:
  
  undici/lib/web/fetch/body.js:
    (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
  
  undici/lib/web/websocket/frame.js:
    (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.5.0
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=createSupplier.js.map
